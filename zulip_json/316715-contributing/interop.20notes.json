[
    {
        "content": "<p>so i think my interop is about ready (which is more thorough than the previous so required a more thourough dive into some topics), <br>\nthought i'd share with you a couple of notes i've taken<br>\nmight be useful for either future interops/ hosts or glue writing/ compiler changes (maybe? see first note about inconsistent layouts (flipped ret position) and second about unnamed types)</p>\n<ol>\n<li>\n<p>requiring multiple function from the application - via record<br>\nnote from the host side it will require a different argument layout than what you used for a singular function<br>\ne.g:<br>\nsingle function - <code>extern void roc__interpolateStringy_1_exposed_generic(struct RocStr *ret, struct RocStr *name)</code><br>\nrecord style - <code>extern void roc__programForHost_1__InterpolateString_caller(struct RocStr *name, char *closure_data, struct RocStr *ret)</code><br>\nwhere both the arguments are fliped and there's a third closure_data argument (to which you'd probably pass 0 if you don't do closures)</p>\n</li>\n<li>\n<p>when declaring the program functions record in the roc platform file, name the types (<code>as</code>), for example <code>interpolateString : (Str -&gt; Str) as InterpolateString</code>, otherwise (as the time of writing this) roc doesn't really generate them.</p>\n</li>\n<li>\n<p>careful what you release/ delete. in some VMs, let's say you use a builtin binding to do something, e.g Java's string constructor, you do not need at all to delete a local ref you made to it.<br>\nlet the jvm take care of it. misuse will result in nasty segfaults. consult ffi docs ofc</p>\n</li>\n<li>\n<p>might be obvious if you know but compile the .roc side with <code>--no-link</code> to compile to .o files which can then be coupled together with the host code. i messed around with <code>--lib</code> and linking shared libs when i didn't know about it. this is much much cleaner and better than having to carry around another shared lib</p>\n</li>\n<li>\n<p>roc_panic could be tricky since it's a no return function (that is obviously not exported to the vm, so it can't do some vm stuff), but you need to propagate the crash back to the vm. one possible solution is, from the wrapper to the function that might crash, when calling the platform, put a setjump. if it indeed crashed and went on to roc_panic, longjmp from roc_panic back to the exported vm function so you could propagate it back up.</p>\n</li>\n</ol>\n<p>hope it'd be of use</p>",
        "id": 343237566,
        "sender_full_name": "dank",
        "timestamp": 1679351130
    }
]