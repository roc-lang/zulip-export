[
    {
        "content": "<p>I think this is a complicated issue and I don't think <code>Maybe</code>/<code>Option</code> is the obvious answer. I think the downsides are subtle and nonobvious.</p>",
        "id": 571059470,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1769787075
    },
    {
        "content": "<p>for example, a potential design we could consider is having encoding and decoding have a special concept of \"optional\" tag unions, which are defined as tag unions with exactly 2 tags, where one of them has a payload of exactly one value and the other has no payload (so, the same shape as <code>Option</code>/<code>Maybe</code>/etc.)</p>",
        "id": 571060714,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1769787367
    },
    {
        "content": "<p>at that point, the json library doesn't need to be coupled to an <code>Option</code> or a <code>Maybe</code> type, and you can use more descriptive things in your data model than <code>Some</code>/<code>None</code>, e.g. <code>Found</code>/<code>NotFound</code>, <code>Provided</code>/<code>Omitted</code>, <code>Present</code>/<code>Absent</code>, <code>Available</code>/<code>Unavailable</code>, etc.</p>",
        "id": 571061042,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1769787439
    },
    {
        "content": "<p>I don't love that idea. <br>\nI actually agree that being more specific is good. However there are a few big concerns i have with that.</p>\n<ol>\n<li>Compiler only: This is a feature not available to library authors, it's a special case inside the compiler that people have to learn, it feels like a hack.</li>\n<li>Option types aren't just about encode/decode: mapping the Some variant, converting the none to a result with a specific error. all of this presumably would need more special compiler magic or not be available.</li>\n<li>Unintuitive behaviour: What if i really did just want a tag union with that shape and now it's suddenly getting encoded in an unexpected way? That's weird and annoying and i don't see a solution when that's happening, without introducing some additional language construct or type system feature.</li>\n</ol>\n<p>Another option would be to just use a result right? <br>\nI do have some objections to that too</p>\n<ol>\n<li>optionality is a real world property that needs to be modeled. A thing can exist or not exist. This is common, and very different to failure. Something not existing is not necessarily an error state and calling it one feels confused.</li>\n<li>Options can now combine with errors, which again feels wrong, like if I do a http request to check if the fridge has milk. No milk, is not really at all related to 500. One is data representing the world, the other is a software fault.</li>\n</ol>\n<p>Just so we're clear I'm fully onboard with trying to find a better alternative and exploring solutions, but obviously thaey have to be better than the status quo, and I think being harshly critical is a good way to figure out if an idea is worth implementing.</p>\n<p>I've also considered implementing option in terms of result, just with type aliases None:Err(None) and Some(a):Ok(a). I feel like that keeps error accumulation (if that's wanted) without having the weirdness of none being a failure. I don't like that much either. but it's a thought.</p>",
        "id": 571082640,
        "sender_full_name": "Eli Dowling",
        "timestamp": 1769793081
    },
    {
        "content": "<p>Should this maybe be moved to an ideas discussion? I don't have permissions to do that.</p>",
        "id": 571082715,
        "sender_full_name": "Eli Dowling",
        "timestamp": 1769793106
    },
    {
        "content": "<p>yeah those are all good points!</p>",
        "id": 571104495,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1769799985
    },
    {
        "content": "<p>I think not having <code>Option</code> or similar in the stdlib has been <em>great</em> for return values, because it's so clear that all \"this operation failed\" APIs should standardize on one type and one way to do it</p>",
        "id": 571105390,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1769800222
    },
    {
        "content": "<p>the main reasons I'm trying to find alternatives to <code>Option</code> for these use cases (which I certainly agree are important!) are: </p>\n<ul>\n<li>Not wanting to lose \"there's one obvious way to do it\" when it comes to return types. It's possible that our <code>?</code> operator combined with the stdlib being consistent about this will be sufficient to prevent that from happening - e.g. \"Why would I return <code>Option</code>? Then I miss out on <code>?</code> and failure tag union accumulation!\"</li>\n<li>opportunity cost compared to other designs. For example, some languages have a more first-class \"optional type\" concept which can be used for things like optional record fields. (Default record fields ended up not working out for structural types, but similar features have totally different tradeoffs when it comes to nominal records, which we now have, and we haven't reevaluated the design space there since adding nominal records.)</li>\n</ul>",
        "id": 571106559,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1769800625
    },
    {
        "content": "<p>but I think if we pull the trigger on adding <code>Option</code> to the stdlib, it will become entrenched and potentially better designs will never get explored properly.</p>",
        "id": 571106741,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1769800685
    },
    {
        "content": "<p>one concrete design question: supposing we added support for a concept of \"optional record fields\" (not just default, but actually optional where if you omit the field when passing the record to a function, the function can actually tell at runtime whether the field was present or missing</p>",
        "id": 571107402,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1769800909
    },
    {
        "content": "<p>if we had that, would we still want <code>Option</code>? If so, for what? e.g. JSON happens to make a distinction between \"field was present but <code>null</code> vs field was missing\" but does that matter from a decoding perspective? And does it matter from an encoding perspective if you can just tell the <code>encode</code> function \"use <code>null</code> when I omit a field\"?</p>",
        "id": 571107705,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1769801013
    },
    {
        "content": "<p>19 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"316715\" href=\"/#narrow/channel/316715-contributing/topic/Worklog.20.28Draft.20PRs.20and.20coordination.29/with/570435779\">#contributing &gt; Worklog (Draft PRs and coordination)</a> by <span class=\"user-mention silent\" data-user-id=\"341568\">Jared Ramirez</span>.</p>",
        "id": 571116414,
        "sender_full_name": "Notification Bot",
        "timestamp": 1769804186
    },
    {
        "content": "<p>I definitely agree with you there! And I think in the short term a non-stdlib option type, in a package is the way to go. I think that makes it clear that its \"a solution\" not \"the solution\" and that things can change.</p>\n<p>When writing the json decoder I would include a specific \"json option\" tag union with <code>[null, undefined, value(a)]</code><br>\nAnd then also include an option to choose whether normal option becomes null (this should be the default), or undefined.</p>\n<p>I think there are rare cases where you want granular control and we should provide it to you. </p>\n<p>In fact maybe we should include an \"encoding option\" because many formats have a differnce between null and missing. <br>\nYaml <br>\nXml had XSI:null vs no tag</p>\n<p>We could say \"this will make a best effort to encode as whatever null is in your output langauge, but for some it may be the same as undefined\" </p>\n<p>As for optional record fields I think it would be great if there was a way to have optional fields that supported structural and nominal types. Restricting it to nominal types would make most deserialization and serialization require nominal types which I think would be a shame. I think if would reduce the use of structural types significantly. If they aren't at the edge of your code they likely just won't be used as much inside.</p>",
        "id": 571142101,
        "sender_full_name": "Eli Dowling",
        "timestamp": 1769816362
    },
    {
        "content": "<p>we had defaultable fields in structural records in the original Rust compiler, and my conclusion based on how it went is that it wasn't a good idea after all</p>",
        "id": 571514957,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1770062563
    },
    {
        "content": "<p>does current roc have a 'spread' operator that would let you do a rust-style:</p>\n<div class=\"codehilite\"><pre><span></span><code>thing = Thing {\n  color: Red,\n  ..Thing.default(),\n}\n</code></pre></div>",
        "id": 571518239,
        "sender_full_name": "Dan G Knutson",
        "timestamp": 1770063855
    },
    {
        "content": "<p><a href=\"https://github.com/roc-lang/roc/issues/7097\">https://github.com/roc-lang/roc/issues/7097</a></p>",
        "id": 571519234,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1770064243
    },
    {
        "content": "<p>yes that is the plan I believe</p>\n<div class=\"codehilite\"><pre><span></span><code>updatedRecord = { foo: 123, bar: &quot;abc&quot;, ..record }\n</code></pre></div>",
        "id": 571519291,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1770064266
    }
]