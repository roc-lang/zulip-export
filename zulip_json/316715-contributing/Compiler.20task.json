[
    {
        "content": "<p>I'm ready for a main quest compiler task (on Monday), what's available?</p>",
        "id": 554498584,
        "sender_full_name": "Anton",
        "timestamp": 1762623418
    },
    {
        "content": "<p>builtins! <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 554502302,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1762627078
    },
    {
        "content": "<p>any interest in fleshing those out?</p>",
        "id": 554502325,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1762627094
    },
    {
        "content": "<p>We can add those piecemeal right? Like add a new builtin fn, add some tests etc and that's a PR</p>",
        "id": 554515407,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1762641023
    },
    {
        "content": "<p>yep! Once this PR for lists lands</p>",
        "id": 554515841,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1762641538
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/channel/316715-contributing/topic/Compiler.20task/near/554502302\">said</a>:</p>\n<blockquote>\n<p>builtins! <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>\n</blockquote>\n<p>Perfect :)</p>",
        "id": 554646805,
        "sender_full_name": "Anton",
        "timestamp": 1762764907
    },
    {
        "content": "<p>I'm interested in working on the string builtins, but it seemed like the low_level_interp tests weren't running when I messed around with them. Are those in a ready-to-get-picked-up state?</p>",
        "id": 555245694,
        "sender_full_name": "Dan G Knutson",
        "timestamp": 1762992795
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"361169\">@Anton</span> recently fixed that!</p>",
        "id": 555257982,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763001860
    },
    {
        "content": "<p>No, the low_level_interp_test.zig is <a href=\"https://github.com/roc-lang/roc/blob/cea6d56329a52c941f752055b48c785655a17fdd/ci/check_test_wiring.zig#L17\">an exception to the new CI test check</a>. I was not able to debug it to get it working again on the first try, but I can focus on that today.</p>",
        "id": 555293001,
        "sender_full_name": "Anton",
        "timestamp": 1763022782
    },
    {
        "content": "<p>Feel free to go ahead with string builtins without adding a test in low_level_interp_test.zig. Please share the specific builtin you want to add here before starting to avoid double work <span class=\"user-mention\" data-user-id=\"430894\">@Dan G Knutson</span> <span class=\"user-mention\" data-user-id=\"986975\">@Edwin Santos</span>.</p>",
        "id": 555305008,
        "sender_full_name": "Anton",
        "timestamp": 1763026152
    },
    {
        "content": "<p>I will do <code>Str.concat</code></p>",
        "id": 555325232,
        "sender_full_name": "Anton",
        "timestamp": 1763031717
    },
    {
        "content": "<p>oh ok I'll take care of that test then</p>",
        "id": 555343925,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763037484
    },
    {
        "content": "<p>I have a bunch of changes on my current branch that will affect it</p>",
        "id": 555343986,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763037503
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/channel/316715-contributing/topic/Compiler.20task/near/555343925\">said</a>:</p>\n<blockquote>\n<p>oh ok I'll take care of that test then</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"281383\">@Richard Feldman</span> I already fixed some Str.is_empty test failures when you sent this and I thought I was close to finishing the whole thing so I continued :p Several hours later all low_level_interp_tests pass now. I'm not sure about the branches I added to src/eval/interpreter.zig though (<a href=\"https://github.com/roc-lang/roc/pull/8378\">PR#8378</a>). Anyway, I basically just put it for inspiration, feel free to do with it what you like :)</p>",
        "id": 555398009,
        "sender_full_name": "Anton",
        "timestamp": 1763050147
    },
    {
        "content": "<p>Essentially any methods in the String documentation which aren't part of RocStr in builtins/str.zig are up for grabs correct? If so I'll start on <code>Str.repeat</code> then!</p>",
        "id": 555424060,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1763056636
    },
    {
        "content": "<p>Yes, go ahead :)</p>",
        "id": 555424832,
        "sender_full_name": "Anton",
        "timestamp": 1763056885
    },
    {
        "content": "<p>Reading some of the messages about trying to get the compiler ready before AoC.. I just can't sit on the sidelines! I was eying with strCaselessAsciiEquals, strWithAsciiLowercased, strWithAsciiUppercased, because I've made them for the rust compiler, so I can probably figure them out for the new one, though I haven't really touched it yet. Is following your footsteps on <a href=\"https://github.com/roc-lang/roc/issues/8380\">#8380</a> a good way <span class=\"user-mention\" data-user-id=\"361169\">@Anton</span>?</p>",
        "id": 555472807,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1763074226
    },
    {
        "content": "<p>Hey y'all, an implementation for Repeat is already in builtins/str.zig, does this mean that integration into build/roc/Builtin.roc and testing is all that's left to complete adding this builtin? I'll finish that stuff up if so.</p>\n<p>I'll also start on Str.with_prefix  since that doesn't have an implementation yet.</p>",
        "id": 555476773,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1763076314
    },
    {
        "content": "<p>Thanks for helping out <span class=\"user-mention\" data-user-id=\"577599\">@Norbert Hajagos</span>, yes <a href=\"https://github.com/roc-lang/roc/issues/8380\">#8380</a> should be a good guide. A bunch of tests will not work but just filling things out and making a draft PR is already helpful. Once we get a nice fix for low_level_interp_test in place we can fix up all the builtin PRs.</p>",
        "id": 555543451,
        "sender_full_name": "Anton",
        "timestamp": 1763113397
    },
    {
        "content": "<blockquote>\n<p>an implementation for Repeat is already in builtins/str.zig</p>\n</blockquote>\n<p>So builtins/str.zig is for use in compiled Roc binaries (so not used by the interpreter). I did notice <code>repeatC</code> does not have a unit test in that file yet, can you add one <span class=\"user-mention\" data-user-id=\"986975\">@Edwin Santos</span>?</p>",
        "id": 555544947,
        "sender_full_name": "Anton",
        "timestamp": 1763113870
    },
    {
        "content": "<blockquote>\n<p>So builtins/str.zig is for use in compiler Roc binaries.</p>\n</blockquote>\n<p>See <a href=\"https://github.com/roc-lang/roc/issues/8380\">#8380</a> for which files you need to later to provide the implementation for the interpreter.</p>",
        "id": 555545038,
        "sender_full_name": "Anton",
        "timestamp": 1763113902
    },
    {
        "content": "<p>Some builtins can be implemented in Roc (like <code>fold</code> in src/build/roc/Builtin.roc) whereas others should be implemented in <a href=\"https://github.com/roc-lang/roc/blob/3e9c0de4c2666391fac4db950234432112001b35/src/eval/interpreter.zig#L2358\">interpreter.zig</a>. How should this decision be made <span class=\"user-mention\" data-user-id=\"281383\">@Richard Feldman</span>?</p>",
        "id": 555545676,
        "sender_full_name": "Anton",
        "timestamp": 1763114101
    },
    {
        "content": "<p>Like I said, new to this compiler. Is there a reason we have 2 implementation for the builtins, one for the interpreter, one fore the compiler? Skimming your PR, it seems the compiled version does extra uniqueness checks to reuse one of the strings if possible for performace reasons, and the interpreted version does not. Is there a reason the interpreted doesn't import the builtins from the compiled version and wraps them with some interpreter-specific work, like allocating the result on the stack?</p>",
        "id": 555547587,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1763114640
    },
    {
        "content": "<p>Good question! I actually don't know, can one of you provide the answer <span class=\"user-mention\" data-user-id=\"281383\">@Richard Feldman</span> <span class=\"user-mention\" data-user-id=\"341568\">@Jared Ramirez</span> <span class=\"user-mention\" data-user-id=\"515757\">@Luke Boswell</span>?</p>",
        "id": 555549772,
        "sender_full_name": "Anton",
        "timestamp": 1763115314
    },
    {
        "content": "<p>I am checking the src right now. It seems some functions are actually reused, like <a href=\"https://github.com/roc-lang/roc/blob/b69a3c8a980f05544832fd768c0818aaf0158104/src/eval/interpreter.zig#L2436\">builtins.list.listGetUnsafe</a>, so I think you can safely reuse your more performant implementation as well.</p>",
        "id": 555550390,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1763115495
    },
    {
        "content": "<p>Yes, looking more thoroughly there are a bunch of cases like this. builtins.list.listIsEmpty, builtins.list.listLen, builtins.list.listConcat, etc...<br>\nDidn't mean to turn this into a code review, I'm grateful that you've made such an atomic change I can base my work on  <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 555551655,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1763115885
    },
    {
        "content": "<p>Yeah, you are correct <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span> I implemented things in a different order and forgot to update my original implementation.</p>",
        "id": 555551915,
        "sender_full_name": "Anton",
        "timestamp": 1763115962
    },
    {
        "content": "<p>I'll fix it</p>",
        "id": 555552311,
        "sender_full_name": "Anton",
        "timestamp": 1763116074
    },
    {
        "content": "<p>I know why I did not call builtins.str.strConcat, I removed the call to builtins.list.listConcat in my hacky fix branch fix-low-level-interp-failures to make it work.</p>",
        "id": 555553970,
        "sender_full_name": "Anton",
        "timestamp": 1763116546
    },
    {
        "content": "<p>Let's pause the addition of builtins until <span class=\"user-mention\" data-user-id=\"281383\">@Richard Feldman</span> can get a proper fix for src/eval/test/low_level_interp_test.zig in place.</p>",
        "id": 555554072,
        "sender_full_name": "Anton",
        "timestamp": 1763116579
    },
    {
        "content": "<p>I'm planning to work on builtins after work hours today. Is this a blocker because tests can't pass, or something more fundamental?</p>",
        "id": 555559714,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1763118073
    },
    {
        "content": "<p>Adding implementations to the interpreter using the existing ones as a guide seems counterproductive given that the existing ones do not work.</p>",
        "id": 555565079,
        "sender_full_name": "Anton",
        "timestamp": 1763119866
    },
    {
        "content": "<p>I see. Will just poke the compiler here and there to see how things work.</p>",
        "id": 555579837,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1763124754
    },
    {
        "content": "<p>Hi, just wanted to update that I'm currently working on implementations/tests for:<br>\nStr.repeat<br>\nStr.with_suffix<br>\nStr.drop_suffix<br>\nStr.drop_prefix</p>\n<p>Will just tinker with other stuff while waiting for the low level interpreter tests to be unblocked.</p>",
        "id": 556894673,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1763401452
    },
    {
        "content": "<p>2 Questions:</p>\n<p>I've noticed that for a lot of the string functions, Str.decref is called on certain paths but not on others, and .incref is seldom called (in str.zig, just in strSplitOnHelp). Could someone explain a bit what the procedure is for handling the refcount? I understand not needing to alter it when you're returning newly allocated strings for example, but some which return slices like the trim methods don't seem to be explicitly increasing the refcount which i'm a lil confused about.</p>\n<p>2nd question, is it safe if you uniquely hold a string to shift it's bytes pointer and decrease it's capacity to shorten the string's \"window\" from the front?  strTrimStart trims the front by creating a new RocStr with a shifted bytes pointer (but the capacity_or_alloc_ptr is the original one). Shifting the pointer and decreasing the capacity accordingly if the string is unique and not a slice and returning the same input string seems like a viable route on my naive understanding. Not ultra familiar with low-level so not sure if that's dangerous tho <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 556897254,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1763402254
    },
    {
        "content": "<p>I'm not familiar with low level as well, but from what I understand, as long as the refcount is 1, you can do whatever you want with it. So yeah, I think you got q2 nailed down. I need to run and I don't have an immadiate answer to q1.</p>",
        "id": 556898986,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1763402731
    },
    {
        "content": "<p>Yeah, I assume that my idea from q2 from shifting the bytes pointer + changing the capacity when RocStr is Unique + not a slice is probably not that much faster than allocating a RocStr with those couple pointers but if this is sound/not dangerous it'd be good to throw in. Mostly wasn't sure if this would actually set off a grenade or something haha.</p>",
        "id": 556900245,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1763403182
    },
    {
        "content": "<p>Also on q1 when someone has a chance to give a definitive answer, are increments happening before calling these functions and decrements happening inside the functions (under the right circumstances)? I'm thinking of something like strTrim where if the entire string would be trimmed (in the first couple lines), an empty string is returned and the input string is decref'd. This makes sense to me if the string's refcount is incremented prior to it being passed to the function (the function doesn't increment the refcount beforehand), but if not then I'm a little lost why the function would decrement the refcount on that path.</p>\n<p>Increments before being passed into functions or auto-refcounting like a Rust RC pointer was my hypothesis on why there's so many decrefs without increfs but wanted to check if this is on the right track.</p>",
        "id": 556901467,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1763403544
    },
    {
        "content": "<p>1 thing I'm not sure about is whether that would lead to problems when we are freeing the str. I don't have time today, sorry for just dropping in vague advices. Follow the decref method in RocStr and see if it would cause problems that the bytes pointer points to further ahead than the original allocation.</p>",
        "id": 556911798,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1763407004
    },
    {
        "content": "<p>I should be able to give answers, just don't have time right now. Will try to loop back in a few hours</p>",
        "id": 556931931,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1763414168
    },
    {
        "content": "<p>Thanks! No rush, was just asking questions on my lunch break haha.</p>",
        "id": 556933249,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1763414790
    },
    {
        "content": "<blockquote>\n<p>I've noticed that for a lot of the string functions, Str.decref is called on certain paths but not on others, and .incref is seldom called (in str.zig, just in strSplitOnHelp).</p>\n</blockquote>\n<p>In roc, each builtin low level function specifies whether or not it takes the input <a href=\"https://github.com/roc-lang/roc/blob/6e50ca09fa8c0485cabe85b39a886228c80008ee/crates/compiler/mono/src/inc_dec.rs#L1260-L1368\">via ownership or via reference</a> (only implemented in the old compiler currently).</p>\n<p>Generally speaking, if there is any chance of mutation, they pick ownership. The roc compiler we automatically generate <code>incref</code> calls before calling the function if needed. This enables the compiler to automatically optimize away incref calls if they aren't needed. <br>\nInstead of:</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s2\">\"some long string with refcount\"</span>\n<span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">call_builtin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"c1\"># builtin internally calls incref</span>\n<span class=\"n\">decref</span><span class=\"w\"> </span><span class=\"n\">x</span>\n</code></pre></div>\n<p>we generate:</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s2\">\"some long string with refcount\"</span>\n<span class=\"c1\"># Already unique ownership, no need to call incref here</span>\n<span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">call_builtin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"c1\"># Builtin took ownership (and maybe called decref), no need to call decref here</span>\n</code></pre></div>",
        "id": 556965796,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1763432223
    },
    {
        "content": "<blockquote>\n<p>Could someone explain a bit what the procedure is for handling the refcount?</p>\n</blockquote>\n<p>I am not sure how things are wired into the interpreter, currently, but likely, it should follow a similar partern. Explicitly have a list of functions that take the RocStr by ownership and for that list call incref before calling the builtin low level function. This will avoid needing two versions of the builtins (one for the interpreter and one for linking to compiled applications)</p>",
        "id": 556965876,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1763432325
    },
    {
        "content": "<blockquote>\n<p>but some which return slices like the trim methods don't seem to be explicitly increasing the refcount which i'm a lil confused about.</p>\n</blockquote>\n<p>Yeah, given trim expects to mutate it takes by ownership. Then it trims and returns a slice (which just passes on the ownership).</p>",
        "id": 556965977,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1763432408
    },
    {
        "content": "<blockquote>\n<p>2nd question, is it safe if you uniquely hold a string to shift it's bytes pointer and decrease it's capacity to shorten the string's \"window\" from the front?</p>\n</blockquote>\n<p>No. Cause when you go to free the string you would free the wrong bytes.</p>\n<blockquote>\n<p>strTrimStart trims the front by creating a new RocStr with a shifted bytes pointer (but the capacity_or_alloc_ptr is the original one).</p>\n</blockquote>\n<p>If I understand your comment correctly, that is not actually a new RocStr. That is a seamless slice. Essentially, it is a reference to the original string that still knows about the original allocation so it can free it.</p>\n<p>The other option would be to keep it as a regular string but memcpy the entire string over to remove the trimmed bytes.</p>\n<p>That said, I didn't double check the code here, so I may be missing something with how it is setup currently.</p>",
        "id": 556966459,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1763432674
    },
    {
        "content": "<p>Yeah, I'm pretty sure from a quick skim of the code that StrTrimStart will never allocate. It will return a shifted small string or a seamless slice. Technically if the string is unique, we could shift it instead of creating a seamless slice, but that is not clearly worth it.</p>",
        "id": 556966636,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1763432819
    },
    {
        "content": "<blockquote>\n<p>Also on q1 when someone has a chance to give a definitive answer, are increments happening before calling these functions and decrements happening inside the functions (under the right circumstances)?</p>\n</blockquote>\n<p>Yep, exactly. Not actually sure the state of this in the interpreter though. But we need to add it if it is not currently working.</p>",
        "id": 556966770,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1763432908
    },
    {
        "content": "<p>Hopefully that gives some base answers.</p>",
        "id": 556966813,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1763432945
    },
    {
        "content": "<p>Feel free to ask more questions or for clarifications.</p>",
        "id": 556966822,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1763432955
    },
    {
        "content": "<p>Have we got these builtins wired into the interpreter yet? It's been a few weeks since I checked, but I thought that was what Richard is currently working on</p>",
        "id": 556969950,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1763435516
    },
    {
        "content": "<p>I'm not sure the exact state. I know richard was working on getting the infrastructure in to add builtins. Then he want other folks to add more builtins.</p>",
        "id": 556970084,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1763435608
    },
    {
        "content": "<p>Ahk, cool. I can see we are using these builtins already in some places.</p>",
        "id": 556970263,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1763435732
    },
    {
        "content": "<p>All the action is in <code>callLowLevelBuiltin</code> in src/eval/interpreter.zig</p>",
        "id": 556970321,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1763435763
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"343810\">@Brendan Hansknecht</span> Thanks so much for the explanation, this clarifies a lot. Also currently it looks like most of the standard lib str functions are taking RocStr by value instead of by reference. Also yeah I was thinking that changing the pointer to the original allocation might end up mucking something up when memory is being freed, I guess one way to put it is that there always needs to be a pointer to the beginning of the original allocation to ensure it's eventually correctly deallocated. Super helpful!</p>",
        "id": 557995341,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1763485701
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515757\">Luke Boswell</span> <a href=\"#narrow/channel/316715-contributing/topic/Compiler.20task/near/556969950\">said</a>:</p>\n<blockquote>\n<p>Have we got these builtins wired into the interpreter yet? It's been a few weeks since I checked, but I thought that was what Richard is currently working on</p>\n</blockquote>\n<p>Currently I think we're waiting on some failing tests for low_level_interp to be fixed, we're starting to work out the actual functions in builtins/ but integrating them with the interpreter is the main blocker before we can PR additions to the builtins.</p>",
        "id": 557995690,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1763485797
    },
    {
        "content": "<p>One more quick question, if you have a function returning a substring from a RocStr (any of them like drop_prefix, trim, etc), do y'all think it'd be more optimal to return a smallstr instead of a seamless slice if the string would fit into a smallstr? Currently the trim functions for example are mostly returning slices but wasn't sure if it might be a little better to try to pack them into smallstr's if possible since the resulting RocStr would be fully on stack. Maybe the memcopy is such that this wouldn't make a huge difference tho.</p>",
        "id": 557996467,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1763486013
    },
    {
        "content": "<p>I think if it fits into a small string then it should be that. No extra pointer chasing when accessing it. I assume the time saved to access those strings possibly multiple times outweighs the cost of creating them.</p>\n<p>It also unlocks further optimizations later, . Example: <br>\nThe program can call <code>my_small_str.with_acsii_bytes_uppercased()</code> and when that built-in sees a small string, it will uppercase the bytes and return a small string. When it sees a non-small string, it will not assume that it could return a small string after uppercasing, since that function does not reduce the size of the string.</p>",
        "id": 558005362,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1763488201
    },
    {
        "content": "<blockquote>\n<p>RocStr by value instead of by reference</p>\n</blockquote>\n<p>So this is where wording is a bit confusing cause there is value/reference as in <code>RocStr</code>/<code>&amp;RocStr</code>. and there is owned/reference as in calling <code>incref</code> before calling a function or just calling the function.</p>\n<p>In general <code>RocStr</code> should always be passed by value as <code>RocStr</code> instead of <code>&amp;RocStr</code> or <code>*RocStr</code>.</p>\n<p>When it comes to owned/reference, that is what depends on the specific function. If the function is read only. (like Str.len), it should be by reference. If the function wants to mutate (or return a referencing subslice), it should be owned.</p>",
        "id": 558011553,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1763489803
    },
    {
        "content": "<blockquote>\n<p>I guess one way to put it is that there always needs to be a pointer to the beginning of the original allocation to ensure it's eventually correctly deallocated</p>\n</blockquote>\n<p>Exactly</p>",
        "id": 558012535,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1763490075
    },
    {
        "content": "<blockquote>\n<p>if you have a function returning a substring from a RocStr (any of them like drop_prefix, trim, etc), do y'all think it'd be more optimal to return a smallstr instead of a seamless slice if the string would fit into a smallstr?</p>\n</blockquote>\n<p>The answer is sadly, \"it depends\" in my testing.</p>\n<p>A lot of times, the substring is used in a way that the copy is not worth it. It is short lifetime and the main string is still in cache. From my limited testing, this is most common. So the copy is not worth it.</p>\n<p>The longer the slice stays around the more it is worthwhile to copy. Copying means you might be able to free the original string (reduced memory overhead); you don't have to worry about things falling out of cache; and you avoid a pointer round trip.</p>\n<p>Especially with the functions that return many strings (like splitting by spaces), I saw returning slices as a really large gain in genereal. For the trim and drop functions... I'm not really sure what is best. This is where you would really prefer to have tons of real world cases running in CI on a lot of different hardware to measure.</p>",
        "id": 558013344,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1763490312
    },
    {
        "content": "<blockquote>\n<p>my_small_str.with_acsii_bytes_uppercased()</p>\n</blockquote>\n<p>If it sees a slice. It should first make the slice unique. Which will turn it into a small string. Then it will uppercase. So it really is just a lazy copy instead of a copy right at the beginning. That said, in a perfect world, it would see the slice and then generate a new small string that uppercases as it copies and would perform one less iteration overall. So I think (ignoring a cache miss), the slice has more opportunities to be performant than creating a small string first.</p>",
        "id": 558013686,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1763490435
    },
    {
        "content": "<p>Yeah, looks like that function technically has an extra iteration right now that we could avoid. It first copies then it uppercases. It could do both at the same time.</p>",
        "id": 558014196,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1763490600
    },
    {
        "content": "<p>Where'd we be without you Brendan? <span aria-label=\"smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"smile\">:smile:</span> Always a pleasure to read your performance insights.</p>",
        "id": 558022284,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1763493113
    },
    {
        "content": "<p>I'm glad I can at least answer questions even if not contributing to roc significantly in code.</p>",
        "id": 558099199,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1763516585
    },
    {
        "content": "<p>ok I just got low_level_interp fixed finally - that took way longer than anticipated! <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 558929850,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763939691
    },
    {
        "content": "<p>I believe adding more builtins should now be unblocked but lmk if you hit anything!</p>",
        "id": 558929863,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763939702
    },
    {
        "content": "<p>I want to try and get my zig template online... that should be nice an minimal</p>",
        "id": 558930033,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1763939944
    },
    {
        "content": "<p>Is that the zig platform template?</p>",
        "id": 558993200,
        "sender_full_name": "Anton",
        "timestamp": 1763977507
    },
    {
        "content": "<p>Yup, that's the one</p>",
        "id": 558998993,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1763978993
    },
    {
        "content": "<p>I've been getting distracted just trying out the new compiler with that fx test platform... so cool</p>",
        "id": 558999168,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1763979045
    },
    {
        "content": "<p>Str.concat is <a href=\"https://github.com/roc-lang/roc/commit/977a26b7036479789d583744ff86f80a0adfc714\">done</a></p>",
        "id": 559094312,
        "sender_full_name": "Anton",
        "timestamp": 1764001774
    },
    {
        "content": "<p>nice, that's a very nice template for other things people might want to add <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 559095440,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764002021
    },
    {
        "content": "<p>I've got a version of Str.trim on a branch following that formula. Could I get permissions to push a branch? I had them on a previous OS/gpg key, but haven't contributed in a while. I'm 'giesch' on github.</p>",
        "id": 560051708,
        "sender_full_name": "Dan G Knutson",
        "timestamp": 1764034145
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"430894\">@Dan G Knutson</span> great to see you again -- hyped to update our graphics / gaming platform soon <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 560052126,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764034478
    },
    {
        "content": "<p>Hi, is this a good minimal PR to look at to learn how to add a builtin? <a href=\"https://github.com/roc-lang/roc/pull/8436\">https://github.com/roc-lang/roc/pull/8436</a><br>\nAny documentation elsewhere? I might look into adding builtins for integers if I get the time.</p>",
        "id": 560265679,
        "sender_full_name": "Matthieu Pizenberg",
        "timestamp": 1764110913
    },
    {
        "content": "<p>Yes I think so</p>",
        "id": 560265711,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764110935
    },
    {
        "content": "<p>Hi y'all, in a bit I'm going to setup a PR for Str.drop_prefix, drop_suffix, repeat, and with_prefix. Could someone give it a review once it's up? On drop_prefix specifically I'm getting an issue with the refcount I think that's causing a segfault and Not sure what to do. I structured drop_prefix like the Trim functions so I'm having a hard time debugging what could be going wrong.</p>\n<p>Will put up a PR soon!</p>",
        "id": 560277912,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1764118204
    },
    {
        "content": "<p>I've got a draft PR up with those <a href=\"https://github.com/roc-lang/roc/pull/8440\">https://github.com/roc-lang/roc/pull/8440</a></p>",
        "id": 560277954,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764118230
    },
    {
        "content": "<p>ahk haven't pushed all of those yet</p>",
        "id": 560278022,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764118273
    },
    {
        "content": "<p>Should I keep going with my implementation or just leave it to you?</p>",
        "id": 560278074,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1764118308
    },
    {
        "content": "<p>Well Claude and I will probably be done in like 5 mins -- would you be happy to give it a review?</p>",
        "id": 560278137,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764118341
    },
    {
        "content": "<p>I'd be happy to give it a review, I don't know if I have permissions to approve PRs into main tho.</p>",
        "id": 560278244,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1764118402
    },
    {
        "content": "<p>That's ok, just leave a comment if you seen anything strange or if you think it looks good</p>",
        "id": 560278286,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764118426
    },
    {
        "content": "<p>Sure!</p>",
        "id": 560278351,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1764118454
    },
    {
        "content": "<p>I think that PR is good for a review now, I'm going to start on the other <code>Str</code> builtins in another PR now</p>",
        "id": 560278378,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764118470
    },
    {
        "content": "<p>Other than string builtins are there any other builtins or core compiler functions to build out before December 1st?</p>",
        "id": 560280613,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1764119702
    },
    {
        "content": "<p>Yeah there's a lot, like <code>Set</code> <code>Dict</code> lots of <code>List</code> ones</p>",
        "id": 560282654,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764120924
    },
    {
        "content": "<p>We had a loose coordination thing going for a while where we all posted in the <a class=\"stream-topic\" data-stream-id=\"316715\" href=\"/#narrow/channel/316715-contributing/topic/Worklog.20.28Draft.20PRs.20and.20coordination.29/with/560271500\">#contributing &gt; Worklog (Draft PRs and coordination)</a> channel before starting work, and make a draft PR</p>",
        "id": 560282745,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764120986
    },
    {
        "content": "<p>But for a little while now it's only really been a smaller handful of people contributing so that practice dropped off a little</p>",
        "id": 560282803,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764121020
    },
    {
        "content": "<p>My approach is looking at the old docs <a href=\"https://www.roc-lang.org/builtins\">https://www.roc-lang.org/builtins</a> and then diffing against the src/build/roc/Builtin.roc implementations.</p>",
        "id": 560282897,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764121075
    },
    {
        "content": "<p>Will set and dict not just stay in pure roc (at least for now, built on top of list).</p>",
        "id": 560283026,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1764121150
    },
    {
        "content": "<p>I guess so?? I haven't looked at them yet</p>",
        "id": 560283060,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764121172
    },
    {
        "content": "<p>There's a body of work there I guess to translate that implementation over then?</p>",
        "id": 560283094,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764121190
    },
    {
        "content": "<p>Yeah. Makes sense</p>",
        "id": 560283114,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1764121199
    },
    {
        "content": "<p>From e.g. crates/compiler/builtins/roc/Dict.roc and crates/compiler/builtins/roc/Set.roc</p>",
        "id": 560283156,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764121221
    },
    {
        "content": "<p>I guess it does require a few different pieces. List has to have enough buiiltins complete. Hash needs to be implemented (which may require compiler magic). Eq has to be implemented as well if it doesn't already auto derive.</p>",
        "id": 560283235,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1764121258
    },
    {
        "content": "<p>So might be a few steps, but core work will be porting otherwise.</p>",
        "id": 560283264,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1764121272
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"281383\">@Richard Feldman</span> is fixing Eq as we speak</p>",
        "id": 560283307,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764121300
    },
    {
        "content": "<p>yep!</p>",
        "id": 560288187,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764124117
    },
    {
        "content": "<p>I haven't done anything with hash or sort</p>",
        "id": 560288240,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764124146
    },
    {
        "content": "<p>If Eq works, I assume those should be similar to implement at least.</p>",
        "id": 560289555,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1764125006
    },
    {
        "content": "<p>Hey I was trying to run a little fibonacci function and got a crash.<br>\nLooks like some kind of stack overflow exception is thrown for fib(N) where N &gt; 5</p>\n<div class=\"codehilite\"><pre><span></span><code>fib = |n|\n    if n &lt;= 1 {\n        n\n    } else {\n        fib(n - 1) + fib(n - 2)\n    }\n</code></pre></div>\n<p>Is it alright if I look into this further. I don't want to step on any toes if someone is already working on stuff related to this. I can also open an issue.</p>",
        "id": 560322089,
        "sender_full_name": "Devin Prothero",
        "timestamp": 1764142778
    },
    {
        "content": "<blockquote>\n<p>Is it alright if I look into this further.</p>\n</blockquote>\n<p>Go ahead :)</p>\n<blockquote>\n<p>I can also open an issue.</p>\n</blockquote>\n<p>Yes, that's handy for tracking. I recommend starting with getting a backtrace with gdb, that will show you the function call chain that triggered the segfault.</p>",
        "id": 560350385,
        "sender_full_name": "Anton",
        "timestamp": 1764151701
    },
    {
        "content": "<p>We dont have tail call optimisation yet  I think the plan is to implement trmc again</p>",
        "id": 560353251,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764152536
    },
    {
        "content": "<p>There might be some hardcoded limit in the interpreter that's like way off</p>",
        "id": 560353369,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764152568
    },
    {
        "content": "<p><code>List</code> builtins are open if anyone's interested - and also a ton of them can be implemented without needing to write any Zig logic (other than maybe some boilerplate you can copy/paste from other example PRs)</p>",
        "id": 560497010,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764202633
    },
    {
        "content": "<p>Is the idea to implement all the missing function in <a href=\"https://www.roc-lang.org/builtins/alpha4/List/\">https://www.roc-lang.org/builtins/alpha4/List/</a>? I think I could take some of them but I am unsure which ones to implement, including the ones that require Zig</p>",
        "id": 560500338,
        "sender_full_name": "Andres Villegas",
        "timestamp": 1764205682
    },
    {
        "content": "<p>Yeah basically -- there are some differences like Numbers have changed significantly</p>",
        "id": 560500371,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764205711
    },
    {
        "content": "<p>I think with static dispatch the way we do encoding and decoding also changes a lot</p>",
        "id": 560500403,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764205731
    },
    {
        "content": "<p>Ah, for List I think it's pretty much 1-1</p>",
        "id": 560500438,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764205763
    },
    {
        "content": "<p>Also, from one recent video I saw on roc, I guess walk and what not is not necessary? and will be replaced by just \"for loops\"?</p>",
        "id": 560500486,
        "sender_full_name": "Andres Villegas",
        "timestamp": 1764205806
    },
    {
        "content": "<p>Will try to spend most of tomorrow and friday implementing some</p>",
        "id": 560500530,
        "sender_full_name": "Andres Villegas",
        "timestamp": 1764205841
    },
    {
        "content": "<p>yeah we already have <code>fold</code> and will get <code>fold_rev</code> (aka <code>foldr</code>) and that's it</p>",
        "id": 560501234,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764206415
    },
    {
        "content": "<p>Hey y'all, I'm trying to implement List.any and with the following</p>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><code>    any : List(a), (a -&gt; Bool) -&gt; Bool\n    any = |list, predicate| {\n        for item in list {\n            if predicate(item) {\n                return True\n            }\n        }\n        False\n    }\n</code></pre></div>\n\n</blockquote>\n<p>But am getting the following compiler error:</p>\n<blockquote>\n<p>This if has no else branch, but it's being used as an expression (assigned to a variable, passed to a function, etc.).</p>\n<p>You can only use if without else when it's a statement. When if is used as an expression that evaluates to a value, else is required because otherwise there wouldn't always be a value available.</p>\n<p>Either add an else branch, or use this if as a standalone statement.</p>\n</blockquote>\n<p>Are early returns not supposed to be used this way? I tried to look for other examples of early returns in .roc files in the code base but i don't think there were any. I had a working version of List.any using fold but thought this would be preferable if early return is working.</p>",
        "id": 560512586,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1764216145
    },
    {
        "content": "<p>that code ought to work</p>",
        "id": 560512950,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764216496
    },
    {
        "content": "<p>looks like a compiler bug! I'll dig into this tomorrow</p>",
        "id": 560512970,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764216510
    },
    {
        "content": "<p>Sounds good! Thought something might be awry.</p>",
        "id": 560513592,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1764217081
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"986975\">@Edwin Santos</span> <a href=\"https://github.com/roc-lang/roc/pull/8468\">https://github.com/roc-lang/roc/pull/8468</a> fixes this</p>",
        "id": 560517129,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764219898
    },
    {
        "content": "<p>Dig a bit on the code, are the built-ins only implemented for the \"interpreter\" backend at the moment? For example, If I want to expose, <code>List.with_capacity</code> I will need to make sure it is implemented in <code>src/builtins/list.zig</code> (it is), then it is added to roc/Builtin.roc, added it to the low_level_map on the build/builtin_compiler, and then do its implementation in <code>src/eval/interpreter.zig</code>?</p>",
        "id": 560522107,
        "sender_full_name": "Andres Villegas",
        "timestamp": 1764224128
    },
    {
        "content": "<p>Yeah that sounds right</p>",
        "id": 560522204,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764224208
    },
    {
        "content": "<p>We aren't lowering to machine code yet</p>",
        "id": 560522222,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764224226
    },
    {
        "content": "<p>yeah we explicitly decided to wait until 2026 to do that, since there was no chance we'd have anything working for Advent of Code if machine code were in scope <span aria-label=\"smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 560587448,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764247227
    },
    {
        "content": "<p>How would you test that List.with_capacity does the right thing in an integration test. is there a way to get the capacity of a list, or should I have a private builtin like <code>list_get_capacity_unsafe</code> to be able to test?</p>",
        "id": 560649330,
        "sender_full_name": "Andres Villegas",
        "timestamp": 1764265834
    },
    {
        "content": "<p>Good question! Personally, I would verify that the capacity is correct in a unit test and in the integration test I would just check that you get back an empty list.</p>",
        "id": 560652810,
        "sender_full_name": "Anton",
        "timestamp": 1764267202
    },
    {
        "content": "<p>The best way to test it (in my opinion) would be with an instrumented roc alloc. Since we have to pass it into roc anyway, we could modify it to validate the allocation.</p>\n<p>Not sure if our tests are setup for that though. Would have to be a special test, not just something run with <code>roc test</code>.</p>\n<hr>\n<p>But yeah, a zig level unit test is probably best otherwise.</p>",
        "id": 560654359,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1764268040
    },
    {
        "content": "<p>Hey, taking a look at implementing List.append in Zig, is there a preference to base it off ListAppend or PushInPlace from list.zig? Looks like it could be either.<br>\n<a href=\"/user_uploads/22008/StvXAcmb2jZy7aiw1jbtzZvP/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/22008/StvXAcmb2jZy7aiw1jbtzZvP/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1098x985\" src=\"/user_uploads/thumbnail/22008/StvXAcmb2jZy7aiw1jbtzZvP/image.png/840x560.webp\"></a></div>",
        "id": 560664383,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1764273399
    },
    {
        "content": "<p>Will try to tackle List.reserve next</p>",
        "id": 560668108,
        "sender_full_name": "Andres Villegas",
        "timestamp": 1764275805
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"986975\">@Edwin Santos</span> I would guess ListAppend if that's in list.zig</p>",
        "id": 560672061,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764278340
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"571445\">@Andres Villegas</span> <span class=\"user-mention\" data-user-id=\"986975\">@Edwin Santos</span>  can you base your changes on <a href=\"https://github.com/roc-lang/roc/pull/8477\">https://github.com/roc-lang/roc/pull/8477</a> if it hasn't merged yet? I'm gonna try to merge it ASAP because it's a big change that's very prone to merge conflicts <span aria-label=\"smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 560694900,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764295410
    },
    {
        "content": "<p>Going to add List.drop_at to builtins next.</p>",
        "id": 560927604,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1764433713
    },
    {
        "content": "<p>Also small question, is the goal (in 2026) for al of the builtins in Roc to be rewritten in Zig? Or will some builtin functionality remain in Roc while some remains in Zig? Not sure if that was what the not yet lowering to machine code discussion was about earlier.</p>\n<p>Also is <a href=\"http://List.map\">List.map</a> implemented yet?</p>",
        "id": 560927905,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1764433962
    },
    {
        "content": "<p>I just opened a PR for <a href=\"http://List.map\">List.map</a></p>",
        "id": 560931249,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764437193
    },
    {
        "content": "<p>also another for keep_if/drop_if</p>",
        "id": 560932622,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764438447
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"986975\">Edwin Santos</span> <a href=\"#narrow/channel/316715-contributing/topic/Compiler.20task/near/560927604\">said</a>:</p>\n<blockquote>\n<p>Going to add List.drop_at to builtins next.</p>\n</blockquote>\n<p>Going to tack on List.sublist and a couple other functions to this.</p>",
        "id": 560935690,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1764441402
    },
    {
        "content": "<p>Does anyone have suggestions for handling Records in the interpreter? I tried following what Richard did in the Str.from_utf8 PR by adding identifiers to cannonicalize/ModuleEnv.zig but that resulted in something unrelated failing to deserialize properly. I also tried reading the bytes directly from the record ({start: U64, len: U64}) as is done when creating records in the numeric conversion fns and it works, but it's actually laid out such that len comes before start on StackValue.ptr.*. That route feels brittle but the first is causing unrelated tests to fail so wanted to check if we have a better way of handling Records in StackValues.</p>",
        "id": 560950655,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1764456262
    },
    {
        "content": "<p>Have you seen the <code>RecordAccessor</code> in src/eval/StackValue.zig, maybe that helps?</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"c1\">/// Safe accessor for record fields with bounds checking and proper memory management</span>\n<span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">RecordAccessor</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"p\">{</span>\n</code></pre></div>",
        "id": 560950804,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764456455
    },
    {
        "content": "<p>Yeah I tried that first but you need a U64 index or Ident.Idx to retrieve the field. When I was searching through Interpreter.zig most of the time the index was retrieved using the Ident.Idx, which is why I tried adding start/len field names to ModuleEnv as Ident.Idx's but that started causing some tests to fail.</p>",
        "id": 560950902,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1764456591
    },
    {
        "content": "<p>Field names are sorted alphabetically I think</p>",
        "id": 560951106,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764456805
    },
    {
        "content": "<p>I'm not sure what the question is... is the RecordAccessor broken or not consistently used?</p>",
        "id": 560951154,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764456847
    },
    {
        "content": "<p>Most of the time I've seen values fetched from it, they're fetched out via an Ident.Idx or a index value retrieved from an Indent.Idx, so I wanted to make sure I was handling it correctly and not just putting in indices that seemed right.</p>",
        "id": 560951285,
        "sender_full_name": "Edwin Santos",
        "timestamp": 1764456989
    },
    {
        "content": "<p>If you can test any implementations with <a href=\"https://github.com/lukewilliamboswell/roc-platform-template-zig\">https://github.com/lukewilliamboswell/roc-platform-template-zig</a> I think that would be good. Our fx test platform uses an arena so dealloc's are a noop, while that platform uses a zig gpa -- and reports leaks. I've been hunting down memory leaks and use after frees ect from our builtin implementations</p>",
        "id": 560952219,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764457842
    },
    {
        "content": "<p>I might look at changing the fx test platform to use a gpa and report leaks also</p>",
        "id": 560952517,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764458154
    },
    {
        "content": "<p>Basically I think the more tests we can have that exercise refcounting in the interpreter with good debug info etc the better. It's complicated to get that right for every possible combination.</p>",
        "id": 560953351,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764459278
    },
    {
        "content": "<p>I'm exploring a new build/compile time flag like trace-eval but for tracing refcounts (basically whenever we allocate or dealloc a value we can trace that -- only really to be used for small test programs to help isolate bugs.</p>",
        "id": 560954622,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764460762
    },
    {
        "content": "<p>added in <a href=\"https://github.com/roc-lang/roc/pull/8505\">https://github.com/roc-lang/roc/pull/8505</a> -- and almost immediately highlighted the issue I was trying to find <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 560955359,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764461429
    },
    {
        "content": "<p>Fixed the double free <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 560955697,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764461821
    },
    {
        "content": "<p>Is there some guidance on how to test Builtins. Some Builtins only have snapshot tests, other only e_low_level tests and others only have test in intepreter_style_tests. Is there a rule of thumb of which goes where and why?</p>",
        "id": 560975258,
        "sender_full_name": "Andres Villegas",
        "timestamp": 1764485487
    },
    {
        "content": "<p>BTW I am working on List.last and List.single, just figuring out the tests, seems like anonymous Tags are not supported in the interpreter style tests or I am holding it wrong somehow. I am able to test them using snapshot tests though</p>",
        "id": 560975439,
        "sender_full_name": "Andres Villegas",
        "timestamp": 1764485678
    },
    {
        "content": "<p>I don't think there's any guidance around. I'd say we want some decent coverage. The snapshot tests are really useful because they have the <code>trace-eval</code> which can give you more detailed explanation of what the interpreter is seeing, they're very fast, and offer a more human readable explanation of each compiler stage. The low_level tests are useful because they're in pure zig, but their scope is much more limited in some ways, though they can assert some characteristics the snapshots cant. Finally and probably less preferable is the fx/integration type tests.</p>",
        "id": 560975738,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764486099
    },
    {
        "content": "<p>So as a general rule I'd say add lots of snapshot tests, some low_level where you need to, and sparingly the integration tests</p>",
        "id": 560975831,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1764486192
    }
]