[
    {
        "content": "<p>I've decided to spin off a discussion from <a href=\"#narrow/stream/231634-beginners/topic/How.20to.20get.20String.20length.3F/near/435071237\">this</a> message, authored by <span class=\"user-mention\" data-user-id=\"515757\">@Luke Boswell</span>.</p>\n<p>It's in the context of the current state of <code>roc-unicode</code> and potential current-stage contributions that would be welcome, such as giving a hand with fuzz testing.</p>\n<p>I've been extremely snowed under with work at my workplace, but I'd be happy to at least try to think how I could be of help with respect to the direction of efforts pertaining to ironing out a more stable <code>roc-unicode</code> release, as it's one of the points which feels to me are relatively strongly tied to overall user experience with Roc.</p>\n<p>It'd also be nice to have some sort of action points, which will be available to the community to address, subject to capacity/time availability as well.</p>",
        "id": 435120267,
        "sender_full_name": "Hristo",
        "timestamp": 1713940709
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"343810\">@Brendan Hansknecht</span> has done a lot of work on fuzzing, he's written notes about it <a href=\"#narrow/stream/395097-compiler-development/topic/Property.20testing.20and.20fuzzing/near/418548020\">in this zulip discussion</a> and upgraded his <a href=\"https://github.com/bhansconnect/roc-fuzz\">roc-fuzz</a> platform so that it is more suitable for testing pure roc code.</p>\n<p>For the next step for <code>roc-lang/unicode</code>, I was wanting to use that platform to provide additional assurance we're handling the various edge cases in the <code>Grapheme.split</code> implementation properly. It's a pretty <a href=\"https://github.com/roc-lang/unicode/blob/09f22e6aee3adedc2b5cf45f654956b41c157202/package/Grapheme.roc#L60\">big state machine</a>, and I have deliberately left a <code>crash</code> to help find any unhandled edge cases. </p>\n<p>We code-gen the test suite from the unicode data file, and I went through all these manually until all 1137 tests passed. Basically, take the first one that fails, use <code>dbg</code> print to follow the recursion through each byte and checking it's behaving correctly, as I find things that are not correct IAW the text segmentation rules fix, rinse and repeat.</p>\n<p>But in the process of doing that I found the coverage of the unicode data file test points is pretty average, like it might only have a test that covers an emoji at the start of a string, but not the middle or end or before a CLRF or after a Hangul sequence... etc.</p>\n<p>So I'm reasonably confident there are a couple of edge cases we haven't caught, and could end up crashing someone's code. It would be nice to get that to a point where we are reasonably confident that is not going to happen.</p>",
        "id": 435144341,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1713949581
    }
]