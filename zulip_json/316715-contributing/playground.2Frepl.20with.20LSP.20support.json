[
    {
        "content": "<p>Hey, I think nothing is preventing us from compiling the language server to WASM and run it in the browser. Would there be interest for this?  </p>\n<p>If so, I would like to make a small PoC that hooks up a CodeMirror editor with some basic LSP functionality (code completions, hover documentation &amp; diagnostics). If this is a success, we could create a neat playground. An interactive tutorial such as <a href=\"https://go.dev/play/\">https://go.dev/play/</a> would especially be cool.</p>",
        "id": 453747271,
        "sender_full_name": "Bram",
        "timestamp": 1721839475
    },
    {
        "content": "<p>Excellent idea <span class=\"user-mention\" data-user-id=\"738973\">@Bram</span>! That could work, I suspect <span class=\"user-mention\" data-user-id=\"651372\">@Eli Dowling</span> may know best</p>",
        "id": 453749817,
        "sender_full_name": "Anton",
        "timestamp": 1721840246
    },
    {
        "content": "<p>that sounds awesome! I'd love to have a <a href=\"http://play.roc-lang.org\">play.roc-lang.org</a></p>",
        "id": 453756808,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721842130
    },
    {
        "content": "<p>I have some thoughts on both the software and infrastructure architecture for the production version of something like that, so <span class=\"user-mention\" data-user-id=\"738973\">@Bram</span> maybe we can chat about that once you're at the proof-of-concept stage! <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 453757752,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721842368
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"738973\">@Bram</span> has suggested exactly my inclination. <br>\nUse Monaco for the editor and connect it to the wasm compiled roc language server.<br>\n(Let me know if you have any major issues trying to run it in a browser, I suspect there may be some challenges)<br>\nThe obvious question is: What platform should we use? <br>\nIf there isn't an existing wasm platform we'd want to make one that just exposes browser stuff: console log, http request etc</p>",
        "id": 453804354,
        "sender_full_name": "Eli Dowling",
        "timestamp": 1721858366
    },
    {
        "content": "<p>Well, after soem research, running a language server in the browser via wasm is not \"the done thing\"</p>\n<p>I did find a little prior art:</p>\n<p><a href=\"https://www.hiro.so/blog/write-clarity-smart-contracts-with-zero-installations-how-we-built-an-in-browser-language-server-using-wasm\">https://www.hiro.so/blog/write-clarity-smart-contracts-with-zero-installations-how-we-built-an-in-browser-language-server-using-wasm</a></p>\n<p>But it looks pretty complex to me.</p>",
        "id": 453807480,
        "sender_full_name": "Eli Dowling",
        "timestamp": 1721859695
    },
    {
        "content": "<p>This Is pretty promising:<br>\n<a href=\"https://github.com/qualified/lsps\">https://github.com/qualified/lsps</a></p>",
        "id": 453807646,
        "sender_full_name": "Eli Dowling",
        "timestamp": 1721859785
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"651372\">Eli Dowling</span> <a href=\"#narrow/stream/316715-contributing/topic/playground.2Frepl.20with.20LSP.20support/near/453807480\">said</a>:</p>\n<blockquote>\n<p>Well, after soem research, running a language server in the browser via wasm is not \"the done thing\"</p>\n</blockquote>\n<p>doing the thing that's not \"the done thing\" is kind of our specialty around here <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 453807668,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721859801
    },
    {
        "content": "<p>since we have our own ls code base written in Rust, I'd have to imagine we could compile that code to wasm and change it to expose its operations as ordinary js function calls (via wasm-bindgen) and then the code editor could call them directly, yeah?</p>",
        "id": 453807986,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721859989
    },
    {
        "content": "<p>or I guess maybe it would need to run in a web worker so it didn't block the main thread</p>",
        "id": 453808066,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721860055
    },
    {
        "content": "<p>Definitely needs to be in a we worker.<br>\nThis looks promising too:<br>\n<a href=\"https://github.com/FurqanSoftware/codemirror-languageserver\">https://github.com/FurqanSoftware/codemirror-languageserver</a></p>",
        "id": 453808153,
        "sender_full_name": "Eli Dowling",
        "timestamp": 1721860098
    },
    {
        "content": "<p>so not quite direct function calls, but rather sending json to/from a web worker running the compiled wasm</p>",
        "id": 453808164,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721860107
    },
    {
        "content": "<p>Everything I'm seeing points towards codemirror as being a more popular option for the editor. <br>\nI think that's because Monaco may not actually provide the completion ui stuff. I think that might be something vscode adds on-top</p>",
        "id": 453808250,
        "sender_full_name": "Eli Dowling",
        "timestamp": 1721860183
    },
    {
        "content": "<p>I think the main issue I've seen, is filesystem related things which some langue severs must use.  <br>\nIt seems some solutions involve simulating a filesystem In the browser. <br>\nI'd have to check if that's an issue we'd face</p>",
        "id": 453808720,
        "sender_full_name": "Eli Dowling",
        "timestamp": 1721860454
    },
    {
        "content": "<p>since we're in charge of both the compiler and the language server, there are ways we can get around that <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 453812769,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721862508
    },
    {
        "content": "<p>Yeah, from memory I don't think we actually make any filesystem calls because we invoke the compile with the source directly.</p>",
        "id": 453818431,
        "sender_full_name": "Eli Dowling",
        "timestamp": 1721865769
    },
    {
        "content": "<p>Cool, I will try to hack something together this weekend. It will indeed run in a web worker. Regarding the editor, there is a popular language server extension for Monaco, but CodeMirror is a bit more lightweight, which might be beneficial if we want to reuse the editor for the repl on the landing page for example.</p>\n<p>That said, _a lot_ of people use vscode, so that would feel more familiar. We can discuss the choice of editor and the overall architecture after I got something working ;)</p>",
        "id": 453875273,
        "sender_full_name": "Bram",
        "timestamp": 1721892558
    },
    {
        "content": "<p>After browsing the source code of the LSP a bit more, we use <a href=\"https://github.com/servo/rust-url/blob/main/url/src/lib.rs#L2625\">Url::to_file_path</a> and <a href=\"https://github.com/servo/rust-url/blob/main/url/src/lib.rs#L2471\">Url::from_file_path</a> in <code>analysis.rs</code> which are not supported in wasm32-unknown-unknown</p>",
        "id": 453927298,
        "sender_full_name": "Bram",
        "timestamp": 1721908590
    },
    {
        "content": "<p>we could vendor those</p>",
        "id": 453931892,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721910022
    },
    {
        "content": "<p>or swap to <a href=\"https://github.com/servo/rust-url/issues/609#issuecomment-2231598982\">this implementation</a> which is <code>no_std</code></p>",
        "id": 453932238,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721910113
    },
    {
        "content": "<p>I managed to build a wasm version of the LSP : D<br>\nI want to split up the <code>language_server</code> crate in three:</p>\n<ul>\n<li><code>language_server_core</code> - this exports the tower service</li>\n<li><code>language_server_wasm</code> - wasm bindgen layer that uses <code>web_sys::ReadableStream</code> and <code>web_sys::WritableStream</code> to send jsonrpc messages between javascript and wasm runtime</li>\n<li><code>language_server</code>- multi-threaded tokio runtime that reads/writes jsonrpc messages from stdin/out</li>\n</ul>",
        "id": 453943765,
        "sender_full_name": "Bram",
        "timestamp": 1721912698
    },
    {
        "content": "<p>any feedback on the naming of the crates, or sounds good?</p>",
        "id": 453943849,
        "sender_full_name": "Bram",
        "timestamp": 1721912720
    },
    {
        "content": "<p>I <em>think</em> the only thing I need in <code>language_server_wasm</code> is this <code>lib.rs</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">tower_lsp</span><span class=\"p\">::{</span><span class=\"n\">LspService</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Server</span><span class=\"p\">};</span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">wasm_bindgen</span><span class=\"p\">::</span><span class=\"n\">prelude</span><span class=\"p\">::</span><span class=\"o\">*</span><span class=\"p\">;</span>\n\n<span class=\"cp\">#[wasm_bindgen]</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">serve</span><span class=\"p\">(</span><span class=\"n\">input</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">web_sys</span><span class=\"p\">::</span><span class=\"n\">ReadableStream</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">output</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">web_sys</span><span class=\"p\">::</span><span class=\"n\">WritableStream</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">console_error_panic_hook</span><span class=\"p\">::</span><span class=\"n\">set_once</span><span class=\"p\">();</span>\n<span class=\"w\">    </span><span class=\"n\">web_sys</span><span class=\"p\">::</span><span class=\"n\">console</span><span class=\"p\">::</span><span class=\"n\">log_1</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"s\">\"::serve\"</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">());</span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">wasm_streams</span><span class=\"p\">::</span><span class=\"n\">ReadableStream</span><span class=\"p\">::</span><span class=\"n\">from_raw</span><span class=\"p\">(</span><span class=\"n\">input</span><span class=\"p\">).</span><span class=\"n\">into_async_read</span><span class=\"p\">();</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">wasm_streams</span><span class=\"p\">::</span><span class=\"n\">WritableStream</span><span class=\"p\">::</span><span class=\"n\">from_raw</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"p\">).</span><span class=\"n\">into_async_write</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">service</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">messages</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">LspService</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">client</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">roc_language_server_core</span><span class=\"p\">::</span><span class=\"n\">RocServer</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">client</span><span class=\"p\">));</span>\n<span class=\"w\">    </span><span class=\"n\">Server</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">input</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">output</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">messages</span><span class=\"p\">).</span><span class=\"n\">serve</span><span class=\"p\">(</span><span class=\"n\">service</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 453945180,
        "sender_full_name": "Bram",
        "timestamp": 1721913030
    },
    {
        "content": "<p>and we got diagnostics in the browser:<br>\n<a href=\"/user_uploads/22008/uYb0yh7gQiz9ZNKVx-VXfUqf/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/22008/uYb0yh7gQiz9ZNKVx-VXfUqf/image.png\" title=\"image.png\"><img data-original-dimensions=\"2700x976\" src=\"/user_uploads/thumbnail/22008/uYb0yh7gQiz9ZNKVx-VXfUqf/image.png/840x560.webp\"></a></div>",
        "id": 454058849,
        "sender_full_name": "Bram",
        "timestamp": 1721943827
    },
    {
        "content": "<p>Which also brings up this question: <br>\n<a href=\"/user_uploads/22008/FtJB2VzFtpl5xB4SwhzIudKp/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/22008/FtJB2VzFtpl5xB4SwhzIudKp/image.png\" title=\"image.png\"><img data-original-dimensions=\"2966x602\" src=\"/user_uploads/thumbnail/22008/FtJB2VzFtpl5xB4SwhzIudKp/image.png/840x560.webp\"></a></div>",
        "id": 454059790,
        "sender_full_name": "Bram",
        "timestamp": 1721944295
    },
    {
        "content": "<p>Some thought. We have compiled the LS and linked it up so that it works in the browser. </p>\n<p>So, when the LS analyses an <code>app</code> module, it is going to try and then compile the platform roc files that comes along with it. But we haven't yet provided these. </p>\n<p>One option is that we might be able to have a \"hostless\" platform just for working in the browser. I've been calling this a \"plugin\" use-case. We have an example in <code>roc glue</code>, where the glue platform is all roc files and there is no host. Perhaps we could even have some effects that are supported.</p>\n<p>Another option, is that we enable the use of any platform ... using a URL. But we would need some machinery in the browser to go and fetch the platform package and then make it available to the LS somehow. We probably can't provide any effects in this case... but at the risk of going down another tangent, wouldn't it be cool if the platform authors also bundled a WASM build of their host which includes effect implementations tailored just for the web editor.</p>",
        "id": 454065028,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1721947252
    },
    {
        "content": "<p>yeah let's do that!</p>",
        "id": 454068089,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721949027
    },
    {
        "content": "<p>I think that's exactly what we should do</p>",
        "id": 454068120,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721949042
    },
    {
        "content": "<p>in fact I think bundles are already set up for that, right?</p>",
        "id": 454068149,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721949065
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281383\">@Richard Feldman</span> -- I mentioned two options. </p>\n<ol>\n<li>make a host-less platform just for editor</li>\n<li>fetch platform URLs (and maybe suupport an editor specific WASM module)</li>\n</ol>",
        "id": 454070279,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1721950489
    },
    {
        "content": "<p>Thinking about this some, I think the obvious answer is option 2. </p>\n<p>We definitely should be able to download any platform for the purpose of a code editor.</p>",
        "id": 454071060,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1721950862
    },
    {
        "content": "<p>The added platform authors including a WASM bundle for editor effect simulation thing... is probably more of a cool future idea, than something we should attempt right now.</p>",
        "id": 454071281,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1721950936
    },
    {
        "content": "<p>So I guess the LS for the editor would get the URL from the app module header, then pass that back to JS which goes and downloads the package and then provides the platform roc files so the LS can continue. I'm not sure how all this would get plumbed together to work in a browser.</p>",
        "id": 454071871,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1721951132
    },
    {
        "content": "<p>Any host binaries in the platform package, like <code>macos-aarch64.a</code> or <code>linux-x64.rh</code> can just be ignored -- or even removed and not retained in the browser cache. </p>\n<p>I assume browsers are more than happy downloading larger files, in the order of 10's of MB, and caching this in local storage or somewhere.</p>",
        "id": 454072251,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1721951247
    },
    {
        "content": "<p>Also we would need to untar the <code>.tar.br</code> or <code>.tar.gz</code> in the browser</p>",
        "id": 454072409,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1721951296
    },
    {
        "content": "<p>This is a super cool project!!</p>",
        "id": 454072498,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1721951329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515757\">Luke Boswell</span> <a href=\"#narrow/stream/316715-contributing/topic/playground.2Frepl.20with.20LSP.20support/near/454072251\">said</a>:</p>\n<blockquote>\n<p>Any host binaries in the platform package, like <code>macos-aarch64.a</code> or <code>linux-x64.rh</code> can just be ignored -- or even removed and not retained in the browser cache. </p>\n<p>I assume browsers are more than happy downloading larger files, in the order of 10's of MB, and caching this in local storage or somewhere.</p>\n</blockquote>\n<p>yep! It’ll have to be indexeddb for binary data, but totally doable!</p>",
        "id": 454074332,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721952030
    },
    {
        "content": "<p>although night be able to just get away with using the browser’s http cache</p>",
        "id": 454074426,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721952078
    },
    {
        "content": "<p>also I think depending on the platform it might not even be that hard to offer a wasm version</p>",
        "id": 454074610,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721952180
    },
    {
        "content": "<p>for example, the playground could offer a fake wasi interface maybe (somebody has surely made a wasi implementation that runs in the browser to that extent possible)</p>",
        "id": 454074681,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721952230
    },
    {
        "content": "<p>and then basic-cli could ship a wasm binary that expects to be connected to a wasi implementation somehow</p>",
        "id": 454074752,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721952262
    },
    {
        "content": "<p>so you could do the normal basic-cli tutorial in the playground! <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 454074771,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721952286
    },
    {
        "content": "<p>One thought about the platform package... if we do the work to unzip it in the browser, and then strip out the binary files, we are just left with the <code>.roc</code> files. So my thoughts we would only keep these in the \"cache\", and the next time the LS recompiles we wont need to unzip the file again.</p>",
        "id": 454075033,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1721952482
    },
    {
        "content": "<blockquote>\n<p>So I guess the LS for the editor would get the URL from the app module header, then pass that back to JS which goes and downloads the package and then provides the platform roc files so the LS can continue. I'm not sure how all this would get plumbed together to work in a browser.</p>\n</blockquote>\n<p>I think we can just make the <code>roc_packaging</code> crate wasm compatible, right?<br>\n<code>reqwest</code> already supports wasm (will use the fetch API under the hood), the only thing is that because of that, it only supports the async client and not the blocking one that is used here: <a href=\"https://github.com/roc-lang/roc/blob/d5db3137a3d8da46f92c31b6bf088bc495f759c2/crates/packaging/src/https.rs#L254\">https://github.com/roc-lang/roc/blob/d5db3137a3d8da46f92c31b6bf088bc495f759c2/crates/packaging/src/https.rs#L254</a></p>",
        "id": 454258518,
        "sender_full_name": "Bram",
        "timestamp": 1721987129
    },
    {
        "content": "<p>The cache implementation of <code>roc_packaging</code> should probably be made custom for the browser though (storing it in indexed db, for example).</p>\n<p>Another option would be to use the new file system API: <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/File_System_API\">https://developer.mozilla.org/en-US/docs/Web/API/File_System_API</a></p>\n<p>There is also: <a href=\"https://github.com/WebAssembly/wasi-filesystem\">https://github.com/WebAssembly/wasi-filesystem</a><br>\nAnd experimental shim for the browser: <a href=\"https://github.com/bytecodealliance/jco/tree/main/packages/preview2-shim\">https://github.com/bytecodealliance/jco/tree/main/packages/preview2-shim</a></p>",
        "id": 454273431,
        "sender_full_name": "Bram",
        "timestamp": 1721991808
    },
    {
        "content": "<blockquote>\n<p>so you could do the normal basic-cli tutorial in the playground!</p>\n</blockquote>\n<p>Yep, and that means not just LSP support, but compiling &amp; running complete roc apps, all from within the browser, right?</p>",
        "id": 454275679,
        "sender_full_name": "Bram",
        "timestamp": 1721992789
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"738973\">@Bram</span> <span class=\"user-mention\" data-user-id=\"651372\">@Eli Dowling</span> I've been thinking about this work, and am excited about the possibilities.</p>\n<p>One idea I've had is that this could be an opportunity to upgrade our <a href=\"https://www.roc-lang.org/examples\">website examples site</a>, <a href=\"https://github.com/roc-lang/examples\">source fiels at roc-lang/examples</a> to be more interactive. </p>\n<p>I know it's early -- we're still working on how to get the editor compiling, and everything linked up. </p>\n<p>But I wonder, imagining we had a playground/repl, could we/should we use this for the roc website examples? are there things that we could do to prepare for this that might also be beneficial in the short term? </p>\n<p>For example, would it be useful if our examples were in another format? or you could download an index of the roc source files?</p>",
        "id": 455346899,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722422739
    },
    {
        "content": "<p>The gleam tour seems like good reference material here: <a href=\"https://tour.gleam.run/\">https://tour.gleam.run/</a></p>",
        "id": 455347077,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1722422810
    },
    {
        "content": "<p>It has examples of the main language features that are loaded into the playground already correct and runnable, and the user can mess with it to change things and see what happens</p>",
        "id": 455347174,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1722422855
    },
    {
        "content": "<p>Having code that's already ready to go <em>should</em> make it more useful for users since they don't have to go find non-trivial code to mess with</p>",
        "id": 455347364,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1722422926
    },
    {
        "content": "<p>It's also really nicely styled, and reads like a book.</p>",
        "id": 455347730,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722423073
    },
    {
        "content": "<p>Yes, Gleam is nothing if not polished</p>",
        "id": 455347808,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1722423119
    },
    {
        "content": "<p>Oh hey, I have another very specific suggestion for this! </p>\n<p>You can use a templating system. <br>\nI recently had to write some documentation and blog posts that included code snippets and wanted the code to be runnable and always work and be up to date with any changes. </p>\n<p>I made a simple templating system that lets you define indexed code blocks using comments and then insert those into points in a document. </p>\n<div class=\"codehilite\"><pre><span></span><code>#$$S1\na= myfunc\n#$$E1\n</code></pre></div>\n<div class=\"codehilite\"><pre><span></span><code>As you can see we define a function called a:\n$$1\n</code></pre></div>\n<p>Then you remove all those line comments, do the templating and you can have documentation as well as the full working source. <br>\nThat way the documentation part stays in sync with the full code.</p>",
        "id": 455347961,
        "sender_full_name": "Eli Dowling",
        "timestamp": 1722423185
    },
    {
        "content": "<p>My system is in Ocaml but I could translate it to roc.</p>",
        "id": 455348014,
        "sender_full_name": "Eli Dowling",
        "timestamp": 1722423218
    },
    {
        "content": "<p>So yeah, I like the idea of setting up the examples repo to somehow be automatically loaded as a set of toys for a REPL playground</p>",
        "id": 455348313,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1722423348
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"651372\">@Eli Dowling</span> sounds cool! If you know of a way to get a system like the one you've got running to work with a fast dev loop, as an LSP would provide, that'd be super cool! That tends to be the thing missing in generated code contexts</p>",
        "id": 455348733,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1722423503
    },
    {
        "content": "<p>The examples site (along with the roc website) are currently generated from markdown files using <a href=\"https://github.com/lukewilliamboswell/basic-ssg\">https://github.com/lukewilliamboswell/basic-ssg</a></p>",
        "id": 455349415,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722423644
    },
    {
        "content": "<p>Could we use something like this?</p>",
        "id": 455349631,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722423686
    },
    {
        "content": "<p>Can we do it all with static files and just a content server?</p>",
        "id": 455349790,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722423718
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461444\">Sam Mohr</span> <a href=\"#narrow/stream/316715-contributing/topic/playground.2Frepl.20with.20LSP.20support/near/455348733\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"651372\">Eli Dowling</span> sounds cool! If you know of a way to get a system like the one you've got running to work with a fast dev loop, as an LSP would provide, that'd be super cool! That tends to be the thing missing in generated code contexts</p>\n</blockquote>\n<p>It's almost instant, so I run it with a file watcher.</p>",
        "id": 455349928,
        "sender_full_name": "Eli Dowling",
        "timestamp": 1722423741
    },
    {
        "content": "<p>Yeah, you just have a set of input files and then an output folder that contains the generated markdown and code files with the special templating comments removed</p>",
        "id": 455350107,
        "sender_full_name": "Eli Dowling",
        "timestamp": 1722423796
    },
    {
        "content": "<p>so you can just check everything into source control</p>",
        "id": 455350221,
        "sender_full_name": "Eli Dowling",
        "timestamp": 1722423817
    },
    {
        "content": "<p>you could run the template tool as an extension to the ssg generator. As pass that runs before that.</p>",
        "id": 455350715,
        "sender_full_name": "Eli Dowling",
        "timestamp": 1722423923
    },
    {
        "content": "<p>We could add effects, like a Task that could be run by the roc app before generating the html files.</p>",
        "id": 455350922,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722423972
    },
    {
        "content": "<p>Yeah that would be cool, having a little pre-build step we can add in there</p>",
        "id": 455351024,
        "sender_full_name": "Eli Dowling",
        "timestamp": 1722424012
    },
    {
        "content": "<p>I've thought about our current system before and I'd really like to include the Roc code directly into the .md file.<br>\nSo currently in our md files we do:</p>\n<div class=\"codehilite\"><pre><span></span><code># Code\n&#39;&#39;&#39;roc\nfile:main.roc\n&#39;&#39;&#39;\n</code></pre></div>\n<p>And I'd love this to be:</p>\n<div class=\"codehilite\"><pre><span></span><code># Code\n&#39;&#39;&#39;roc\napp [main] { pf: platform &quot;...&quot; }\n\nimport pf.Stdout\nimport pf.Task\n\nmain =\n    Stdout.line! &quot;Hello, World!&quot;\n&#39;&#39;&#39;\n</code></pre></div>\n<p>I tried to set up our tutorial to work with <code>file:main.roc</code> but it's just way too many files and needless indirection.</p>\n<p>The templating references (<code>$$1</code>) would indeed be great to reference small parts of the code.</p>",
        "id": 455372907,
        "sender_full_name": "Anton",
        "timestamp": 1722431682
    },
    {
        "content": "<p>I've been wondering if we should make the compiler able to handle markdown files, so it can check or execute or test all the roc code blocks. Doc comments are basically already markdown documents and we definitely want to be able to check any roc code blocks in those doc comments.</p>",
        "id": 455372918,
        "sender_full_name": "Anton",
        "timestamp": 1722431687
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515757\">Luke Boswell</span> <a href=\"#narrow/stream/316715-contributing/topic/playground.2Frepl.20with.20LSP.20support/near/455346899\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"738973\">Bram</span> <span class=\"user-mention silent\" data-user-id=\"651372\">Eli Dowling</span> I've been thinking about this work, and am excited about the possibilities.</p>\n<p>One idea I've had is that this could be an opportunity to upgrade our <a href=\"https://www.roc-lang.org/examples\">website examples site</a>, <a href=\"https://github.com/roc-lang/examples\">source fiels at roc-lang/examples</a> to be more interactive. </p>\n<p>I know it's early -- we're still working on how to get the editor compiling, and everything linked up. </p>\n<p>But I wonder, imagining we had a playground/repl, could we/should we use this for the roc website examples? are there things that we could do to prepare for this that might also be beneficial in the short term? </p>\n<p>For example, would it be useful if our examples were in another format? or you could download an index of the roc source files?</p>\n</blockquote>\n<p>So the LSP in the browser is already functional. I hooked up diagnostics, docs on hover and auto completions into codemirror (if we decide to use this editor is to be decided, but works well so far). The main blocker now is getting platform support for <code>wasm-unknown-unknown</code> and/or <code>wasi </code> (there must be a wasi browser runtime out there).</p>\n<p>Regarding the examples, I think we can just do SSG and embed the example source code into the HTML. This is also what gleam's playground does: <a href=\"https://github.com/gleam-lang/language-tour/blob/main/src/tour.gleam#L695\">https://github.com/gleam-lang/language-tour/blob/main/src/tour.gleam#L695</a> and <a href=\"https://github.com/gleam-lang/language-tour/blob/main/static/index.js#L7\">https://github.com/gleam-lang/language-tour/blob/main/static/index.js#L7</a></p>\n<p>Then all there is left to do is host it on a CDN</p>",
        "id": 455390938,
        "sender_full_name": "Bram",
        "timestamp": 1722436901
    },
    {
        "content": "<p>Super cool <span class=\"user-mention\" data-user-id=\"738973\">@Bram</span>!</p>",
        "id": 455392897,
        "sender_full_name": "Anton",
        "timestamp": 1722437429
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"453714\">@Ryan Barth</span> did some exploration into platformless roc, which may be relevant. Also he and I have been working on <a href=\"https://github.com/roc-lang/roc/pull/6859\">the build-host PR</a> which refactors the build pipeline a bit and I think will make it easier if we need to change anything.</p>",
        "id": 455499800,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722465835
    },
    {
        "content": "<p>I've got builtins and and things happy with zig 13 on a branch -- one of the main motivations for that was that I think it unlocks linking with <code>.wasm</code> hosts.</p>",
        "id": 455499905,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722465886
    },
    {
        "content": "<p>Just thinking about what we might be able to do to experiment with these ideas and test them out.</p>\n<p>I imagine we need a platform with a release, that has a binary for a wasm host in it. </p>\n<p>Then when the roc compiler (that is compiled to wasm and running in the browser) loads an app that uses a wasm supported platform, we fetch the platform files which include the prebuilt wasm host. Compile the app to wasm and then link the app and wasm together so we can run the combined thing in the browser.</p>",
        "id": 455500186,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722466033
    },
    {
        "content": "<p>We could possibly upgrade <span class=\"user-mention\" data-user-id=\"496321\">@Oskar Hahn</span>'s  <a href=\"https://github.com/ostcar/roc-wasi-platform\">https://github.com/ostcar/roc-wasi-platform</a> to zig-13 and I think that will give us a nice WASI host.</p>",
        "id": 455500366,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722466119
    },
    {
        "content": "<p>Or maybe now we have a working llvm 18/zig 13 compiler we could continue with <a href=\"https://github.com/lukewilliamboswell/roc-platform-template-wasi\">https://github.com/lukewilliamboswell/roc-platform-template-wasi</a> and see if we can get something minimal working there.</p>",
        "id": 455500460,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722466177
    },
    {
        "content": "<p>For reference <a href=\"https://github.com/roc-lang/roc/tree/upgrade-llvm-zig/crates/compiler/builtins/bitcode/src\">the zig builtins source on this branch</a> have been upgraded to zig 13.</p>",
        "id": 455501040,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722466464
    },
    {
        "content": "<p>So I guess what I'm thinking is we can isolate the different platform parts we need. Build something minimal and test/validate it works outside the browser.</p>",
        "id": 455502762,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722467353
    },
    {
        "content": "<p>If we build an end-2-end MVP now while those PR's are still WIP, we can probably have this working when the build-host and upgrade-llvm-zig PR's land. But it's also a bit more involved working on branches and digging into/understanding the build/linking pipeline. </p>\n<p>So it would also be reasonable to wait for those changes before adding in more scope. Though it could take us a month or more before we see these changes in main with a latest release.</p>",
        "id": 455503958,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722467917
    },
    {
        "content": "<p>Sounds like a good plan <span class=\"user-mention\" data-user-id=\"515757\">@Luke Boswell</span> , I am not sure how much I can be of help in the short term (upcoming weeks) as I am a bit busy, don’t know Zig yet, and have to read a bit into how platforms are implemented, but if anyone wants to do an experiment to make a wasm compatible host, I would gladly try to hook it up to my experiment and see if we can get a complete web based Roc editor going</p>",
        "id": 455504441,
        "sender_full_name": "Bram",
        "timestamp": 1722468159
    },
    {
        "content": "<p>One, maybe unrelated, thought I had about platforms, what if you want to interop with other languages? Let’s say some JavaScript library if you build a frontend app, in that case you would lose the security/ sandboxing like features that platforms offer? But not being able to interface with external code would also be quite limiting…</p>",
        "id": 455505238,
        "sender_full_name": "Bram",
        "timestamp": 1722468537
    },
    {
        "content": "<p>This is a slight tangent, I can't move the messages. </p>\n<p>But in general the platform controls that interface. So the platform would be able to expose some kind of API to interop (or choose not to).</p>",
        "id": 455505738,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722468791
    },
    {
        "content": "<p>If you are building to WASM and then using javascript to load that into the browser, there is an additional interface there between the platform host and the javascript/wasm runtime which would need to be considered.</p>",
        "id": 455505889,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722468857
    },
    {
        "content": "<p>Ok, so I think I've got something you can work with. After writing all of ^^^ I couldn't help myself. </p>\n<p>Just pushed an update for <a href=\"https://github.com/lukewilliamboswell/roc-platform-template-wasi\">https://github.com/lukewilliamboswell/roc-platform-template-wasi</a></p>\n<p>You can grab the compiled wasm binary here <a href=\"https://github.com/lukewilliamboswell/roc-platform-template-wasi/tree/main/zig-out/bin\">https://github.com/lukewilliamboswell/roc-platform-template-wasi/tree/main/zig-out/bin</a></p>",
        "id": 455515791,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722473857
    },
    {
        "content": "<p>I think the next step is linking. I can think of two options that might work;</p>\n<ol>\n<li>Use the roc <code>--dev</code> backend and Additive linker somehow -- we probably need to use the <a href=\"https://github.com/roc-lang/roc/tree/rebuild-platform\">rebuild-platform</a> branch and make some changes in <code>crates/compiler/build/src/link.rs</code> so it doesn't expect a <code>hozt.zig</code> and try to rebuild the host. </li>\n<li>Compile the roc app using e.g. <code>$ roc build --target=wasm32 --no-link app.roc</code> which gives us a <code>app.wasm</code> and then linking that with our <code>host.wasm</code> using some other tool. Maybe this can even be done in the browser?</li>\n</ol>\n<p>Hopefully everything combines and we get a nice WASM binary that meets the requirements for WASI and we can run it using a runtime like wasmer, or load into the browser with a shim.</p>",
        "id": 455516401,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722474203
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515757\">Luke Boswell</span> <a href=\"#narrow/stream/316715-contributing/topic/playground.2Frepl.20with.20LSP.20support/near/455516401\">said</a>:</p>\n<blockquote>\n<p>I think the next step is linking. I can think of two options that might work;</p>\n<ol>\n<li>Use the roc <code>--dev</code> backend and Additive linker somehow -- we probably need to use the <a href=\"https://github.com/roc-lang/roc/tree/rebuild-platform\">rebuild-platform</a> branch and make some changes in <code>crates/compiler/build/src/link.rs</code> so it doesn't expect a <code>hozt.zig</code> and try to rebuild the host. </li>\n<li>Compile the roc app using e.g. <code>$ roc build --target=wasm32 --no-link app.roc</code> which gives us a <code>app.wasm</code> and then linking that with our <code>host.wasm</code> using some other tool. Maybe this can even be done in the browser?</li>\n</ol>\n<p>Hopefully everything combines and we get a nice WASM binary that meets the requirements for WASI and we can run it using a runtime like wasmer, or load into the browser with a shim.</p>\n</blockquote>\n<p>Maybe a stupid question, but shouldn't the compiler compile the Zig-based host with the wasm target?</p>",
        "id": 455622227,
        "sender_full_name": "Bram",
        "timestamp": 1722511439
    },
    {
        "content": "<p>I'm definitely skipping over a lot of detail here, so I apologise for that. I've been working to try and understand WASM and platform things for a while and it's still not completely clear in my head.</p>\n<p>I'm thinking about how it should work in future, with a couple of WIP PR's that should land soon and change the way platform hosts are built. Specifically, the platforms will be responsible for building their own binaries, which frees roc from that responsibility and leaves roc to just produce the \"roc\" binary and link it with the host. </p>\n<p>In our case, this means that for any platform to support the playground it would need to provide a binary that can be run in the browser. WASM is the obvious choice here as the other formats (macos-aarch64, linux-x64 etc) wouldn't be very useful. </p>\n<p>It makes sense for the WASM host to be targeting WASI as that means it would be runnable using any of the various runtimes (after linking with the app). We could build the app and run it using <code>wasmer</code> or <code>wasmtime</code> etc, or just upload the <code>app.wasm</code> file to any of the edge compute platforms like cloudfare or fastly. We can probably assume that there will be a WASI shim or runtime we can piggy-back off to do this in the browser too for our playground.</p>\n<p>The other alternative, is that we have some kind of playground specific API that platform authors can choose to support. The platform author builds the host into freestanding WASM with this API, so it can be loaded into the playground environment. This may be the easier (or only feasible) way to do things.</p>\n<p>My wasi platform template is an attempt at doing the first. It currently provides a <code>host.wasm</code> binary that targets WASI. Thought I'm not totally sure if we can even do things this way. I had a look yesterday at linking with the app manually and got an error about the wasm file no being relocatable. At the time I needed to get back to work, so I paused my exploration.</p>\n<p>I think the way WASM is currently done in roc is that there must be a <code>host.zig</code> file, and roc will \"rebuild the platform\". The host is compiled to llvm bitcode I think, and then linked with the app. So it's not really a standalone host, and doesn't work with a URL platform that needs to provide a pre-built host.</p>",
        "id": 455775613,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722554948
    },
    {
        "content": "<p>I spent a lot of time yesterday looking at WASM hosts and linking. I don't think I made any progress unfortunately. I'll come back to this topic again at some point, but just wanted to let you know I'm stuck and will probably move onto to other priorities for now.</p>",
        "id": 456065422,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722645246
    },
    {
        "content": "<p>thanks for giving it a shot!</p>",
        "id": 456065892,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1722645700
    },
    {
        "content": "<p>Great news... I managed to get it working!!! <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> </p>\n<p><a href=\"https://github.com/lukewilliamboswell/roc-platform-template-wasi\">https://github.com/lukewilliamboswell/roc-platform-template-wasi</a></p>\n<p>I'm super stoked about this. I've included a <code>build.sh</code> script which steps through things manually, but from here I think there is a clear path to supporting WASI prebuilt-hosts.</p>",
        "id": 456125439,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722675120
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>$ wasmtime out.wasm\nRoc loves WASI\nRuntime: 0.223ms\n</code></pre></div>",
        "id": 456125496,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722675143
    },
    {
        "content": "<p>And I think it consistency takes &lt;100ms to build and link the app (with the prebuilt host). I'm having trouble measuring it tbh.</p>",
        "id": 456126625,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1722675735
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"515757\">@Luke Boswell</span>  great to see it working. I have been busy lately with work, and more importantly, my vacation <span aria-label=\"sunglasses\" class=\"emoji emoji-1f60e\" role=\"img\" title=\"sunglasses\">:sunglasses:</span> </p>\n<p>I was wondering if there is any low-hanging fruit that I could help with?<br>\nWhat was the conclusion from the exploration of a platformless roc? Should we wait on build pipeline changes that potentially emerge from that exploration, or go ahead and try to hook wasm platform support into what we currently have now?</p>",
        "id": 466992759,
        "sender_full_name": "Bram",
        "timestamp": 1725293175
    },
    {
        "content": "<p>Gday Bram, good to see you back post-vacation. </p>\n<p><em>It's difficult to talk about this topic because there are so many different parts involved, and I'm also learning as I explore things, so please ask for clarification if anything here isn't clear.</em></p>\n<p>The answer depends on what we would like to achieve I think.</p>\n<p>The longer term goal of a generic playground in the browser is achievable, but there is some blockers that need to be investigated. The first issue  I can see is that we want the compiler to run inside the browser, and in that context we can't use LLVM or Zig (so the legacy linker and llvm backend aren't available). We should be able use the <code>gen_wasm</code> backend (and the wasm additive linker) like the wasm repl that is used on the website but this hasn't been done before, and so I think there is a bit of research and development here to do.</p>\n<p>I spent some time exploring in this direction and was able to get a WASI version of the compiler that compiles a roc app using gen_wasm -- it's actually pretty simple to get working**. I can share it with you but I haven't made it a public repository because it's pretty hacky/proof of concept stage.</p>\n<p>** by working, I mean it compiles and produces something... I don't know if it's actually doing things correctly as I haven't got a fully working example yet.</p>\n<p>I ran into some complications around generating a WASI app and also potentially trying to compile a roc app that uses a platform and/or with multiple files -- I think I was trying to do too much at once. This is unlike the current wasm repl, which loads a single module and links with a simple host implementation (which we know works well). </p>\n<p>I'm not sure what my issue was; it could be a bug in gen_wasm, or perhaps the way I was setting up the prebuilt WASM host (for additive linking), or perhaps in the way I was using the compiler to set things up. </p>\n<p>Basically, I got as far as a WASI compiler that compiles a roc app (that was using a platform with a Task based API <code>main: Task {} I32</code>) to WASI, but the output binary wasn't valid. Using wam binary tools, <code>wasm-validate app.wasm</code> would complain about a leb128 encoding error. Brian helped me look into this, and his recommendation was to simplify things because there are currently too many variables that could be giving us grief. At this point, I've had to put this on the backburner to focus on other things -- but the next step here would be to pare things back and use a simpler platform, simpler host, and maybe generate a wasm32-unknown-unknown application.</p>\n<p>If we want to build a simple playground that is is limited to a single module and hardcoded interface e.g. it only exposes a couple of functions to solve an Advent of Code puzzle or similar. This would be almost identical to the wasm repl setup we have now, and I think it would be much easier to achieve. I'm not sure howthis interacts with the LSP though.</p>\n<p>If we are wanting to use the roc cli to compile WASM/WASI apps, and are not talking about a playground in the browser, then it's also much easier to do. The <a href=\"https://github.com/roc-lang/roc/pull/6859\">build-host PR</a> should get us pretty close. We can use LLVM and Zig to link with a prebuilt host in the platform. The key thing I'm hoping to gain over the status quo is that the platform can be prebuilt and roc is just linking things together.</p>\n<p>If you want a nice WASI platform, and are happy to let zig (or the host toolchain) drive the linking, it's quite easy to do today. Just build the app first <code>roc build --target wasm32 --emit-llvm-ir</code> and then use that to build the host.</p>",
        "id": 467077731,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1725325646
    }
]