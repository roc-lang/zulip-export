[
    {
        "content": "<p>I just discovered the hard way that our JSON decoder decodes <code>null</code> into the string <code>\"null\"</code> <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 400003081,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698951227
    },
    {
        "content": "<p>only if you expect to decode it to a string, right?</p>",
        "id": 400003742,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1698951523
    },
    {
        "content": "<p>somebody somewhere would call it a feature</p>",
        "id": 400003783,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1698951539
    },
    {
        "content": "<p>I think this is because we hadn't decided on a convention for what it should do with nulls</p>",
        "id": 400012397,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698955756
    },
    {
        "content": "<p>I think <code>[Null, NotNull a]</code> seems like the frontrunner because it's very explicit, and also means you can do stuff like <code>{ email: Null }</code> and have it generate the right JSON</p>",
        "id": 400012548,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698955833
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"515757\">@Luke Boswell</span> do you think you'd have bandwidth to add null handling to your json package?</p>\n<p>it's the first Roc in production blocker we've run into at work (which is, in one sense, a milestone for the language! <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span><span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span><span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span>)</p>",
        "id": 400012736,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698955936
    },
    {
        "content": "<p>oh wait, <span class=\"user-mention\" data-user-id=\"454654\">@Ayaz Hafiz</span> - <code>Decoding</code> doesn't support tag unions yet, does it?</p>",
        "id": 400013271,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698956258
    },
    {
        "content": "<p>we would need that to be able to decode into <code>[Null, NotNull Str]</code> or whatever</p>",
        "id": 400013346,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698956288
    },
    {
        "content": "<p>I should have some time today to look at it. Might be hlepful to make a summary of things not yet supported. We also dont support Dicts yet.</p>",
        "id": 400017695,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1698958516
    },
    {
        "content": "<p>nice! Actually another one that should be unblocked is being able to decode objects with extra fields</p>",
        "id": 400017853,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698958587
    },
    {
        "content": "<p>From memory I think tags are good to go. Do you think it shouldn't be possible to decode a null or true or false into a Str? The alternative is these fail, and must use tags instead.</p>",
        "id": 400017861,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1698958594
    },
    {
        "content": "<p>e.g. if I want to decode <code>{ a, b }</code> from a JSON object that has <code>\"a\"</code>, <code>\"b\"</code>, and also <code>\"c\"</code> as fields, that fails currently</p>",
        "id": 400017892,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698958609
    },
    {
        "content": "<p>yeah I think they should fail</p>",
        "id": 400017907,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698958619
    },
    {
        "content": "<p>like if we get a <code>null</code> and we expected a string, that should fail</p>",
        "id": 400017929,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698958631
    },
    {
        "content": "<p>if we think null could happen instead of string, we should decode into <code>[Null, NotNull Str]</code></p>",
        "id": 400017965,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698958651
    },
    {
        "content": "<p>I thought extra fields were just ignored. I can look at that too.</p>",
        "id": 400018062,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1698958690
    },
    {
        "content": "<p>sweet, thank you so much! <span aria-label=\"heart eyes\" class=\"emoji emoji-1f60d\" role=\"img\" title=\"heart eyes\">:heart_eyes:</span></p>",
        "id": 400018136,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698958725
    },
    {
        "content": "<p>btw the PascalCase field mapping came up right away and was super useful, so thanks for that! <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 400018541,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698958909
    },
    {
        "content": "<blockquote>\n<p>Decoding doesn't support tag unions yet, does it?</p>\n</blockquote>\n<p>Yeah it doesn't</p>",
        "id": 400022070,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1698960688
    },
    {
        "content": "<p>I forget - were there unsolved design questions there?</p>",
        "id": 400022110,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698960720
    },
    {
        "content": "<p>or is it unblocked but just not implemented</p>",
        "id": 400022162,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698960730
    },
    {
        "content": "<p>Oh right, we currently encode tags, but can't decode them.</p>",
        "id": 400023943,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1698961838
    },
    {
        "content": "<p>yeah that makes sense</p>",
        "id": 400024858,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698962357
    },
    {
        "content": "<p>So if we don't have tags, would you like me to update and have roc-json fail when trying to decode a Null into a string?</p>",
        "id": 400025971,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1698962902
    },
    {
        "content": "<p>That is an easy change, just remove this when statement</p>\n<div class=\"codehilite\"><pre><span></span><code>decodeString = Decode.custom \\bytes, @Json {} -&gt;\n    when bytes is\n        [&#39;n&#39;, &#39;u&#39;, &#39;l&#39;, &#39;l&#39;, ..] -&gt;\n            { result: Ok &quot;null&quot;, rest: List.dropFirst bytes 4 }\n</code></pre></div>",
        "id": 400026079,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1698962980
    },
    {
        "content": "<p>the specific scenario we ran into at work is needing to distinguish between null and non-null things</p>",
        "id": 400026878,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698963438
    },
    {
        "content": "<p>so <code>Bool</code> errors out on null at the moment, which is actually a blocker <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 400026889,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698963447
    },
    {
        "content": "<p>so what we need is to be able to tell the difference, not to have it error out (or change it to a default value)</p>",
        "id": 400026916,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698963468
    },
    {
        "content": "<p>in other words, we need tags</p>",
        "id": 400026922,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698963473
    },
    {
        "content": "<p>It's easy enough to default null to false when decoding a Bool</p>",
        "id": 400027763,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1698963940
    },
    {
        "content": "<p>unfortunately in this use case we specifically need to be able to distinguish between null, true, and false <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 400027930,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698964040
    },
    {
        "content": "<p>but I think accepting unused object fields, should be unblocked, yeah?</p>",
        "id": 400028489,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698964350
    },
    {
        "content": "<p>I think it should be working with <code>jsonWithOptions = \\{ fieldNameMapping ? Default, skipMissingProperties ? Bool.true }</code></p>",
        "id": 400028822,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1698964564
    },
    {
        "content": "<p>Setting <code>skipMissingProperties: Bool.true</code> should be working</p>",
        "id": 400028862,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1698964584
    },
    {
        "content": "<p>ahh interesting</p>",
        "id": 400029063,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698964708
    },
    {
        "content": "<p>can we default that to true?</p>",
        "id": 400029072,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698964713
    },
    {
        "content": "<p>It is currently</p>\n<div class=\"codehilite\"><pre><span></span><code>## Returns a JSON `Encoder` and `Decoder`\njson = @Json { fieldNameMapping: Default, skipMissingProperties: Bool.true }\n\n## Returns a JSON `Encoder` and `Decoder` with configuration options\n##\n## `skipMissingProperties` - if `True` the decoder will skip additional properties\n## in the json that are not present in the model. (Default: `True`)\njsonWithOptions = \\{ fieldNameMapping ? Default, skipMissingProperties ? Bool.true } -&gt;\n    @Json { fieldNameMapping, skipMissingProperties }\n</code></pre></div>",
        "id": 400029159,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1698964768
    },
    {
        "content": "<p>And here is the test for it which passes</p>\n<div class=\"codehilite\"><pre><span></span><code># Test decode of partial record with multiple additional fields\nexpect\n    input = Str.toUtf8 &quot;{\\&quot;extraField\\&quot;:2, \\&quot;ownerName\\&quot;: \\&quot;Farmer Joe\\&quot;, \\&quot;extraField2\\&quot;:2 }&quot;\n    actual : DecodeResult { ownerName : Str }\n    actual = Decode.fromBytesPartial input json\n\n    expected = Ok { ownerName: &quot;Farmer Joe&quot; }\n\n    result = actual.result\n    result == expected\n</code></pre></div>",
        "id": 400029279,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1698964835
    },
    {
        "content": "<p>oh but what about <code>Decode.decode</code>?</p>",
        "id": 400029450,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698964935
    },
    {
        "content": "<blockquote>\n<p>or is it unblocked but just not implemented</p>\n</blockquote>\n<p>Yeah, it's this. We have a design for it here: <a href=\"https://github.com/roc-lang/roc/issues/3816\">https://github.com/roc-lang/roc/issues/3816</a>. In principle (\"principle\") it should mostly be a copy-paste of what's needed for records</p>",
        "id": 400057496,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1698982221
    },
    {
        "content": "<p>awesome! Does anyone want to take a shot at implementing that? Could be a fun self-contained way to make a change to that part of the compiler <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span> </p>\n<p>(with outside help and guidance of course!)</p>",
        "id": 400057847,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1698982478
    },
    {
        "content": "<p>if nobody else is interested, I'll pick it up, but I figured it might be a good introductory project to compiler type system stuff</p>",
        "id": 400315803,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1699119305
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281383\">@Richard Feldman</span> if you haven't started on it yet I'd be interested in doing it. I have a good chunk of time I could spend on it tomorrow. That said, if it's very time sensitive to get it done for your work then I'll hold off.</p>",
        "id": 400325506,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1699130016
    },
    {
        "content": "<p>that's awesome, go for it! <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 400325560,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1699130060
    },
    {
        "content": "<p>Okay sweet! Any guidance before I dig in?</p>",
        "id": 400325655,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1699130195
    },
    {
        "content": "<p>re-reading the notion doc linked in the issue, I don't remember what the <code>Nat</code> in <code>discriminant</code> does, or how this would work when specifically decoding the bytes <code>null</code> into a tag union  <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> </p>\n<p><span class=\"user-mention\" data-user-id=\"454654\">@Ayaz Hafiz</span> do you remember how those would work?</p>",
        "id": 400326021,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1699130754
    },
    {
        "content": "<p>it returns the index of the matched discriminant given the list of discriminants</p>",
        "id": 400327112,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1699132041
    },
    {
        "content": "<p>the formatter could match null on the empty discriminant</p>",
        "id": 400327179,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1699132105
    },
    {
        "content": "<p>hm, I still don't follow <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> - how would that look in practice?</p>",
        "id": 400327207,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1699132169
    },
    {
        "content": "<p>so when <code>Json</code> encounters a <code>null</code> it calls <code>DecoderFormatting.discriminant [[]]</code> ? But in that case, how would that get translated to a <code>[Null, NotNull a]</code> on the decoded side?</p>",
        "id": 400327395,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1699132368
    },
    {
        "content": "<p>No, the point is that the formatter implements discriminant right</p>",
        "id": 400328187,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1699133412
    },
    {
        "content": "<p>So JSON implements that function</p>",
        "id": 400328193,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1699133425
    },
    {
        "content": "<p>So given [[A],[B],[]] the formatter would return a decoder that when matched on null returns 2</p>",
        "id": 400328209,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1699133479
    },
    {
        "content": "<p>And then that index is used to figure out what “sequence” function should be called</p>",
        "id": 400328221,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1699133512
    },
    {
        "content": "<p>which for the index 2 case here, would return the variant named Null</p>",
        "id": 400328266,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1699133531
    },
    {
        "content": "<blockquote>\n<p><code>[[A],[B],[]]</code></p>\n</blockquote>\n<p>is this the type of a tag union?</p>",
        "id": 400328303,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1699133626
    },
    {
        "content": "<p>No, the list of discriminants passed to the discriminant function</p>",
        "id": 400328347,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1699133657
    },
    {
        "content": "<p>The relevant tag union would be “A …, B…, Null”, I suppose</p>",
        "id": 400328354,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1699133678
    },
    {
        "content": "<p>ah gotcha - <span class=\"user-mention\" data-user-id=\"611722\">@Isaac Van Doren</span> does that make sense? Happy to answer questions if it would help!</p>",
        "id": 400328474,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1699133860
    },
    {
        "content": "<p>I haven't looked at the implementation yet but I think this will be enough for me to get started tomorrow <span aria-label=\"check\" class=\"emoji emoji-2705\" role=\"img\" title=\"check\">:check:</span></p>",
        "id": 400329534,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1699135298
    },
    {
        "content": "<p>What is the status of decoding tuples from json? I see that it's implemented but haven't gotten it to work</p>",
        "id": 400443001,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1699235946
    },
    {
        "content": "<p>do you have an example you've tried?</p>",
        "id": 400448014,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1699239346
    },
    {
        "content": "<p>As I was typing up a compact example, I got it to work. Looks like the reason it wasn't working before is because the file I was reading in had whitespace in it. </p>\n<p>For example, this fails</p>\n<div class=\"codehilite\"><pre><span></span><code>expect\n    actual = Decode.fromBytes (&quot;[ 123,456]&quot; |&gt; Str.toUtf8) Core.json\n    expected = Ok (123,456)\n    actual == expected\n</code></pre></div>\n<p>but it passes if I remove the space before 123. So I guess just a bug with whitespace then</p>",
        "id": 400448835,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1699239771
    },
    {
        "content": "<p>ah nice! can you open an issue for that?</p>",
        "id": 400448857,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1699239791
    },
    {
        "content": "<p>Will do!</p>",
        "id": 400449067,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1699239944
    },
    {
        "content": "<p><a href=\"https://github.com/lukewilliamboswell/roc-json/issues/5\">https://github.com/lukewilliamboswell/roc-json/issues/5</a></p>",
        "id": 400449633,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1699240404
    },
    {
        "content": "<p>Also, what's the status for removing the rest of <code>TotallyNotJson</code> from the builtins? Is it blocked or ready to proceed? I see that there is a partial PR from June to do so</p>",
        "id": 400449814,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1699240538
    },
    {
        "content": "<p>Another thought, it might be nice to link to to roc-json somewhere on the Decode page so that it's easier to find. I had to dig around in Zulip for a while before I could figure out where Json was moved to.</p>",
        "id": 400449936,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1699240605
    },
    {
        "content": "<p>I think the tests need to be updated to use a shim implementation, but I don't think there's any blocker. I think <span class=\"user-mention\" data-user-id=\"515757\">@Luke Boswell</span> has the most context</p>",
        "id": 400450007,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1699240666
    },
    {
        "content": "<p>On another note, this approach to decoding is so cool <span aria-label=\"star struck\" class=\"emoji emoji-1f929\" role=\"img\" title=\"star struck\">:star_struck:</span>. Very slick to be able to do it without any type annotations if desired</p>",
        "id": 400451003,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1699241430
    },
    {
        "content": "<p>yeah it's crazy, right</p>",
        "id": 400451041,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1699241460
    },
    {
        "content": "<p>still blows my mind</p>",
        "id": 400451047,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1699241465
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"454654\">Ayaz Hafiz</span> <a href=\"#narrow/stream/316715-contributing/topic/json.20null.20handling/near/400451047\">said</a>:</p>\n<blockquote>\n<p>still blows my mind</p>\n</blockquote>\n<p>and you made it!!! <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 400451079,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1699241496
    },
    {
        "content": "<p>Re removing TotallyNotJson I couldn't figure out how to inline the module into the rust tests at the time. I described the issue in a zulip thread I think, or maybe the issue. On my phone rn, I can dig into it later. I don't think there are any issues, it was just beyond my rust skills and probably a bit ambitious for someone with less than a month rust exposure <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 400473388,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1699254322
    },
    {
        "content": "<p>This <a href=\"https://github.com/roc-lang/roc/pull/5543\">#5543</a> is the inactive PR I was working on. I haven't looked at this in a while, and don't plan to any time soon. I probably should close this PR as I imagine it is pretty stale now.</p>",
        "id": 400490968,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1699262596
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"611722\">@Isaac Van Doren</span> while you are looking at that part of the code base, there is another issue <a href=\"https://github.com/roc-lang/roc/issues/5294\">#5294</a> which would be super useful. This would mean we can decode json straight into dicts. </p>\n<p>i.e. <code>{'Mickey Mouse':'Disney', 'Donald Duck':'Disney', 'Daffy Duck':'Warner Brothers', 'Fred Flintstone':'Hanna Barbera'}</code><br>\ncould be decoded into <code>Dict Str Str</code></p>",
        "id": 400492086,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1699263039
    },
    {
        "content": "<p>I don't know how hard that is to implement. But just thought I would mention in case you are interested.</p>",
        "id": 400492184,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1699263077
    },
    {
        "content": "<p>Okay sounds good. Thanks for mentioning it, I’ll keep it in mind if I get that far! It would be very nice to have</p>",
        "id": 400536332,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1699279003
    },
    {
        "content": "<p>Trying to wrap my head around how this stuff works, so I could be totally off here. Do we need to have a <br>\n<code>sequence : state, (state -&gt; [Keep (Decoder state fmt), Skip]), (state -&gt; Result val DecodeError) -&gt; Decoder val fmt | fmt has DecoderFormatting</code><br>\nwhen we already have a <br>\n<code>tuple : state, (state, Nat -&gt; [Next (Decoder state fmt), TooLong]), (state -&gt; Result val DecodeError) -&gt; Decoder val fmt where fmt implements DecoderFormatting</code>?</p>\n<p>It seems like perhaps it could serve the same purpose.</p>",
        "id": 400663099,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1699332466
    },
    {
        "content": "<p>They seem to have different goals. Sequence looks to collect or skip items from a list while tuple takes a list of a specific length. So it would never skip anything and must fail if there are too few or many items.</p>",
        "id": 400663381,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1699332620
    },
    {
        "content": "<p>Though probably could be merged if really wanted. Would need a combined tag and more complex state machine.</p>",
        "id": 400663452,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1699332666
    },
    {
        "content": "<p>Also, what final type does sequence generate? I assume a list instead of a tuple?</p>",
        "id": 400663589,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1699332736
    },
    {
        "content": "<p>I think they both would take a list of a specific length. Because the appropriate call to sequence would be made based on the particular tag that is trying to be decoded into. So in that case the arity of the tag (i.e. the length of the list) is known.</p>",
        "id": 400664588,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1699333350
    },
    {
        "content": "<p>I think the usage of Keep and Skip may have been borrowed from the record decoder. I don’t see why you would want to skip some values if you’re trying to decode into a tag</p>",
        "id": 400664663,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1699333408
    },
    {
        "content": "<blockquote>\n<p>Also, what final type does sequence generate? I assume a list instead of a tuple?</p>\n</blockquote>\n<p>The idea is to use sequence to decode into a Tag with payload so basically the same thing as a tuple</p>",
        "id": 400664803,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1699333528
    },
    {
        "content": "<p>ah sequence is for tags. I'm not sure then cause a tag isn't really a tuple. A tag is a enum and then anything (record, list, tuple, etc)</p>",
        "id": 400664937,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1699333600
    },
    {
        "content": "<p>Right I should have been more clear. What I mean is that T a b c holds basically the same payload as (a,b,c).</p>",
        "id": 400665222,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1699333829
    },
    {
        "content": "<p>ah yeah, totally.</p>",
        "id": 400665295,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1699333915
    },
    {
        "content": "<p>Yeah i think using Tuple is fine</p>",
        "id": 400665685,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1699334165
    },
    {
        "content": "<p>I wrote that document before tuples existed <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 400665703,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1699334181
    },
    {
        "content": "<p>Okay cool</p>",
        "id": 400739141,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1699363535
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"611722\">@Isaac Van Doren</span> how are things going on this? I'm happy to help with anything! <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 401884639,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1699927243
    },
    {
        "content": "<p>I’ve got most of the boilerplate for a module to derive tag unions, implemented discriminant, and mostly figured out how the decoding stuff fits together. </p>\n<p>The next step is getting a sample implementation of what the derived decoder should be for an example tag Union so that I can test it and make sure I’m on the right track before writing all the code to actually generate it.</p>\n<p>Originally I thought I would be able to use the tue decoder for the payload of a tag but I realized that won’t work because it needs to work for an empty tuples and single element tuple.</p>\n<p>So I’ll need to implement sequence as Ayaz had originally thought might be necessary.</p>\n<p>Once I have that I’ll have the example implementation done.</p>\n<p>I’ve had some issues with building my branch which I don’t yet understand. Specifically, cargo check succeeded but cargo build hung on roc_load. Do you have an idea about what could cause this? Also have not gotten rust analyzer and cargo to play together nicely yet. </p>\n<p>If you need this done more promptly for work I am happy to let you take over.</p>",
        "id": 401990781,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1699970006
    },
    {
        "content": "<p>oh wow, awesome!</p>",
        "id": 401991291,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1699970157
    },
    {
        "content": "<p>it's not urgent, and I'm excited to see your progress! <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 401991382,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1699970176
    },
    {
        "content": "<p>if you <code>git bisect</code>, can you find out which commit introduced the hang? I might have some ideas based on that</p>",
        "id": 401991568,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1699970235
    },
    {
        "content": "<blockquote>\n<p>Also have not gotten rust analyzer and cargo to play together nicely yet.</p>\n</blockquote>\n<p>The <a href=\"https://github.com/roc-lang/roc/tree/main/devtools\">devtools flake</a> should fix that</p>",
        "id": 401993346,
        "sender_full_name": "Anton",
        "timestamp": 1699970661
    },
    {
        "content": "<p>Does build hang around roc_load? If so I suspect it’s due to the builtins not compiling. you can try “cargo build -vvv” which should be much more verbose and show if that’s the issue. I suspect you may need to add the discriminant/sequence implementation to the Json module in the stdlib if you haven’t already</p>",
        "id": 401994036,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1699970872
    },
    {
        "content": "<p>Okay good to know, I’ll try that. I have added the implementation to the Json module but there could certainly still be an error</p>",
        "id": 402086060,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1700002861
    },
    {
        "content": "<p>do you mean <code>TotallyNotJson</code> in the <code>roc/</code> repo?</p>",
        "id": 402086194,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1700002907
    },
    {
        "content": "<blockquote>\n<p>The <a href=\"https://github.com/roc-lang/roc/tree/main/devtools\">devtools flake</a> should fix that</p>\n</blockquote>\n<p>Yes I need to get the setup! Right now I have the LSP building in a different directory which solved the main problem it seems</p>",
        "id": 402086348,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1700002948
    },
    {
        "content": "<blockquote>\n<p>do you mean <code>TotallyNotJson</code> in the <code>roc/</code> repo? </p>\n</blockquote>\n<p>Yes</p>",
        "id": 402086376,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1700002959
    },
    {
        "content": "<p>I can probably figure something out once I get a chance to look into it more with the verbose output</p>",
        "id": 402086565,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1700003032
    },
    {
        "content": "<p>cool, let us know if you get stuck, and we can try some other things!</p>",
        "id": 402086633,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1700003057
    },
    {
        "content": "<p>I have an example implementation of a derived decoder for a tag union:</p>\n<div class=\"codehilite\"><pre><span></span><code>example : Decoder [Zero, One a, Two b c] fmt where a implements Decoding, b implements Decoding, c implements Decoding, fmt implements DecoderFormatting\nexample =\n    nameDecoder =\n        [&quot;Zero&quot;, &quot;One&quot;, &quot;Two&quot;]\n        |&gt; List.map Str.toUtf8\n        |&gt; discriminant\n\n    Decode.custom \\bytes, fmt -&gt;\n        { result: nameResult, rest: bytesAfterName } = Decode.decodeWith bytes nameDecoder fmt\n        when nameResult is\n            Err _ -&gt; { result: Err TooShort, rest: bytesAfterName }\n            Ok index -&gt;\n                when index is\n                    0 -&gt;\n                        state = {}\n                        stepper = \\_, _ -&gt; TooLong\n                        finalizer = \\_ -&gt; Ok Zero\n\n                        Decode.decodeWith bytesAfterName (Decode.tuple state stepper finalizer) fmt\n\n                    1 -&gt;\n                        state = { e0: Err TooShort }\n                        stepper = \\s, i -&gt;\n                            when i is\n                                0 -&gt;\n                                    Next\n                                        (\n                                            Decode.custom \\b, f -&gt;\n                                                when Decode.decodeWith b Decode.decoder f is\n                                                    { result, rest } -&gt;\n                                                        { result: Result.map result \\val -&gt; { s &amp; e0: Ok val }, rest }\n                                        )\n\n                                _ -&gt; TooLong\n                        finalizer = \\s -&gt;\n                            when s is\n                                { e0: Ok val } -&gt; Ok (One val)\n                                _ -&gt; Err TooShort\n\n                        Decode.decodeWith bytesAfterName (Decode.tuple state stepper finalizer) fmt\n\n                    2 -&gt;\n                        state = { e0: Err TooShort, e1: Err TooShort }\n                        stepper = \\s, i -&gt;\n                            when i is\n                                0 -&gt;\n                                    Next\n                                        (\n                                            Decode.custom \\b, f -&gt;\n                                                when Decode.decodeWith b Decode.decoder f is\n                                                    { result, rest } -&gt;\n                                                        { result: Result.map result \\val -&gt; { s &amp; e0: Ok val }, rest }\n                                        )\n\n                                1 -&gt;\n                                    Next\n                                        (\n                                            Decode.custom \\b, f -&gt;\n                                                when Decode.decodeWith b Decode.decoder f is\n                                                    { result, rest } -&gt;\n                                                        { result: Result.map result \\val -&gt; { s &amp; e1: Ok val }, rest }\n                                        )\n\n                                _ -&gt; TooLong\n                        finalizer = \\s -&gt;\n                            when s is\n                                { e0: Ok v0, e1: Ok v1 } -&gt; Ok (Two v0 v1)\n                                _ -&gt; Err TooShort\n\n                        Decode.decodeWith bytesAfterName (Decode.tuple state stepper finalizer) fmt\n\n                    _ -&gt; { result: Err TooShort, rest: bytesAfterName }\n</code></pre></div>\n<p>It type checks (<span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span>) but I have not been able to test it.</p>\n<p>When I run this (using cargo)</p>\n<div class=\"codehilite\"><pre><span></span><code>expect\n    actual = Decode.decodeWith (&quot;Two:[3,\\&quot;foo\\&quot;]&quot; |&gt; Str.toUtf8) example json\n    actual.result == Ok (Two 3 &quot;foo&quot;)\n</code></pre></div>\n<p>I get </p>\n<div class=\"codehilite\"><pre><span></span><code>thread &#39;&lt;unnamed&gt;&#39; panicked at &#39;unspecialized lambda sets left over during resolution: LambdaSet([] + (&lt;22014&gt;FlexAble(a, [`Decode.Decoding`, `Bool.Eq`]):`Decode.decoder`:1), ^&lt;22018&gt;), UlsOfVar(VecMap { keys: [19831, 22014, 22367, 22462], values: [VecSet { elements: [19830] }, VecSet { elements: [22016] }, VecSet { elements: [22369] }, VecSet { elements: [22464] }] })&#39;, crates/compiler/mono/src/layout.rs:2074:17\n</code></pre></div>\n<p>Any suggestions about getting the testing to work or about the code in general? I figured it would be good to get feedback before I get too far in to implementing the code to generate it.</p>",
        "id": 402806889,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1700268717
    },
    {
        "content": "<p>if it's a lambda set problem, my general approach is \"cross  my fingers and hope <span class=\"user-mention\" data-user-id=\"454654\">@Ayaz Hafiz</span> knows\" <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 402809359,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1700269569
    },
    {
        "content": "<p>wow, is there 22K type variables in the derived implementation? or is that placed into a roc program?</p>",
        "id": 402812564,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1700270874
    },
    {
        "content": "<p>have you added tests in the derive crate? there are some checks there that make sure the type variables are well formed</p>",
        "id": 402812644,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1700270899
    },
    {
        "content": "<p>otherwise, if you can run a derive test with ROC_PRINT_UNIFICATIONS and ROC_TRACE_COMPACTION the output might give some pointers to us</p>",
        "id": 402812800,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1700270974
    },
    {
        "content": "<p>This is just an example I wrote myself to figure out what the compiler should derive. I had it in the TotallyNotJson module to test with the other functions there. Given that, are there still tests I could add in the derive crate that would be helpful?</p>",
        "id": 402812927,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1700271021
    },
    {
        "content": "<p>oh interesting</p>",
        "id": 402815601,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1700272601
    },
    {
        "content": "<p>I’m out right now but I can take a deeper look in a bit. you might be running into what i lovingly call the “higher region restriction”</p>",
        "id": 402815658,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1700272644
    },
    {
        "content": "<p>there are some notes on the possible patterns that cause it and workarounds here: <a href=\"https://github.com/roc-lang/roc/issues/3724\">https://github.com/roc-lang/roc/issues/3724</a></p>",
        "id": 402815751,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1700272701
    },
    {
        "content": "<p>Okay cool, I’ll check that out when I get a chance</p>",
        "id": 402816478,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1700273018
    },
    {
        "content": "<p>Can you share your branch?</p>",
        "id": 402837018,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1700286264
    },
    {
        "content": "<p>Yes here you go <a href=\"https://github.com/isaacvando/roc/tree/decode-tags-2\">https://github.com/isaacvando/roc/tree/decode-tags-2</a></p>",
        "id": 402896126,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1700328297
    },
    {
        "content": "<p>Alright, I don't know exactly why this is happening but it's not due to the HRR. But I suspect that it shouldn't be a blocker for the implementation of auto-derivation. I think this is a bug with type inference, but in the auto-deriver, the type variables will be explicitly linked together, and so things should \"just compile\"</p>",
        "id": 402959385,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1700369480
    },
    {
        "content": "<p>Thanks for looking into it! I’ll go ahead with implementing the deriving for this</p>",
        "id": 402963250,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1700371704
    },
    {
        "content": "<p>I would like to construct a <code>FlatDecodableKey::TagUnion(Vec&lt;(TagName, u16)&gt;)</code> <a href=\"https://github.com/roc-lang/roc/blob/531af182899835a9298efd758b927e5ba3e2f64a/crates/compiler/derive_key/src/decoding.rs#L75\">here</a> to be used in deriving the decoder. The u16 is the arity of the tag in question. I'm not sure where I can get the arity, any suggestions?</p>",
        "id": 404020033,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1700860099
    },
    {
        "content": "<p>here’s how it determined for Encode: <a href=\"https://github.com/roc-lang/roc/blob/531af182899835a9298efd758b927e5ba3e2f64a/crates/compiler/derive_key/src/encoding.rs#L80\">https://github.com/roc-lang/roc/blob/531af182899835a9298efd758b927e5ba3e2f64a/crates/compiler/derive_key/src/encoding.rs#L80</a></p>",
        "id": 404025221,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1700864415
    },
    {
        "content": "<p>Great, thanks!</p>",
        "id": 404051338,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1700883043
    },
    {
        "content": "<p>I've started working on generating code for the decoder. Actually generating the code is pretty straightforward but I'm not sure what do with all of the type variables, when to unify them, and which ones to unify. I don't know how unification works in detail so perhaps I need to get more familiar with it.</p>\n<p>That being said, I think I can probably get pretty far by using similar approaches to those used by the other decoder derivers.</p>\n<p>Is there a good way to test the unification part incrementally? Right now I have a test in test_derive which is useful because I can see the code that gets generated, but I'm not sure about the unification piece.</p>\n<p>This is my branch <a href=\"https://github.com/isaacvando/roc/tree/decode-tags-2\">https://github.com/isaacvando/roc/tree/decode-tags-2</a></p>",
        "id": 404772077,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1701229105
    },
    {
        "content": "<p>I'm also currently getting an error with the generated code about builtin functions not being found:</p>\n<div class=\"codehilite\"><pre><span></span><code>---- decoding::tag_union stdout ----\nthread &#39;decoding::tag_union&#39; panicked at &#39;Derived does not typecheck:\n── UNRECOGNIZED NAME ──────────────────────────────────────────────── Test.roc ─\n\nThe List module does not expose anything by the name `map`.\n\n── UNRECOGNIZED NAME ──────────────────────────────────────────────── Test.roc ─\n\nThe Str module does not expose anything by the name `toUtf8`.\n\nDerived def:\n#Derived.decoder_[A 2,B 1] = discriminant (List.map Str.toUtf8 [&quot;A&quot;, &quot;B&quot;])\n</code></pre></div>\n<p>I'm not sure if if this is because I'm referencing them wrong or maybe because the derived code doesn't type check?</p>\n<p>This is how I'm writing the calls:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">list_map_fn</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">((</span>\n<span class=\"w\">        </span><span class=\"n\">env</span><span class=\"p\">.</span><span class=\"n\">subs</span><span class=\"p\">.</span><span class=\"n\">fresh_unnamed_flex_var</span><span class=\"p\">(),</span>\n<span class=\"w\">        </span><span class=\"n\">Loc</span>::<span class=\"n\">at_zero</span><span class=\"p\">(</span><span class=\"n\">Expr</span>::<span class=\"n\">Var</span><span class=\"p\">(</span>\n<span class=\"w\">            </span><span class=\"n\">Symbol</span>::<span class=\"n\">LIST_MAP</span><span class=\"p\">,</span>\n<span class=\"w\">            </span><span class=\"n\">env</span><span class=\"p\">.</span><span class=\"n\">subs</span><span class=\"p\">.</span><span class=\"n\">fresh_unnamed_flex_var</span><span class=\"p\">(),</span>\n<span class=\"w\">        </span><span class=\"p\">)),</span>\n<span class=\"w\">        </span><span class=\"n\">env</span><span class=\"p\">.</span><span class=\"n\">subs</span><span class=\"p\">.</span><span class=\"n\">fresh_unnamed_flex_var</span><span class=\"p\">(),</span>\n<span class=\"w\">        </span><span class=\"n\">env</span><span class=\"p\">.</span><span class=\"n\">subs</span><span class=\"p\">.</span><span class=\"n\">fresh_unnamed_flex_var</span><span class=\"p\">(),</span>\n<span class=\"w\">    </span><span class=\"p\">));</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">list_map_to_utf8_call</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Expr</span>::<span class=\"n\">Call</span><span class=\"p\">(</span>\n<span class=\"w\">        </span><span class=\"n\">list_map_fn</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"fm\">vec!</span><span class=\"p\">[</span>\n<span class=\"w\">            </span><span class=\"p\">(</span>\n<span class=\"w\">                </span><span class=\"n\">env</span><span class=\"p\">.</span><span class=\"n\">subs</span><span class=\"p\">.</span><span class=\"n\">fresh_unnamed_flex_var</span><span class=\"p\">(),</span>\n<span class=\"w\">                </span><span class=\"n\">Loc</span>::<span class=\"n\">at_zero</span><span class=\"p\">(</span><span class=\"n\">Expr</span>::<span class=\"n\">Var</span><span class=\"p\">(</span>\n<span class=\"w\">                    </span><span class=\"n\">Symbol</span>::<span class=\"n\">STR_TO_UTF8</span><span class=\"p\">,</span>\n<span class=\"w\">                    </span><span class=\"n\">env</span><span class=\"p\">.</span><span class=\"n\">subs</span><span class=\"p\">.</span><span class=\"n\">fresh_unnamed_flex_var</span><span class=\"p\">(),</span>\n<span class=\"w\">                </span><span class=\"p\">)),</span>\n<span class=\"w\">            </span><span class=\"p\">),</span>\n<span class=\"w\">            </span><span class=\"p\">(</span>\n<span class=\"w\">                </span><span class=\"n\">env</span><span class=\"p\">.</span><span class=\"n\">subs</span><span class=\"p\">.</span><span class=\"n\">fresh_unnamed_flex_var</span><span class=\"p\">(),</span>\n<span class=\"w\">                </span><span class=\"n\">Loc</span>::<span class=\"n\">at_zero</span><span class=\"p\">(</span><span class=\"n\">list_of_variants</span><span class=\"p\">),</span>\n<span class=\"w\">            </span><span class=\"p\">),</span>\n<span class=\"w\">        </span><span class=\"p\">],</span>\n<span class=\"w\">        </span><span class=\"n\">CalledVia</span>::<span class=\"n\">Space</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"p\">);</span>\n</code></pre></div>\n<p>all the fresh_unnamed_flex_vars are placeholders for now</p>",
        "id": 404772763,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1701229370
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"454654\">@Ayaz Hafiz</span> do you know if there’s any good way to test parts of a derived decoder prior to having a full implementation?</p>",
        "id": 407101224,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1702238567
    },
    {
        "content": "<p>The uitest for deriving?</p>",
        "id": 407104052,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1702239917
    },
    {
        "content": "<p>They show then intermediate specializations info that is chosen</p>",
        "id": 407104089,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1702239938
    },
    {
        "content": "<p>Not really. You can try writing a test in the <code>test_derive</code> crate (check out for example the tests for encoding/decoding in that crate)</p>",
        "id": 407112643,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1702246279
    },
    {
        "content": "<p>They will check that the derived implementation is doesn't have type errors</p>",
        "id": 407112652,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1702246295
    },
    {
        "content": "<p>It looks like the addition of those tests was missed for inspect.</p>",
        "id": 407112661,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1702246308
    },
    {
        "content": "<p>Okay thanks</p>",
        "id": 407116418,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1702249802
    },
    {
        "content": "<p>I have a test written there which is useful to see the code that is generated but doesn’t help with the variables when I’m just checking a small chunk</p>",
        "id": 407116498,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1702249844
    },
    {
        "content": "<p>Another question, on Expr::Call there are three variables, one for the function, one for the closure, and one for function return type. What is the closure var and how does that differ from the function var?</p>",
        "id": 407116554,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1702249910
    },
    {
        "content": "<p>The closure var is the so called \"lambda set\"</p>",
        "id": 407120490,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1702253276
    },
    {
        "content": "<p>Each function type is of form <code>arg1, ..., argn -[clos]-&gt; ret</code>. The closure var is the \"clos\" part</p>",
        "id": 407120551,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1702253298
    },
    {
        "content": "<p>Okay cool, thanks</p>",
        "id": 407139796,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1702262687
    },
    {
        "content": "<p>Hi folks, working on this (adding support for decoding into tag unions) has become a drain recently so I am going to stop. If anyone would like to pick up on my progress, it is <a href=\"https://github.com/isaacvando/roc/tree/decode-tags-2\">here</a>. I implemented discriminant, the necessary boilerplate, an example derived decoder, and some of the code to generate decoders. Thanks for the help along the way! If anyone does want to pick it up I’m happy to answer questions about my approach.</p>",
        "id": 408719663,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1702949136
    },
    {
        "content": "<p>fair enough, thanks for taking it this far - really appreciate it! <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 408725828,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1702952117
    },
    {
        "content": "<p>Thanks for the opportunity! It was very cool to work on</p>",
        "id": 408744248,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1702956390
    }
]