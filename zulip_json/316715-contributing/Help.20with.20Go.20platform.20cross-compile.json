[
    {
        "content": "<p>I'm just wondering if there are any Go users who may be able to assist with <a href=\"https://github.com/roc-lang/examples/pull/173\">the Go platform example</a>?</p>\n<p>I was exploring changes so that the platform builds the pre-built binaries itself, and also cross-compiles to the various roc supported targets.</p>\n<p>If I compile for my native target (macos arm64) everything is happy and I get a c-archive for the host which links nicely with Roc and I can use with <code>roc dev --prebuilt-platform main.roc</code>. </p>\n<p>But as soon as I go to cross-compile for another target I get an issue <code>build constraints exclude all Go files</code> which seems strange as we don't specify any build constraints. I've been following various guides online and this doesn't seem to be a common thing.</p>\n<p>I've left a <code>build.sh</code> script in that branch to help debug this.</p>\n<div class=\"codehilite\"><pre><span></span><code>GOOS=linux GOARCH=arm64 go build -C host -buildmode=c-archive -o libhost.a\ncp host/libhost.a platform/macos-arm64.a\n\nroc dev --prebuilt-platform main.roc\n</code></pre></div>\n<p>Also, below is the WIP roc build script for building the platform for various architectures.</p>\n<div class=\"codehilite\" data-code-language=\"roc\"><pre><span></span><code>main =\n\n    buildGoTarget! MacosArm64\n\n    # TODO -- why is this failing with \"build constraints exclude all Go files\"?\n    buildGoTarget! MacosX64\n\n    # buildGoTarget! LinuxArm64\n    # etc\n\n    Stdout.line \"DONE\"\n\nbuildGoTarget : SupportedTarget -&gt; Task {} _\nbuildGoTarget = \\target -&gt;\n\n    (goos, goarch, prebuiltBinary) = when target is\n        MacosArm64 -&gt; (\"darwin\", \"arm64\", \"macos-arm64.a\")\n        MacosX64 -&gt; (\"darwin\", \"amd64\", \"macos-x64\")\n        LinuxArm64 -&gt; (\"linux\", \"arm64\", \"linux-arm64.a\")\n        LinuxX64 -&gt; (\"linux\", \"amd64\", \"linux-x64.a\")\n        WindowsArm64 -&gt; (\"windows\", \"arm64\", \"windows-arm64.a\")\n        WindowsX64 -&gt; (\"windows\", \"amd64\", \"windows-x64\")\n\n    Cmd.new \"go\"\n    |&gt; Cmd.envs [(\"GOOS\", goos), (\"GOARCH\", goarch)]\n    |&gt; Cmd.args [\"build\", \"-C\", \"host\", \"-buildmode=c-archive\", \"-o\",\"libhost.a\"]\n    |&gt; Cmd.status\n    |&gt; Task.mapErr! \\err -&gt; BuildErr goos goarch (Inspect.toStr err)\n\n    Cmd.exec \"cp\" [\"host/libhost.a\", \"platform/$(prebuiltBinary)\"]\n    |&gt; Task.mapErr! \\err -&gt; CpErr (Inspect.toStr err)\n</code></pre></div>",
        "id": 435813418,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1714274643
    },
    {
        "content": "<p>Could you tell exactly, what commands you are running and which returns the error message  <code>build constraints exclude all Go files</code>?</p>\n<p>The first command, you have to call is <code>roc build --lib main.roc --output host/libapp.so</code>. I can not see this in your build-scripts.</p>\n<p>You also have to call <code>roc preprocess-host main.roc</code>. This command internally calls <code>roc gen-stub-lib</code> which does something similar then <code>roc build --lib</code>, but is broken in some cases. This means, that <code>roc preprocess-host</code> creates a broken <code>libapp.so</code> file. You have to call <code>roc build --lib</code> every time after calling <code>roc preprocess-host</code> to replace the broken <code>libapp.so</code>.</p>\n<p>There are some strange things in your branch. Why are you using <code>go 1.23</code> ?  The latest go version is <code>1.22</code>. Some time ago, they changed the syntax of the <code>go.mod</code> file. You have to specify a miner version. For example <code>go 1.22.0</code> or <code>go 1.22.1</code>.</p>\n<p>You removed the <code>LDFLAGS</code> from the <code>main.go</code> file: <code>#cgo LDFLAGS: -L. -lapp</code> I don't think it works without it.</p>\n<p>Is there a reason, you are using <code>-buildmode=c-archive</code> instead of <code>-buildmode=pie</code>?</p>",
        "id": 435847209,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1714292403
    },
    {
        "content": "<p>You could also try to use <code>zig</code> as the c-compiler. If you want go cross compile cgo, you could get better results with it:</p>\n<p><code>CC=\"zig cc\" go build [...]</code></p>\n<p>If you look for \"cgo cross compile zig\" you find some articles, that explain, how zig helps to cross compile cgo.</p>",
        "id": 435847628,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1714292810
    },
    {
        "content": "<p>Thank you for your comments. I probably should have provided some more context for what I am trying to achieve and my intent here. </p>\n<p>I'm not necessarily wanting to merge that PR... I've been researching and working towards achieving <a href=\"https://github.com/roc-lang/roc/issues/6414\">https://github.com/roc-lang/roc/issues/6414</a> </p>\n<p>The intent is to remove the \"Rebuilding platform...\" from roc cli. So all platforms will be responsible for building their own prebuilt binaries and roc only needs to link with either a library (using the legacy linker) or where available the preprocessed host (surgical linker).</p>\n<p>I was updating the examples and the current  Go example doesn't work using the <code>ci/all_tests.sh</code> script for me. I started investigating that... and got sidetracked learning about the go build system and then started thinking about the changes for glue, and then thinking about how I could make a tool which scaffolds out starter platforms for various languages. It's a bit of a random thought process... but where the PR is at is kind of where I got to. I've almost got all the pieces that I could make a tool that scaffolds out a zig, rust, and now basic go platform that can cross compile to all of the roc supported targets.</p>\n<p>So, I've changed the example to build a c-archive and produce a <code>libhost.a</code> library instead of the dynamic library. That is why you can't see any <code>libapp.so</code>, because it's now doing something very different.</p>\n<p>I wasn't aware that <code>1.23</code> isn't the latest. I just had an error when I try to build that says I need to upgrade to <code>1.23</code>. It must be something that homebrew installed for me? <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span>  </p>\n<p>I removed the LDFLAGS as it didn't seem to be required any more, and included <code>#cgo CFLAGS: -Wno-main-return-type</code> as I was getting warnings for that. I needed to add <code>//export main</code> so that the static library kept the main symbol in the artefact.</p>\n<p>Using zig for the c-compiler sounds interesting. I'll explore that further. </p>\n<p>Thank you for your assistance.</p>",
        "id": 435849379,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1714294507
    },
    {
        "content": "<p>btw you can set some environment variables to prevent Homebrew from automatically updating things:</p>\n<div class=\"codehilite\"><pre><span></span><code>export HOMEBREW_NO_AUTO_UPDATE=1\nexport HOMEBREW_NO_INSTALL_UPGRADE=1\n</code></pre></div>",
        "id": 435866959,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1714303521
    },
    {
        "content": "<p>A bit of a follow up to the above. <span class=\"user-mention\" data-user-id=\"496321\">@Oskar Hahn</span> and I did some more investigation into this. The issue is related to how I've set up the cross compilation with Go in that PR. Using environment variables <code>CGO_ENABLED=1</code> and setting <code>CC</code> to a cross compiler looks to be the solution. I didnt quite get to the point of fully working static library due to obscure issues, but I've convinced myself that someone familiar with go could do this without too much trouble. </p>\n<p>My take away though from this exploration is that it will be helpful to have an example or template with a good developer experience suited for the native toolchain. The current example is really helpful, I'dlike to add something like a build script maybe. </p>\n<p>Anyone who would like to build binaries for multiple archs and OS should be able to use things like GH actions or docker buildx as other alternatives.</p>",
        "id": 435868401,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1714304467
    }
]