[
    {
        "content": "<p>hello everyone! If you did any amount of Advent of Code in Roc this year, I'd love to hear your feedback about the experience!</p>\n<p>in the past for things like this we've done a video chat - if that sounds good to you, here's a link for coordinating on when we can all make it: <a href=\"https://www.when2meet.com/?18034195-ZJlyp\">https://www.when2meet.com/?18034195-ZJlyp</a> - alternatively, if you'd rather share feedback in written form, feel free to either post it here or DM it to me...whatever you prefer, I'd love to hear about how the experience went - whatever comes to mind!</p>",
        "id": 316566314,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1671359708
    },
    {
        "content": "<p><strong>Advent of Code 2022 Feedback and Observations</strong></p>\n<p>I had a lot of fun working through the AoC puzzles; and some friendly competition with my mates who insist on using legacy technologies. <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n<p>My first introduction to this kind of challenge was for Roctoberfest. My experience has been similar, though I managed to get much further this time around. I have enjoyed writing Roc apps, learning more about the language and finding new ways to solve problems. The best part has been comparing my solutions with other people, which really highlighted different approaches to the same problem.</p>\n<p>I experienced some issues using Roc which was what I expected; however I tried to focus on contributing bug reports or ideas where I could. My progress through the challenges has slowed recently. I think the main reasons for this is; the puzzles are getting harder, I’m getting distracted with other things, coming across bugs which are hard to workaround, and Roc doesn’t have a mature ecosystem of libraries for common algorithms, data structures, visualisations etc.</p>\n<p>Parsers are fun, not-that-hard, and very worthwhile to learn. I’ve never really had much need to write a parser, the occasional regex has always been more than sufficient. I thought parsers were difficult and time consuming to write and test. However, during this AoC I started writing parsers in an attempt to learn more. I’m still a beginner; and can see there is much more to learn, but from my experience I would highly recommend using parsers to anyone, especially beginners.</p>\n<p>URL packages are great to work with. I’ve had no issues and found they really helped to reduce the friction to write an app. I could just copy-paste code into a file, type <code>roc run</code> and it ‘just worked’! As someone who doesn’t live in a cli, I found this a significant improvement over googling how to write a symlink each time, or writing my apps in a roc subdirectory.</p>\n<p>I had some trouble learning how to do Task management and error handling. Roc felt strict sometimes; wouldn’t run my app, I couldn’t isolate the issue and the errors were confusing. I didn't find many examples of how to do Tasks or handle errors properly. However; I think my experience has now been overtaken by events, and I don’t think it is likely to be repeated in future. There have been changes to the API and at least one bug here that I experienced. I think a relevant lesson here is that it will be important for an introduction to Roc programming and using Tasks to include working examples and show error handling. Note that at the start of AoC there weren’t many (any?) examples of Tasks in the wild; this is no longer the case. The pattern of sequencing Tasks with backpassing syntax is really nice, just new and different enough from patterns in other languages.</p>\n<p>Minimising errors and reporting crashes was easy to do and really helped the team find and fix compiler issues. I experienced plenty of crashes and panics; usually due to my lack of understanding or a crazy misapplication of syntax. I was encouraged by the team who have consistently asked me to raise issues when I find them. I found the process to minimise these examples to be straightforward and also helped me to understand my code better in the process. All I needed to do was copy-paste the app into a new file and then just repeatedly delete things and run the code until I got to a minimal example. Simple enough, but something I haven’t needed to do before.</p>\n<p>Thank you to the Roc contributors for your work building a great language. It’s awesome to see all the progress; and I feel lucky to be part of the development at this time.</p>",
        "id": 316685033,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1671436958
    },
    {
        "content": "<p>thank you for the feedback and the kind words, Luke! <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 316719109,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1671449545
    },
    {
        "content": "<p>besides fixing the <code>Task</code>-related bug, this tells me I should make sure to prioritize explaining <code>Task</code> error handling in the tutorial <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 316719203,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1671449594
    },
    {
        "content": "<p>On error handling it is so cool that error tags combine and \"just work\".</p>\n<p>Elm (does not compile)</p>\n<div class=\"codehilite\" data-code-language=\"Elm\"><pre><span></span><code><span class=\"kr\">type</span><span class=\"w\"> </span><span class=\"kt\">ThingErr</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"kt\">Wat</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nf\">|</span><span class=\"w\"> </span><span class=\"kt\">Hmm</span><span class=\"w\"></span>\n\n\n<span class=\"nv\">thing</span><span class=\"w\"> </span><span class=\"nf\">:</span><span class=\"w\"> </span><span class=\"kt\">Result</span><span class=\"w\"> </span><span class=\"kt\">ThingErr</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"nv\">thing</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kt\">Err</span><span class=\"w\"> </span><span class=\"kt\">Wat</span><span class=\"w\"></span>\n\n\n<span class=\"kr\">type</span><span class=\"w\"> </span><span class=\"kt\">Thing2Err</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"kt\">Other</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nf\">|</span><span class=\"w\"> </span><span class=\"kt\">Stuff</span><span class=\"w\"></span>\n\n\n<span class=\"nv\">thing2</span><span class=\"w\"> </span><span class=\"nf\">:</span><span class=\"w\"> </span><span class=\"kt\">Result</span><span class=\"w\"> </span><span class=\"kt\">Thing2Err</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"nv\">thing2</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kt\">Ok</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n\n<span class=\"nv\">dooStuff</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nv\">thing</span><span class=\"w\"> </span><span class=\"nf\">|&gt;</span><span class=\"w\"> </span><span class=\"kt\">Result</span><span class=\"nf\">.</span><span class=\"nv\">andThen</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nf\">\\</span><span class=\"nv\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nv\">thing2</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Roc (Does compile!)</p>\n<div class=\"codehilite\" data-code-language=\"Elixir\"><pre><span></span><code><span class=\"nc\">ThingErr</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nc\">Hmm</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nc\">Wat</span><span class=\"p\">]</span><span class=\"w\"></span>\n\n<span class=\"n\">thing</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Result</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"nc\">ThingErr</span><span class=\"w\"></span>\n<span class=\"n\">thing</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">Err</span><span class=\"w\"> </span><span class=\"nc\">Wat</span><span class=\"w\"></span>\n\n<span class=\"nc\">Thing2Err</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nc\">Other</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nc\">Stuff</span><span class=\"p\">]</span><span class=\"w\"></span>\n\n<span class=\"n\">thing2</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Result</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"nc\">Thing2Err</span><span class=\"w\"></span>\n<span class=\"n\">thing2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">Ok</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"n\">dooStuff</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Result</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nc\">Hmm</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nc\">Other</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nc\">Stuff</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nc\">Wat</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"n\">dooStuff</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">thing</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"nc\">Result</span><span class=\"o\">.</span><span class=\"k\">try</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"bp\">_</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">thing2</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 316846809,
        "sender_full_name": "Erik",
        "timestamp": 1671490460
    },
    {
        "content": "<p>yeah, this was the original motivation for having tag unions in the language! <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 316850077,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1671492111
    },
    {
        "content": "<p>Here's a few notes about my experience:</p>\n<ul>\n<li>The typechecker, error messages and the language/type system design now feels solid</li>\n<li>Codegen crashes were a showstopper and made me gave up after day 13. I might do the rest later but I'm taking a break for now.</li>\n<li><code>dbg</code> showing incorrect results is worse than not having <code>dbg</code> at all</li>\n<li>never got <code>expect</code>s inside functions to work</li>\n<li>formatter consistently doesn't work for <code>if .. then .. else ...</code></li>\n<li><code>crash</code> has been a huge productivity boost. Not sure if this is good for the language in the long term</li>\n<li>the stdlib could be improved. I had to write my own sort function. Glad that <code>List.range</code> is now fixed. Had to write generally-expected functions in FP languages like scan, windows and chunk myself. See <a href=\"https://hexdocs.pm/elixir/Enum.html#summary\">Elixir's Enum module</a> for inspiration</li>\n<li>generally enjoyed the experience and will be using Roc for other things (RayTracer WIP, other use cases at $WORK)</li>\n</ul>",
        "id": 317002983,
        "sender_full_name": "Shritesh Bhattarai",
        "timestamp": 1671558031
    },
    {
        "content": "<p>Thanks for the feedback <span class=\"user-mention\" data-user-id=\"452038\">@Shritesh Bhattarai</span>!</p>",
        "id": 317010856,
        "sender_full_name": "Anton",
        "timestamp": 1671560462
    },
    {
        "content": "<p>There were a number of string manipulation functions that I missed not having, such as:</p>\n<ol>\n<li>Being able to trim a prefix/suffix or a set of graphemes from the start or end string: right now, only spacing can be trimmed. Technically replaceFirst and replaceLast can be used for this in conjunction with startsWith and endsWith, though it's not as convenient.</li>\n<li>A splitLines function that does the right thing with an input that ends with a newline character(s) (\"line terminator\" interpretation) or does not (\"line separator\" interpretation).</li>\n<li>Checked vs non-checked versions of any string manipulation function that returns a Result. I may want to replace matching substrings but don't necessarily care whether the substring was present.</li>\n</ol>\n<p>Additionally, I found a couple places when doing string manipulation where it would've been nice to be able to re-declare an identifier within the same scope (the same way that Rust permits), i.e. by shadowing the previous declaration. An example would be splitting a string into words, then incrementally consuming each of those words: with redeclaration, I could have a <code>words</code> identifier that I peel words off the front of, and have a successively smaller list of remaining words; without such an ability, I need to use different variable names (naming is hard), or I need to carefully count indices.</p>",
        "id": 317466363,
        "sender_full_name": "Kevin Gillette",
        "timestamp": 1671750201
    },
    {
        "content": "<p>+1 to shadowing - even though I love a language like Elm, I've been using Elixir a lot and shadowing never caused me any bugs there. However, not shadowing did cause bugs for me on Elm since I need to maintain multiple versions of the same thing on the same scope with the same type, but if I reference an old one by mistake the compiler is not helpful (since they're the same type). maybe a restricted shadowing where only things with the same type could be generated would be ideal?</p>",
        "id": 317470595,
        "sender_full_name": "Georges Boris",
        "timestamp": 1671752766
    },
    {
        "content": "<p>I tend to try and rewriting things that require shadowing with pipelining, but shadowing would be more flexible.</p>",
        "id": 317477293,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1671757154
    },
    {
        "content": "<p>Definitely think it would be a nice addition based on my current experience.</p>",
        "id": 317477317,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1671757178
    },
    {
        "content": "<p>Though i think maybe shadowing should be limited to scopes somehow. So can't shadow top level declarations or functions which might get called recursively....not sure the best rule here. Maybe the type idea above would work</p>",
        "id": 317477418,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1671757234
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"483789\">@Kevin Gillette</span> want to open a new topic in <a class=\"stream\" data-stream-id=\"304641\" href=\"/#narrow/stream/304641-ideas\">#ideas</a> about shadowing so we can discuss more there?</p>",
        "id": 317488727,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1671766648
    },
    {
        "content": "<p>Hmm....this said, a common use case in rust for shadowing is explicitly changing types. So path as a string and then path as a PathBuf. And other things of that nature.</p>",
        "id": 317488823,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1671766736
    },
    {
        "content": "<p>I like the language and I had fun :)</p>\n<p>I should've kept a list of stuff that came up as I went along, but here's what I can recall:</p>\n<ul>\n<li>List pattern matching not having a way to match on the rest of the elements came up pretty often, although on the other hand being able to pattern match on the last one(s) was great</li>\n<li>I think I like the formatter avoiding increasing indentation for pipes and being concise-ish in general</li>\n<li>Tags seem great</li>\n<li>I missed being able to add section comments since the formatter would move the comments right above functions</li>\n<li>At some point backpassing failed with some error in some nested place, so I had to rewrite it to a pipeline (but sadly I didn't record it anywhere, so maybe I just didn't understand the error message), but that made me avoid using it too much later</li>\n<li>Another reason I avoided backpassing was that it was nicer having a default in the same function at times, but I later realized I could've done something like this: <code>_ &lt;- \\f -&gt; Result.withDefault (f {}) []</code></li>\n<li><code>dbg</code> was both great when it worked and annoying when it didn't :D</li>\n<li><code>expect</code> was lovely to write tests with, usually writing tests has a lot of friction (gotta name stuff and create files and whatnot)</li>\n<li>Coming from Elm, using <code>crash</code> felt wrong every time, but it kept working out for AOC stuff, so I kept using it :D</li>\n</ul>",
        "id": 317624020,
        "sender_full_name": "Marten",
        "timestamp": 1671821097
    },
    {
        "content": "<p>I've had a good number of times in which i used successive backpassing with <a href=\"http://Result.map\">Result.map</a> and saw type mismatches from nested results, and it took me a while to get comfortable enough with the Roc mindset to realize i needed Result.try in such cases.</p>\n<p>This is an area where documentation could be more helpful to beginners if it includes some wording along the lines of \"you want this function if...\"</p>",
        "id": 317897465,
        "sender_full_name": "Kevin Gillette",
        "timestamp": 1672020861
    }
]