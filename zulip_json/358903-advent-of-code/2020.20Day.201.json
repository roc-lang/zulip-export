[
    {
        "content": "<p>I have gone through another AoC puzzle to see if there were things I would do differently now I have learnt a bit more about Roc. I'm pretty happy with the end result. Note my focus was on how to use Roc and not really algorithm performance.</p>\n<p>This is the code <a href=\"https://github.com/lukewilliamboswell/roc-things/blob/main/aoc-2020/01.roc\">AoC 2020 Problem 1</a> I am referring to below.</p>\n<p>There are two main things that I think worth sharing from my exploration. </p>\n<h2>Parsing Numbers using Decode Ability</h2>\n<p>From my experience working on the Json decoder I think this is a handy way to parse the file input bytes. Basically, just recursively parse a number from the list of bytes and build up a list. This can be extended to support other <code>Decode.custom</code> decoders too. An alternative method to using a <code>Parser</code> and combinators. </p>\n<p>Also I think it should be reasonably efficient now with seamless slices.</p>\n<div class=\"codehilite\"><pre><span></span><code># Should probably have used `numbers: List.withCapacity []` here\n{ numbers, rest } = parseNumbers { numbers: [], rest: input }\n\nparseNumbers = \\{ numbers, rest } -&gt;\n    if List.isEmpty rest then\n        { numbers, rest }\n    else\n        decodeResult : Decode.DecodeResult U64\n        decodeResult = Decode.fromBytesPartial rest Json.fromUtf8\n\n        when decodeResult.result is\n            Ok n -&gt; parseNumbers { numbers: List.append numbers n, rest: decodeResult.rest }\n            Err _ -&gt; parseNumbers { numbers, rest: List.dropFirst rest }\n</code></pre></div>\n<h2>Task API and Error Handling</h2>\n<p>I wanted to revisit the Task API and figure out a nicer way to handle errors, rather than just <em>crashing</em> <code>onFail</code> which was what I had defaulted to.</p>\n<p>I found that using a tag union to group task errors at the level you care about is really nice. You can provide good descriptions for what the error is so you can handle it effectively.</p>\n<p>If you separate the tasks into distinct functions it is easier to add type annotions for the detail you care about. You can ignore lower level errors, or include additional information such as the \"path\" for an invalid file etc.</p>\n<div class=\"codehilite\"><pre><span></span><code>TaskErrors : [InvalidArg, InvalidFile Str]\n\nreadPath : Task.Task Str TaskErrors\n\nreadFile : Str -&gt; Task.Task (List U8) TaskErrors\n</code></pre></div>\n<p>This simplifies the flow of tasks and makes it easy to use backpassing syntax when using the tasks and handling errors.</p>\n<div class=\"codehilite\"><pre><span></span><code>main =\n    task =\n        path &lt;- readPath |&gt; Task.await\n        fileBytes &lt;- readFile path |&gt; Task.await\n\n        [\n            part1 &quot;Part 1 Sample&quot; sampleBytes,\n            part1 &quot;Part 1 File&quot; fileBytes,\n            part2 &quot;Part 2 Sample&quot; sampleBytes,\n            part2 &quot;Part 2 File&quot; fileBytes,\n        ]\n        |&gt; List.keepOks \\x -&gt; x\n        |&gt; Str.joinWith &quot;\\n&quot;\n        |&gt; Task.succeed\n\n    taskResult &lt;- Task.attempt task\n\n    when taskResult is\n        Ok answers -&gt; Stdout.line answers\n        Err InvalidArg -&gt; Stderr.line &quot;Error: expected arg file.roc -- path/to/input.txt&quot;\n        Err (InvalidFile path) -&gt; Stderr.line &quot;Error: couldn&#39;t read input file at \\&quot;\\(path)\\&quot;&quot;\n</code></pre></div>",
        "id": 347597772,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1680855474
    },
    {
        "content": "<p>Very nice!</p>",
        "id": 347627113,
        "sender_full_name": "Brian Carroll",
        "timestamp": 1680863598
    },
    {
        "content": "<p>You mentioned <code>List.withCapacity</code>. Its argument is actually a number - how many elements you want to reserve initial capacity for.</p>\n<p>Here I think you'd guess the initial capacity based on the length of the input string divided by... some made-up constant. Maybe 4? It's not worth being accurate by counting the commas because then you're not saving time!</p>\n<p>If that guess is too small, it might have to resize the list, but hopefully fewer resizes than if you hadn't given a guess. If the guess is too big, you waste some memory. Either way, the code still works.</p>\n<p>If you don't do any of this, the default behaviour is pretty good anyway.</p>",
        "id": 347632113,
        "sender_full_name": "Brian Carroll",
        "timestamp": 1680864851
    }
]