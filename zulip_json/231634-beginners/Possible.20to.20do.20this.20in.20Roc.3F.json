[
    {
        "content": "<p>Hello, I was wondering if it would be possible to do something like this in Roc (C# code):</p>\n<div class=\"codehilite\"><pre><span></span><code>class ComponentRegistry\n    {\n        Dictionary&lt;Type, Object&gt; components = new Dictionary&lt;Type, object&gt;();\n\n        public void AddComponent&lt;T&gt;(T component)\n        {\n            components[typeof(T)] = component;\n        }\n\n        public bool GetComponentOfType&lt;T&gt;(out T result)\n        {\n            if (components.ContainsKey(typeof(T)))\n            {\n                result = (T)components[typeof(T)];\n                return true;\n            }\n\n            result = default(T);\n            return false;\n        }\n    }\n</code></pre></div>\n<p>Basically, have a generic store of components that would let you retrieve a component by its type? In case context helps I'm brainstorming how <a href=\"https://en.wikipedia.org/wiki/Entity_component_system\">ECS</a> could be done in Roc</p>",
        "id": 276388173,
        "sender_full_name": "Jared Cone",
        "timestamp": 1648063952
    },
    {
        "content": "<p>I believe tags are the recommended mechanism for \"runtime typing\"</p>",
        "id": 276389046,
        "sender_full_name": "jan kili",
        "timestamp": 1648064438
    },
    {
        "content": "<p>But tags require the ComponentRegistry to know about every possible thing that can be put into it?</p>",
        "id": 276399009,
        "sender_full_name": "Jared Cone",
        "timestamp": 1648068939
    },
    {
        "content": "<p>we don't have this kind of reflection. You can see here how a type is turned into a value <code>typeof(T)</code>. That's not something we can do</p>",
        "id": 276399308,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1648069077
    },
    {
        "content": "<p>types and values live in distinct universes in roc</p>",
        "id": 276399382,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1648069094
    },
    {
        "content": "<p>interestingly, to get this sort of feature you can be both more strongly and more weakly typed</p>",
        "id": 276399421,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1648069117
    },
    {
        "content": "<p>e.g. haskell can actually achieve the same result (if you enable a bunch of language extensions)</p>",
        "id": 276399474,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1648069142
    },
    {
        "content": "<p>If you don't want the component registry to know every \"type\" it can use as a dict key, then it sounds like you'll want to use strings as keys. Perhaps a component is a record with a <code>.type</code> string field.</p>",
        "id": 276401129,
        "sender_full_name": "jan kili",
        "timestamp": 1648069884
    },
    {
        "content": "<p>That wouldn't work in roc. What would the actual component be? <code>{ type: Str, component: ??? }</code></p>\n<p>So it would have to be an explicit tag I think.</p>\n<p>If you used a type variable for the component, all components would need the same type.</p>",
        "id": 276401996,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648070307
    },
    {
        "content": "<p>As a side note, I think that the tagged version would be cheaper at runtime then the type reflection version.</p>",
        "id": 276402044,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648070340
    },
    {
        "content": "<p>But yeah, not flexible due to no reflection.</p>",
        "id": 276402106,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648070378
    },
    {
        "content": "<p>I don't know ECS very well, so this is just an idea:</p>\n<div class=\"codehilite\"><pre><span></span><code>MyECS.Component : { type: Str }*\nMyECS.ComponentRegistry : SomeDictLibrary.Dict\nMyECS.addComponent : MyECS.ComponentRegistry, MyECS.Component -&gt; MyECS.ComponentRegistry\n\nregistry : MyECS.ComponentRegistry\nregistry = MyECS.initializeComponentRegistry\nregistry = MyECS.addComponent registry { type: &quot;friend&quot;, name: &quot;Friendo&quot; }\n</code></pre></div>",
        "id": 276403092,
        "sender_full_name": "jan kili",
        "timestamp": 1648070891
    },
    {
        "content": "<p>Hmmm...I'm actually really interested, does that work in roc? At a minimum, it would break if two component have a field with the same name but different types, but otherwise it may work.</p>",
        "id": 276403641,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648071181
    },
    {
        "content": "<p><code>MyECS.Component : { type: Str }*</code> does not work. That <code>*</code> type variable needs to occur on the left-hand side</p>",
        "id": 276403862,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1648071297
    },
    {
        "content": "<p>Oh, whoops, lemme edit</p>",
        "id": 276403929,
        "sender_full_name": "jan kili",
        "timestamp": 1648071341
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>MyECS.Component a : { type: Str }a\nMyECS.ComponentRegistry : SomeDictLibrary.Dict\nMyECS.addComponent : MyECS.ComponentRegistry, MyECS.Component -&gt; MyECS.ComponentRegistry\n\nregistry : MyECS.ComponentRegistry\nregistry = MyECS.initializeComponentRegistry\nFriend : { name: Str }\nfriendo : MyECS.Component Friend\nfriendo = { type: &quot;friend_idk_this_aspect_is_pain&quot;, name: &quot;Friendo&quot; }\nregistry = MyECS.addComponent registry\n</code></pre></div>",
        "id": 276404321,
        "sender_full_name": "jan kili",
        "timestamp": 1648071551
    },
    {
        "content": "<p>None of those type aliases are necessary, they're just to show what types things would have (and to skip writing full definitions)</p>",
        "id": 276404329,
        "sender_full_name": "jan kili",
        "timestamp": 1648071555
    },
    {
        "content": "<p>It turns out my understanding of ECS is just OOP with methods extracted into systems (not shown here) <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 276404389,
        "sender_full_name": "jan kili",
        "timestamp": 1648071592
    },
    {
        "content": "<p>I think the <code>.Dict</code> also needs some type parameters right? and I think that makes this fall apart</p>",
        "id": 276404582,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1648071708
    },
    {
        "content": "<p>what you want is some sort of way to \"forget\" about that type variable</p>",
        "id": 276404651,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1648071731
    },
    {
        "content": "<p>and we can't do that. There are ways in haskell with a <code>forall</code>, or in rust with the <code>Any</code> trait</p>",
        "id": 276404673,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1648071747
    },
    {
        "content": "<p>I imagine this particular ECS implementation approach isn't the most Roc-y regardless</p>",
        "id": 276404680,
        "sender_full_name": "jan kili",
        "timestamp": 1648071750
    },
    {
        "content": "<p>or <code>dyn Trait</code> in general</p>",
        "id": 276404687,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1648071753
    },
    {
        "content": "<p>String encoding? <span aria-label=\"nauseated\" class=\"emoji emoji-1f922\" role=\"img\" title=\"nauseated\">:nauseated:</span></p>",
        "id": 276404929,
        "sender_full_name": "jan kili",
        "timestamp": 1648071898
    },
    {
        "content": "<p><code>void *</code></p>",
        "id": 276405136,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1648071992
    },
    {
        "content": "<p>solution to all our problems</p>",
        "id": 276405154,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1648072004
    },
    {
        "content": "<p>I don't understand and I'm terrified</p>",
        "id": 276405189,
        "sender_full_name": "jan kili",
        "timestamp": 1648072030
    },
    {
        "content": "<p>So what's the real solution here? It's a legitimate use case, so we should have a clean pattern ready.</p>",
        "id": 276405353,
        "sender_full_name": "jan kili",
        "timestamp": 1648072128
    },
    {
        "content": "<p>A tag and explicitly naming the possible types is definitely the cleanest in current roc. The library would just expose it as a type variable and the user would fill in the tag</p>",
        "id": 276405518,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648072221
    },
    {
        "content": "<p>Ooh</p>",
        "id": 276405564,
        "sender_full_name": "jan kili",
        "timestamp": 1648072258
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>ComponentRegistry a : List a\n\n# not sure if the original deduplicates based on the type?\naddComponent = List.push\n\nfindComponent : ComponentRegistry a, (a -&gt; Bool) -&gt; [ Found a, NotFound ]\n</code></pre></div>",
        "id": 276405730,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1648072352
    },
    {
        "content": "<p>(wow, Roc's type variables and type inference are a powerful combo for terse yet readable code, IMO)</p>",
        "id": 276405892,
        "sender_full_name": "jan kili",
        "timestamp": 1648072461
    },
    {
        "content": "<p>So does this or something like it work in general?</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">dict : </span><span class=\"nx\">Dict</span> <span class=\"nx\">Str</span> <span class=\"p\">{</span> <span class=\"p\">}</span><span class=\"nx\">a</span>\n<span class=\"nv\">dict = </span><span class=\"nx\">Dict</span><span class=\"p\">.</span><span class=\"nx\">Empty</span>\n    <span class=\"o\">|&gt;</span> <span class=\"nx\">Dict</span><span class=\"p\">.</span><span class=\"nx\">insert</span> <span class=\"s\">\"Friend\"</span> <span class=\"p\">{</span> <span class=\"nv\">hp: </span><span class=\"mi\">12</span><span class=\"p\">,</span> <span class=\"nv\">name: </span><span class=\"s\">\"Foo\"</span> <span class=\"p\">}</span>\n    <span class=\"o\">|&gt;</span> <span class=\"nx\">Dict</span><span class=\"p\">.</span><span class=\"nx\">insert</span> <span class=\"s\">\"Enemy\"</span> <span class=\"p\">{</span> <span class=\"nv\">hp: </span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"nv\">atk: </span><span class=\"mi\">7</span> <span class=\"p\">}</span>\n</code></pre></div>",
        "id": 276405939,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648072498
    },
    {
        "content": "<p><code>dict a : ...</code>?</p>",
        "id": 276405978,
        "sender_full_name": "jan kili",
        "timestamp": 1648072529
    },
    {
        "content": "<p>no collections are homogeneous</p>",
        "id": 276406088,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1648072599
    },
    {
        "content": "<p>Ok. That is what I thought.</p>",
        "id": 276406246,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648072693
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"481285\">@Jared Cone</span> with the original code, wouldn't that limit to exactly one component of each type? Is that normal for ECS. This just doesn't quite match my understanding of it.</p>",
        "id": 276406698,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648072884
    },
    {
        "content": "<p>Yeah I think this use case needs variable component types/bodies</p>",
        "id": 276410176,
        "sender_full_name": "jan kili",
        "timestamp": 1648074555
    },
    {
        "content": "<p>I think the <code>a</code> in Folkert's example would be a tag union with \"component types\" as tags and \"component data\" as tag payloads</p>",
        "id": 276410359,
        "sender_full_name": "jan kili",
        "timestamp": 1648074657
    },
    {
        "content": "<blockquote>\n<p>with the original code, wouldn't that limit to exactly one component of each type? Is that normal for ECS. This just doesn't quite match my understanding of it.</p>\n</blockquote>\n<p>Yes, I was just wanting to keep the example simple. The core issue is the same regardless if it's exactly one component or more than one component of each type.</p>",
        "id": 276410884,
        "sender_full_name": "Jared Cone",
        "timestamp": 1648074972
    },
    {
        "content": "<p>So a basic design in Roc might be something like:</p>\n<div class=\"codehilite\"><pre><span></span><code>EntityId : U32\n\nGame : {\n    deltaSeconds : F32,\n    velocityComponents : Dict EntityId Vector3,\n    gravityComponents : Dict EntityId Vector3,\n    ...\n}\n\nGravitySystem : Game -&gt; Game\nGravitySystem = \\game -&gt;\n    velocityComponents = ... apply gravity to each entity that has velocity and gravity components ...\n    { game &amp; velocityComponents }\n</code></pre></div>\n<p>Issues:</p>\n<ul>\n<li>Components have to live in top-level modules, then Game lives in a middle module, then Systems live in lower modules</li>\n<li>Any new component types have to be added to Game. Also means plugins can't be supported.</li>\n<li>Is this performant if Game has hundreds of component types?</li>\n</ul>",
        "id": 276412027,
        "sender_full_name": "Jared Cone",
        "timestamp": 1648075601
    },
    {
        "content": "<p>I thought one of the goals of ECS pattern is to eliminate bloated \"God\"/\"Game\" objects, so maybe mimicking the implementation from another language is breaking the spirit of the pattern?</p>",
        "id": 276412342,
        "sender_full_name": "jan kili",
        "timestamp": 1648075795
    },
    {
        "content": "<p>The idea is a System can say \"Give me the entities that have X and Y components so I can do some work with them\". As far as I can tell in Roc currently the only way to do that is with a \"God\" object.</p>",
        "id": 276412613,
        "sender_full_name": "Jared Cone",
        "timestamp": 1648075972
    },
    {
        "content": "<p>So I think this would be a functional example that would theoretically perform similar to a regular ECS:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">Type : </span><span class=\"p\">[</span>\n        <span class=\"nx\">Animal</span><span class=\"p\">,</span>\n        <span class=\"nx\">Plant</span><span class=\"p\">,</span>\n        <span class=\"nx\">Player</span><span class=\"p\">,</span>\n        <span class=\"nx\">Chest</span><span class=\"p\">,</span>\n    <span class=\"p\">]</span>\n\n<span class=\"nx\">Entity</span> <span class=\"o\">:=</span> <span class=\"p\">{</span> <span class=\"nv\">id: </span><span class=\"nx\">U64</span><span class=\"p\">,</span> <span class=\"nv\">type: </span><span class=\"nx\">Type</span> <span class=\"p\">}</span>\n\n<span class=\"nv\">ComponentProperties : </span><span class=\"p\">{</span>\n        <span class=\"nv\">hasPosition: </span><span class=\"nx\">Bool</span><span class=\"p\">,</span>\n        <span class=\"nv\">hasVelocity: </span><span class=\"nx\">Bool</span><span class=\"p\">,</span>\n        <span class=\"nv\">hasHealth: </span><span class=\"nx\">Bool</span><span class=\"p\">,</span>\n        <span class=\"nv\">hasInventory: </span><span class=\"nx\">Bool</span><span class=\"p\">,</span>\n    <span class=\"p\">}</span>\n\n<span class=\"nv\">supportedComponents : </span><span class=\"nx\">Type</span> <span class=\"nf\">-&gt;</span> <span class=\"nx\">ComponentProperties</span>\n<span class=\"nv\">supportedComponents = </span><span class=\"err\">\\</span><span class=\"nx\">type</span> <span class=\"nf\">-&gt;</span>\n    <span class=\"k\">when</span> <span class=\"nx\">type</span> <span class=\"o\">is</span>\n        <span class=\"nx\">Animal</span> <span class=\"nf\">-&gt;</span>\n            <span class=\"p\">{</span> <span class=\"nv\">hasPosition: </span><span class=\"nx\">True</span><span class=\"p\">,</span> <span class=\"nv\">hasVelocity: </span><span class=\"nx\">True</span><span class=\"p\">,</span> <span class=\"nv\">hasHealth: </span><span class=\"nx\">True</span><span class=\"p\">,</span> <span class=\"nv\">hasInventory: </span><span class=\"nx\">False</span> <span class=\"p\">}</span>\n        <span class=\"nx\">Plant</span> <span class=\"nf\">-&gt;</span>\n            <span class=\"p\">{</span> <span class=\"nv\">hasPosition: </span><span class=\"nx\">True</span><span class=\"p\">,</span> <span class=\"nv\">hasVelocity: </span><span class=\"nx\">False</span><span class=\"p\">,</span> <span class=\"nv\">hasHealth: </span><span class=\"nx\">True</span><span class=\"p\">,</span> <span class=\"nv\">hasInventory: </span><span class=\"nx\">False</span> <span class=\"p\">}</span>\n        <span class=\"nx\">Chest</span> <span class=\"nf\">-&gt;</span>\n            <span class=\"p\">{</span> <span class=\"nv\">hasPosition: </span><span class=\"nx\">True</span><span class=\"p\">,</span> <span class=\"nv\">hasVelocity: </span><span class=\"nx\">False</span><span class=\"p\">,</span> <span class=\"nv\">hasHealth: </span><span class=\"nx\">False</span><span class=\"p\">,</span> <span class=\"nv\">hasInventory: </span><span class=\"nx\">True</span> <span class=\"p\">}</span>\n        <span class=\"nx\">Player</span> <span class=\"nf\">-&gt;</span>\n            <span class=\"p\">{</span> <span class=\"nv\">hasPosition: </span><span class=\"nx\">True</span><span class=\"p\">,</span> <span class=\"nv\">hasVelocity: </span><span class=\"nx\">True</span><span class=\"p\">,</span> <span class=\"nv\">hasHealth: </span><span class=\"nx\">True</span><span class=\"p\">,</span> <span class=\"nv\">hasInventory: </span><span class=\"nx\">True</span> <span class=\"p\">}</span>\n\n<span class=\"nv\">Item : </span><span class=\"p\">[</span> <span class=\"nx\">SomeTag</span> <span class=\"p\">]</span>\n\n<span class=\"nv\">Components : </span><span class=\"p\">{</span>\n        <span class=\"c1\"># These could also be lists with empty data for entities without this data.</span>\n        <span class=\"nv\">position: </span><span class=\"nx\">Dict</span> <span class=\"nx\">U64</span> <span class=\"p\">{</span> <span class=\"nv\">x: </span><span class=\"nx\">F64</span><span class=\"p\">,</span> <span class=\"nv\">y: </span><span class=\"nx\">F64</span><span class=\"p\">,</span> <span class=\"nv\">z: </span><span class=\"nx\">F64</span> <span class=\"p\">},</span>\n        <span class=\"nv\">velocity: </span><span class=\"nx\">Dict</span> <span class=\"nx\">U64</span> <span class=\"p\">{</span> <span class=\"nv\">dx: </span><span class=\"nx\">F64</span><span class=\"p\">,</span> <span class=\"nv\">dy: </span><span class=\"nx\">F64</span><span class=\"p\">,</span> <span class=\"nv\">dz: </span><span class=\"nx\">F64</span> <span class=\"p\">},</span>\n        <span class=\"nv\">health: </span><span class=\"nx\">Dict</span> <span class=\"nx\">U64</span> <span class=\"nx\">U64</span>\n        <span class=\"nv\">inventory: </span><span class=\"nx\">Dict</span> <span class=\"nx\">U64</span> <span class=\"p\">(</span><span class=\"nx\">List</span> <span class=\"nx\">Item</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n\n<span class=\"nv\">moveSystem : </span><span class=\"nx\">List</span> <span class=\"nx\">Entity</span><span class=\"p\">,</span> <span class=\"nx\">Components</span> <span class=\"nf\">-&gt;</span> <span class=\"p\">[</span> <span class=\"nx\">T</span> <span class=\"p\">(</span><span class=\"nx\">List</span> <span class=\"nx\">Entity</span><span class=\"p\">)</span> <span class=\"nx\">Components</span> <span class=\"p\">]</span>\n<span class=\"nv\">moveSystem = </span><span class=\"err\">\\</span><span class=\"nx\">entities</span><span class=\"p\">,</span> <span class=\"nx\">components</span> <span class=\"nf\">-&gt;</span>\n    <span class=\"nx\">List</span><span class=\"p\">.</span><span class=\"nx\">walk</span> <span class=\"nx\">entities</span> <span class=\"p\">(</span><span class=\"nx\">T</span> <span class=\"nx\">entities</span> <span class=\"nx\">components</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"err\">\\</span><span class=\"nx\">T</span> <span class=\"nx\">currentEntities</span> <span class=\"nx\">currentComponents</span><span class=\"p\">,</span> <span class=\"nx\">entity</span> <span class=\"nf\">-&gt;</span>\n        <span class=\"nv\">supported = </span><span class=\"nx\">supportedComponents</span> <span class=\"nx\">entity</span><span class=\"p\">.</span><span class=\"nx\">type</span>\n        <span class=\"k\">if</span> <span class=\"nx\">supported</span><span class=\"p\">.</span><span class=\"nx\">hasPosition</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">supported</span><span class=\"p\">.</span><span class=\"nx\">hasVelocity</span> <span class=\"k\">then</span>\n            <span class=\"p\">{</span><span class=\"nx\">x</span><span class=\"p\">,</span> <span class=\"nx\">y</span><span class=\"p\">,</span> <span class=\"nx\">z</span><span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"nx\">Dict</span><span class=\"p\">.</span><span class=\"nx\">get</span> <span class=\"nx\">currentComponents</span><span class=\"p\">.</span><span class=\"nx\">position</span> <span class=\"nx\">entity</span><span class=\"p\">.</span><span class=\"nx\">id</span>\n            <span class=\"p\">{</span><span class=\"nx\">dx</span><span class=\"p\">,</span> <span class=\"nx\">dy</span><span class=\"p\">,</span> <span class=\"nx\">dz</span><span class=\"p\">}</span> <span class=\"o\">=</span> <span class=\"nx\">Dict</span><span class=\"p\">.</span><span class=\"nx\">get</span> <span class=\"nx\">currentComponents</span><span class=\"p\">.</span><span class=\"nx\">velocity</span> <span class=\"nx\">entity</span><span class=\"p\">.</span><span class=\"nx\">id</span>\n            <span class=\"nv\">nextPosition = </span><span class=\"p\">{</span> <span class=\"nv\">x: </span><span class=\"nx\">x</span> <span class=\"o\">+</span> <span class=\"nx\">dx</span><span class=\"p\">,</span> <span class=\"nv\">y: </span><span class=\"nx\">y</span> <span class=\"o\">+</span> <span class=\"nx\">dy</span><span class=\"p\">,</span> <span class=\"nv\">z: </span><span class=\"nx\">z</span> <span class=\"o\">+</span> <span class=\"nx\">dz</span> <span class=\"p\">}</span>\n            <span class=\"nv\">nextComponents = </span><span class=\"p\">{</span><span class=\"nx\">currentComponents</span> <span class=\"o\">&amp;</span> <span class=\"nv\">position: </span><span class=\"nx\">Dict</span><span class=\"p\">.</span><span class=\"nx\">insert</span> <span class=\"nx\">currentComponents</span><span class=\"p\">.</span><span class=\"nx\">position</span> <span class=\"nx\">entity</span><span class=\"p\">.</span><span class=\"nx\">id</span> <span class=\"nx\">nextPosition</span><span class=\"p\">}</span>\n            <span class=\"nx\">T</span> <span class=\"nx\">currentEntities</span> <span class=\"nx\">nextComponents</span>\n        <span class=\"k\">else</span>\n            <span class=\"nx\">T</span> <span class=\"nx\">currentEntities</span> <span class=\"nx\">currentComponents</span>\n    <span class=\"p\">)</span>\n</code></pre></div>",
        "id": 276413025,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648076264
    },
    {
        "content": "<p>Of course it is custom and would be much harder to make generic in roc. Would have a bunch of open ended type variables that need to be filled in.</p>",
        "id": 276413384,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648076446
    },
    {
        "content": "<p>As a side note, this might be made more reasonable with abilities. Could have an ability to get an entities position. That ability would be on all entities and would just look up the entity in the position dictionary. If the entity does not support position, it would return None.</p>",
        "id": 276413698,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648076611
    },
    {
        "content": "<p>But that would also be one ability per component, so it would be quite odd.</p>",
        "id": 276413798,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648076656
    },
    {
        "content": "<blockquote>\n<p>would be much harder to make generic in roc</p>\n</blockquote>\n<p>True but in Elm I've always found this to be a good thing. If you're making a game (as opposed to selling a game engine like Unity) then isn't it <em>better</em> it to be explicit rather than generic?</p>",
        "id": 276415848,
        "sender_full_name": "Brian Carroll",
        "timestamp": 1648077965
    },
    {
        "content": "<p>I say this with zero experience in game dev, it's just what I've found in other types of application.</p>",
        "id": 276415870,
        "sender_full_name": "Brian Carroll",
        "timestamp": 1648077998
    },
    {
        "content": "<p>I mean if you are new to game making and want to use someone's basic game platform with some ECS library, you would prefer not to have to learn and implementation everything explicitly cause it is all new to you.</p>",
        "id": 276416048,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648078166
    },
    {
        "content": "<p>The big issue is that I believe some ECS library basically wouldn't be functional without reflection or something more powerful in those lines. It would basically be an empty shell of type variables that take explicit knowledge to implement. Probably would be best just to make your own custom implementation or ECS rather than use the library.</p>",
        "id": 276416196,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648078286
    },
    {
        "content": "<p>There are two ECS packages in Elm (which has a very similar type system to Roc) if you're interested in seeing what the API and implementation of those look like. I don't know that much about ECS so I don't know if they are good implementations of it though.</p>\n<p><a href=\"https://package.elm-lang.org/packages/justgook/elm-game-logic/latest/\">https://package.elm-lang.org/packages/justgook/elm-game-logic/latest/</a> (source code: <a href=\"https://github.com/justgook/elm-game-logic/tree/3.0.0\">https://github.com/justgook/elm-game-logic/tree/3.0.0</a>)<br>\n<a href=\"https://package.elm-lang.org/packages/harmboschloo/elm-ecs/latest/\">https://package.elm-lang.org/packages/harmboschloo/elm-ecs/latest/</a> (source code: <a href=\"https://github.com/harmboschloo/elm-ecs/tree/2.0.0\">https://github.com/harmboschloo/elm-ecs/tree/2.0.0</a>)</p>",
        "id": 276416350,
        "sender_full_name": "Martin Stewart",
        "timestamp": 1648078409
    },
    {
        "content": "<p>So <code>elm-game-logic</code> just ignores the entity typing problem all together by using an array of <code>Maybe</code>. That might be an acceptable option, but it has a few problems:</p>\n<ul>\n<li><del>More bug prone: e.g. might forget a component on an entity that should have it due to not having entity types</del></li>\n<li>Higher memory cost: every element in every array has the overhead of <code>Maybe</code></li>\n<li>Lookup performance cost: Instead of knowing the type of the entity and then being done, I must look up the entity in each array to figure out if it has a component.</li>\n</ul>",
        "id": 276417947,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648079615
    },
    {
        "content": "<p><code>elm-ecs</code> is more complicated for me to wrap my head around. Will try to give an analysis once I get what it is actually doing under the hood.</p>",
        "id": 276418016,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648079650
    },
    {
        "content": "<p>Ok, <code>elm-ecs</code> looks better. It uses a lot of type variables and indirection (that could theoretically be compiled away) to make this work. Essentially each component has to know how to get/set itself in the world via the use of lambdas. Assuming those lambdas get compiled away it should generate similar code to what I have above. Though it does still have some clear drawbacks from the direct implementation:</p>\n<ul>\n<li><del>Same bug prone-ness as above due to lacking entity types</del></li>\n<li>Same lookup cost as above due to lacking entity types and needing to look up in all dictionaries before knowing if all components are supported by an entity.</li>\n<li>No memory overhead to the dictionary version due to the lambdas. Would not be able to convert to the list version without adding in maybes and reintroducing the memory overhead.</li>\n<li>restrictions based on how many duplicate methods the author makes. For example, the author only added up to <code>Ecs.Components49</code> so if you have 50 components, you need the author to update the library. Same with a number of the accessors.</li>\n</ul>",
        "id": 276419279,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648080755
    },
    {
        "content": "<p>So I would label this as both having fundamental overhead and restrictions compared to the raw implementation, but still cool and probably useful for many hobby games.</p>",
        "id": 276419305,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648080792
    },
    {
        "content": "<p>Would this be a job for a Roc codegen/scaffolding tool? Or maybe just copy/paste/customize haha</p>",
        "id": 276421422,
        "sender_full_name": "jan kili",
        "timestamp": 1648082904
    },
    {
        "content": "<p>(with regard to the idea I'm gathering that \"Roc ECS developers of all skill levels might be better served by a manual implementation from scratch, since a Roc ECS library can't provide meaningful zero-cost abstractions\")</p>",
        "id": 276421944,
        "sender_full_name": "jan kili",
        "timestamp": 1648083376
    },
    {
        "content": "<p>I think copy and modify would work great for something like with. Also would work well to be able to make a declarative list of types and their components and then generate it.</p>",
        "id": 276428269,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648091209
    },
    {
        "content": "<p>So I was watching <a href=\"https://www.youtube.com/watch?v=NTWSeQtHZ9M\">a talk on ECS</a> to better understand how it is done with good data oriented design. I think that there may actually be a way to modify something like <code>elm-ecs</code> to generate almost the exact same thing as a proper DoD entity component system (assuming all lambdas inline). The actual core difference is just expanding an entity include some metadata about the components and tags that is has.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"NTWSeQtHZ9M\" href=\"https://www.youtube.com/watch?v=NTWSeQtHZ9M\"><img src=\"https://uploads.zulipusercontent.net/a86b318e0eed2a4f97bb56330dbaf15a74f6d83b/68747470733a2f2f692e7974696d672e636f6d2f76692f4e545753655174485a394d2f64656661756c742e6a7067\"></a></div><p>This ECS still doesn't exactly have entity types, but it has entity tags that can be used in the same way. Though it has no proper verification to stop a user from accidentally make an entity that is missing a component that it should have. To get that sort of full verification, you would either need a tag per entity type, or make the entity type something separate.</p>",
        "id": 276430169,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648094331
    },
    {
        "content": "<p>I should add a warning to the talk: it is a lot of C++ and a metric ton of templates.</p>",
        "id": 276430180,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648094369
    },
    {
        "content": "<p>To clarify, there shouldn't be static types of entities. An entity is a collection of components and components can be added to or removed from entities throughout their lifetime</p>",
        "id": 276431827,
        "sender_full_name": "Jared Cone",
        "timestamp": 1648096717
    },
    {
        "content": "<p>Yeah, I didn't realize that at first. see it now with these talks</p>",
        "id": 276431849,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648096769
    },
    {
        "content": "<p>Yeah, I forgot that too in my examples and treated entities as components</p>",
        "id": 276432942,
        "sender_full_name": "jan kili",
        "timestamp": 1648098263
    },
    {
        "content": "<p>There is fundamental clash between ECS and functional programming. </p>\n<p>The fact that any component of an entity can modify other entities and it's components in the game world, eg. on colision with other object, open the door. </p>\n<p>Which is bonkers from the perspective of FP.</p>",
        "id": 276561209,
        "sender_full_name": "Zeljko Nesic",
        "timestamp": 1648171645
    },
    {
        "content": "<p>I believe that we still don't know how to model the world so rich and dynamic with FP and type systems that we've got. </p>\n<p>Just blunt copying the pattern doesn't work!</p>",
        "id": 276561337,
        "sender_full_name": "Zeljko Nesic",
        "timestamp": 1648171777
    },
    {
        "content": "<p>Which is weird, because we are talking about \"composability\" of FP constructs, and yet, we can't have a blank cotton ball and stick random stuff to it and be sure that our program will run.</p>",
        "id": 276561474,
        "sender_full_name": "Zeljko Nesic",
        "timestamp": 1648171909
    },
    {
        "content": "<p>With Roc's inplace mutation, I think that can be worked around. Of course, a small mistake can lead to tons of copying.</p>",
        "id": 276561478,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648171918
    },
    {
        "content": "<p>So definitely a case where you need to tread carefully or you could ruin performance</p>",
        "id": 276561535,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648171949
    },
    {
        "content": "<p>Maybe this is good place where abilities might help? Or platforms?</p>",
        "id": 276561660,
        "sender_full_name": "Zeljko Nesic",
        "timestamp": 1648172097
    },
    {
        "content": "<blockquote>\n<p>The fact that any component of an entity can modify other entities and it's components</p>\n</blockquote>\n<p>Unfortunately ECS has two different meanings. The type of ECS I'm referring to is where the Components are just data, no behavior. Systems are behavior, no data. So in that case Components don't modify anything, but any System can modify any entity or component.</p>",
        "id": 276575179,
        "sender_full_name": "Jared Cone",
        "timestamp": 1648182017
    },
    {
        "content": "<p>I think FP should be a good fit for ECS because Systems can be implemented as pure functions. The thing that I'm a little roadblocked with is how to do it in Roc since there (currently) isn't a data type that can store \"anything\" that can later be cast to the correct underlying type. Though... could open tags somehow support this? I haven't worked much with them.</p>",
        "id": 276575484,
        "sender_full_name": "Jared Cone",
        "timestamp": 1648182406
    },
    {
        "content": "<p>An open tag can't be stored. Has be a concrete type.</p>",
        "id": 276575519,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648182467
    },
    {
        "content": "<p>I think making an ECS library will be hard in Roc (would require lots of type variables and lambdas like the linked elm libraries)</p>",
        "id": 276575577,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648182517
    },
    {
        "content": "<p>I think making a concrete ECS where each component gets it's own array or dictionary should be totally doable. Just has to be done manually.</p>",
        "id": 276575596,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648182562
    },
    {
        "content": "<p>I haven't thought this through at all, and don't know about ECS, but can't you have a general ECS module expressed in terms of a completely open tag system (possibly with tags the ECS module specifically understands), and accept a callback function from the app that takes as input the known app-specific tags? At that point, the compiler would have its concrete definition. This would be a bit like Elm update functions, I presume.</p>",
        "id": 276789063,
        "sender_full_name": "Kevin Gillette",
        "timestamp": 1648388588
    },
    {
        "content": "<p>I think you would run into storage issues. For example, I want the position component in one array and the color component in a separate array.</p>\n<p>If the user of the library is passing an open tag of type <code>[ Pos F32 F32, Color U8 U8 U8 ]*</code>. The underlying library would know nothing about the type and would not able able to do anything with it. The underlying library could store them all to one master list, but it would have no way to distinguish between them.</p>",
        "id": 276799633,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648403776
    },
    {
        "content": "<p>To store <code>Pos</code> in the position array and <code>Color</code> in the color array would require the library to know about the individual tags.</p>",
        "id": 276799656,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1648403859
    },
    {
        "content": "<p>Hi! Is there a platform and example of a simple http server in Roc?</p>",
        "id": 288313143,
        "sender_full_name": "Kas Buunk",
        "timestamp": 1656832689
    },
    {
        "content": "<p>Some work was done on this in <a href=\"https://github.com/rtfeldman/roc/pull/2975\">PR #2975</a> but it may require some updating.</p>",
        "id": 288314023,
        "sender_full_name": "Anton",
        "timestamp": 1656834242
    },
    {
        "content": "<p>Thanks. Would be relevant for a large audience if a solid ecosystem exists for building web services on http, like rest, gRPC, graphql, etc.</p>",
        "id": 288314930,
        "sender_full_name": "Kas Buunk",
        "timestamp": 1656835769
    },
    {
        "content": "<p>Same goes for event-driven microservices, an ecosystem for subscribing and publishing to a Kafka or Nats/JetStream event bus would make it easy for service meshes to experiment with a microservice in Roc.</p>",
        "id": 288314985,
        "sender_full_name": "Kas Buunk",
        "timestamp": 1656835849
    },
    {
        "content": "<p>Absolutely, we definitely plan to work on it in the future.</p>",
        "id": 288315070,
        "sender_full_name": "Anton",
        "timestamp": 1656836040
    },
    {
        "content": "<p>Would make for a fantastic well-scoped domain.</p>",
        "id": 288315623,
        "sender_full_name": "Kas Buunk",
        "timestamp": 1656836993
    },
    {
        "content": "<p>Probably in Rust. With arena memory management with requests and incoming events with their separate arenas.</p>",
        "id": 288315703,
        "sender_full_name": "Kas Buunk",
        "timestamp": 1656837093
    }
]