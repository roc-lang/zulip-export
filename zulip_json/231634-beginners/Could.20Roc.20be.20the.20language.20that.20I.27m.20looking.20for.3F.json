[
    {
        "content": "<p>I love programing and I'm quite frustrated with the state of programming languages, at least the mainstream ones. Go is the language that I've been using for the longest time, more than 10 years. I really like some of it's ideas like: being compiled, easy to cross compile, simple, and fast enough. But the lack of guarantees is such a massive deal breaker. No matter how many times Rob Pike tries to defend the idea of <code>nil</code> and <code>zero value</code>, it simply makes no sense.</p>\n<p>I tried to explore the heavily typed FP languages by using Scala with Cats, and everything felt so magical and hidden on layers upon layers of abstractions. I thought that I was the problem because if you go to r/scala everyone will swear that Scala is a very simple language. Maybe I'm too dumb because it was one of the hardest languages that I had to work with. </p>\n<p>Then I decided to pivot, maybe Rust is the language that I'm looking for. It has many of the benefits from Go, and has a way better type system.  To be honest, Rust is the closest language that I can think of being the ideal one. The core is really not complex, but things can get out of hand quite quick and you'll be in a sea of <code>pub async unsafe fn transcend&lt;'a, 'b: 'a, T, U, const N: usize, E&gt;(input: &amp;'a T, f: impl for&lt;'c&gt; Fn(&amp;'c U) -&gt; Result&lt;&lt;T as IntoIterator&gt;::Item, E&gt; + Send + Sync + 'b) -&gt; impl Future&lt;Output = Result&lt;[Option&lt;&lt;T as IntoIterator&gt;::Item&gt;; N], Box&lt;dyn std::error::Error + Send + Sync&gt;&gt;&gt; + 'a where T: IntoIterator + Clone + Send + Sync + 'a, T::Item: Default + Clone + Send + Sync + 'static, U: ?Sized + 'b, E: std::error::Error + Send + Sync + 'static</code>.<br>\nOk, I'm being too dramatic and you'll not see this all the time, but the borrow checker is just too much for a higher level applications.</p>\n<p>I'm looking for something more advanced than Go, but not like Rust. On this pursuit I found Roc that quite looks that. Elixir getting types is also on my radar. It's not quite on the same level of what I'm expecting, but the Erlang VM is such an wonderful platform, and I would be ok letting go of some \"requirements\" to have that in case I have good types.</p>",
        "id": 575613350,
        "sender_full_name": "fenugurod",
        "timestamp": 1771957150
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"1034079\">@fenugurod</span>,<br>\nit does seem like Roc would be a good fit for you :)<br>\nI have written a good amount of Scala about 10 years ago and I still remember it fondly, it is quite easy to get too fancy with the FP stuff though.</p>",
        "id": 575617040,
        "sender_full_name": "Anton",
        "timestamp": 1771958446
    },
    {
        "content": "<p>I think Roc will be amazing for many use cases. Roc is different to most languages because of the application/platform split. I like that applications can sit at a higher level of abstraction, with platforms providing a curated experience and managing the lower level details.</p>\n<p>Where there is a mature platform for a particular domain -- I feel like it will be hard to match Roc for ergonomics and performance. However, I think there will still be many kinds of software where Roc isn't a good fit. Maybe where you need precise control over memory layout, CPU instructions such as high performance computing, low-level firmware / graphics / OS etc.</p>",
        "id": 575642303,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1771967533
    }
]