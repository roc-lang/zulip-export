[
    {
        "content": "<p>Tags are super useful and elegant and I really like them, but what the hell are they, mathematically speaking? They just seem like magic objects to me, even though I understand how they function in a practical sense. Like what do they compile to? Do they compile to anything at all, or are they just an abstraction that vanishes? What's actually happening when I decide to add a branch to a function that returns a tag?</p>",
        "id": 397828496,
        "sender_full_name": "Declan Joseph Maguire",
        "timestamp": 1697876134
    },
    {
        "content": "<p>The tag ID is represented as an integer at runtime.<br>\nFor each expression in your program that has a tag type, the type checker will figure out the set of all possible tags that can end up there. Then that set of tags gets a runtime representation where each tag is assigned an integer value.<br>\nSo the same tag name <code>A</code> could be represented as different numbers in different places, depending on what other tags reach there.<br>\nTags can also have payload values and in that case they form a data structure containing the payload values and the tag ID.</p>",
        "id": 397841216,
        "sender_full_name": "Brian Carroll",
        "timestamp": 1697886562
    },
    {
        "content": "<p>You did ask for a mathematical answer and I realise this is a programming answer!</p>",
        "id": 397841444,
        "sender_full_name": "Brian Carroll",
        "timestamp": 1697886597
    },
    {
        "content": "<p>Still helpful, it gives a skeleton that might help me double check my understanding when trying to understand a more mathy version. I guess part of why I want the maths answer is how neat and tight the rest of the type system is. It's just a highly comprehensible, unified system, and is otherwise conventional, but then you have tags that seem to blur the very lines between variable, name, and value.</p>",
        "id": 397841761,
        "sender_full_name": "Declan Joseph Maguire",
        "timestamp": 1697886848
    },
    {
        "content": "<p>They're so bizzare, even as they're so simple in practical use.</p>",
        "id": 397841788,
        "sender_full_name": "Declan Joseph Maguire",
        "timestamp": 1697886877
    },
    {
        "content": "<p><a href=\"https://vimeo.com/653510682\">https://vimeo.com/653510682</a> around the 40 minute mark talks about the in-memory representation, kinda aimed at a C/C++ audience - I'm happy to elaborate on any of that!</p>",
        "id": 397847099,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1697891726
    },
    {
        "content": "<p>I think of them as functions. So if you have <code>MyType : [Foo Str]</code> then <code>Foo</code> is a function <code>Foo : Str -&gt; [Foo Str]</code> and when you write <code>Foo \"some string\"</code> you're applying <code>Foo</code> to the argument <code>\"some string\"</code>. This isn't what <code>Foo</code> explicitly is in the language but I think it works conceptually. </p>\n<p>It is however explicit in languages like Elm and Haskell. For example in elm:</p>\n<div class=\"codehilite\"><pre><span></span><code>&gt; type Foo = Foo String\n&gt; Foo\n&lt;function&gt; : String -&gt; Foo\n</code></pre></div>\n<p>Here tags are just functions and you can use them in all the same ways. (in haskell they are called value constructors)</p>",
        "id": 397853677,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1697898211
    },
    {
        "content": "<p>Here is the math interpretation:<br>\nYou can think of tags as forming an ADT/sum type/coproduct (I'll use coproduct). Specifically, for a given tag union type <code>[Zero, Add x y]</code>, we have the inclusion operations</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.25em\" columnalign=\"right left\" columnspacing=\"0em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mi mathvariant=\"monospace\">Z</mi><mi mathvariant=\"monospace\">e</mi><mi mathvariant=\"monospace\">r</mi><mi mathvariant=\"monospace\">o</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>↪</mo><mrow><mo stretchy=\"false\">[</mo><mi mathvariant=\"monospace\">Z</mi><mi mathvariant=\"monospace\">e</mi><mi mathvariant=\"monospace\">r</mi><mi mathvariant=\"monospace\">o</mi><mo separator=\"true\">,</mo><mi mathvariant=\"monospace\">A</mi><mi mathvariant=\"monospace\">d</mi><mi mathvariant=\"monospace\">d</mi><mtext> </mtext><mi mathvariant=\"monospace\">x</mi><mtext> </mtext><mi mathvariant=\"monospace\">y</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mi mathvariant=\"monospace\">A</mi><mi mathvariant=\"monospace\">d</mi><mi mathvariant=\"monospace\">d</mi><mtext> </mtext><mi mathvariant=\"monospace\">x</mi><mtext> </mtext><mi mathvariant=\"monospace\">y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>↪</mo><mrow><mo stretchy=\"false\">[</mo><mi mathvariant=\"monospace\">Z</mi><mi mathvariant=\"monospace\">e</mi><mi mathvariant=\"monospace\">r</mi><mi mathvariant=\"monospace\">o</mi><mo separator=\"true\">,</mo><mi mathvariant=\"monospace\">A</mi><mi mathvariant=\"monospace\">d</mi><mi mathvariant=\"monospace\">d</mi><mtext> </mtext><mi mathvariant=\"monospace\">x</mi><mtext> </mtext><mi mathvariant=\"monospace\">y</mi><mo stretchy=\"false\">]</mo></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{align*}\n\\tt{Zero} &amp;\\hookrightarrow \\tt{[Zero, Add\\ x\\ y]}\\\\\n\\tt{Add\\ x\\ y} &amp;\\hookrightarrow \\tt{[Zero, Add\\ x\\ y]}\n\\end{align*}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:3em;vertical-align:-1.25em;\"></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-r\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.75em;\"><span style=\"top:-3.91em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathtt\">Zero</span></span></span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathtt\">Add</span><span class=\"mspace\"> </span><span class=\"mord mathtt\">x</span><span class=\"mspace\"> </span><span class=\"mord mathtt\">y</span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.25em;\"><span></span></span></span></span></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.75em;\"><span style=\"top:-3.91em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↪</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\">[</span><span class=\"mord mathtt\">Zero</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathtt\">Add</span><span class=\"mspace\"> </span><span class=\"mord mathtt\">x</span><span class=\"mspace\"> </span><span class=\"mord mathtt\">y</span><span class=\"mclose\">]</span></span></span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↪</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\">[</span><span class=\"mord mathtt\">Zero</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathtt\">Add</span><span class=\"mspace\"> </span><span class=\"mord mathtt\">x</span><span class=\"mspace\"> </span><span class=\"mord mathtt\">y</span><span class=\"mclose\">]</span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.25em;\"><span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p>Now, Roc has an important distinction between \"open\" and \"closed\" tag union types. The distinction is that a closed tag union cannot grow - that is, there is no way to transform the closed union type <code>[Zero, Add x y]</code> to any other union type. However, the open tag union type <code>[Zero, Add x y]*</code> can grow - that is, there is an operation I can perform to add a new variant to that type, thus making the type larger. We can thus think of some relationship like</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mtable rowspacing=\"0.25em\" columnalign=\"right left\" columnspacing=\"0em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mi mathvariant=\"monospace\">Z</mi><mi mathvariant=\"monospace\">e</mi><mi mathvariant=\"monospace\">r</mi><mi mathvariant=\"monospace\">o</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>↪</mo><mrow><mo stretchy=\"false\">[</mo><mi mathvariant=\"monospace\">Z</mi><mi mathvariant=\"monospace\">e</mi><mi mathvariant=\"monospace\">r</mi><mi mathvariant=\"monospace\">o</mi><mo separator=\"true\">,</mo><mi mathvariant=\"monospace\">A</mi><mi mathvariant=\"monospace\">d</mi><mi mathvariant=\"monospace\">d</mi><mtext> </mtext><mi mathvariant=\"monospace\">x</mi><mtext> </mtext><mi mathvariant=\"monospace\">y</mi><mo stretchy=\"false\">]</mo><mo>∗</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mi mathvariant=\"monospace\">A</mi><mi mathvariant=\"monospace\">d</mi><mi mathvariant=\"monospace\">d</mi><mtext> </mtext><mi mathvariant=\"monospace\">x</mi><mtext> </mtext><mi mathvariant=\"monospace\">y</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>↪</mo><mrow><mo stretchy=\"false\">[</mo><mi mathvariant=\"monospace\">Z</mi><mi mathvariant=\"monospace\">e</mi><mi mathvariant=\"monospace\">r</mi><mi mathvariant=\"monospace\">o</mi><mo separator=\"true\">,</mo><mi mathvariant=\"monospace\">A</mi><mi mathvariant=\"monospace\">d</mi><mi mathvariant=\"monospace\">d</mi><mtext> </mtext><mi mathvariant=\"monospace\">x</mi><mtext> </mtext><mi mathvariant=\"monospace\">y</mi><mo stretchy=\"false\">]</mo><mo>∗</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mo>&lt;</mo><mi mathvariant=\"monospace\">A</mi><mi mathvariant=\"monospace\">n</mi><mi mathvariant=\"monospace\">y</mi><mi mathvariant=\"monospace\">O</mi><mi mathvariant=\"monospace\">t</mi><mi mathvariant=\"monospace\">h</mi><mi mathvariant=\"monospace\">e</mi><mi mathvariant=\"monospace\">r</mi><mi mathvariant=\"monospace\">T</mi><mi mathvariant=\"monospace\">a</mi><mi mathvariant=\"monospace\">g</mi><mo>&gt;</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"true\"><mrow><mrow></mrow><mo>↪</mo><mrow><mrow><mo stretchy=\"false\">[</mo><mi mathvariant=\"monospace\">Z</mi><mi mathvariant=\"monospace\">e</mi><mi mathvariant=\"monospace\">r</mi><mi mathvariant=\"monospace\">o</mi><mo separator=\"true\">,</mo><mi mathvariant=\"monospace\">A</mi><mi mathvariant=\"monospace\">d</mi><mi mathvariant=\"monospace\">d</mi><mtext> </mtext><mi mathvariant=\"monospace\">x</mi><mtext> </mtext><mi mathvariant=\"monospace\">y</mi><mo stretchy=\"false\">]</mo><mo>∗</mo></mrow><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mrow><mo stretchy=\"false\">[</mo><mi mathvariant=\"monospace\">Z</mi><mi mathvariant=\"monospace\">e</mi><mi mathvariant=\"monospace\">r</mi><mi mathvariant=\"monospace\">o</mi><mo separator=\"true\">,</mo><mi mathvariant=\"monospace\">A</mi><mi mathvariant=\"monospace\">d</mi><mi mathvariant=\"monospace\">d</mi><mtext> </mtext><mi mathvariant=\"monospace\">x</mi><mtext> </mtext><mi mathvariant=\"monospace\">y</mi><mo separator=\"true\">,</mo><mo>&lt;</mo><mi mathvariant=\"monospace\">A</mi><mi mathvariant=\"monospace\">n</mi><mi mathvariant=\"monospace\">y</mi><mi mathvariant=\"monospace\">O</mi><mi mathvariant=\"monospace\">t</mi><mi mathvariant=\"monospace\">h</mi><mi mathvariant=\"monospace\">e</mi><mi mathvariant=\"monospace\">r</mi><mi mathvariant=\"monospace\">T</mi><mi mathvariant=\"monospace\">a</mi><mi mathvariant=\"monospace\">g</mi><mo>&gt;</mo><mo stretchy=\"false\">]</mo><mo>∗</mo></mrow></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\\begin{align*}\n\\tt{Zero} &amp;\\hookrightarrow \\tt{[Zero, Add\\ x\\ y]*}\\\\\n\\tt{Add\\ x\\ y} &amp;\\hookrightarrow \\tt{[Zero, Add\\ x\\ y]*}\\\\\n\\tt{&lt;AnyOtherTag&gt;} &amp;\\hookrightarrow \\tt{[Zero, Add\\ x\\ y]*} \\implies \\tt{[Zero, Add\\ x\\ y, &lt;AnyOtherTag&gt;]*}\n\\end{align*}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:4.5em;vertical-align:-2em;\"></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-r\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.5em;\"><span style=\"top:-4.66em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathtt\">Zero</span></span></span></span></span><span style=\"top:-3.16em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathtt\">Add</span><span class=\"mspace\"> </span><span class=\"mord mathtt\">x</span><span class=\"mspace\"> </span><span class=\"mord mathtt\">y</span></span></span></span></span><span style=\"top:-1.66em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathtt\">AnyOtherTag</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2em;\"><span></span></span></span></span></span><span class=\"col-align-l\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.5em;\"><span style=\"top:-4.66em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↪</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\">[</span><span class=\"mord mathtt\">Zero</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathtt\">Add</span><span class=\"mspace\"> </span><span class=\"mord mathtt\">x</span><span class=\"mspace\"> </span><span class=\"mord mathtt\">y</span><span class=\"mclose\">]</span><span class=\"mord\">∗</span></span></span></span></span><span style=\"top:-3.16em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↪</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\">[</span><span class=\"mord mathtt\">Zero</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathtt\">Add</span><span class=\"mspace\"> </span><span class=\"mord mathtt\">x</span><span class=\"mspace\"> </span><span class=\"mord mathtt\">y</span><span class=\"mclose\">]</span><span class=\"mord\">∗</span></span></span></span></span><span style=\"top:-1.66em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↪</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\">[</span><span class=\"mord mathtt\">Zero</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathtt\">Add</span><span class=\"mspace\"> </span><span class=\"mord mathtt\">x</span><span class=\"mspace\"> </span><span class=\"mord mathtt\">y</span><span class=\"mclose\">]</span><span class=\"mord\">∗</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mopen\">[</span><span class=\"mord mathtt\">Zero</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathtt\">Add</span><span class=\"mspace\"> </span><span class=\"mord mathtt\">x</span><span class=\"mspace\"> </span><span class=\"mord mathtt\">y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathtt\">AnyOtherTag</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mclose\">]</span><span class=\"mord\">∗</span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2em;\"><span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p>If you think of all possible tag unions as sets, you can say adding the tag <code>Sub x y</code> to <code>[Zero, Add x y]*</code> is a function that maps <code>[Zero, Add x y]*</code> to <code>[Zero, Add x y, Sub x y]*</code> and leaves all other tag unions intact.</p>\n<p>If you are familiar with category theory, we can say precisely that there is some category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>a</mi><mi>g</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">Tags</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">s</span></span></span></span> consisting of all open and closed tag unions, where growing an open tag union by one variant is an endofunctor mapping that particular tag union. And, there is a free functor from a open tag union to a closed one, and a forgetful functor the other way, that form a monad over the category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>a</mi><mi>g</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">Tags</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">s</span></span></span></span></p>",
        "id": 397854643,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1697898991
    },
    {
        "content": "<p>Okay from these replies and some independent research, I think I get how Tags work. Tags without payloads are basically Just Types but with weird rules that mean you can create them on the fly and treat them syntactically like values (if there's something deeper to this, tell me!). Without payloads, the type has only one inhabitant with no properties beyond that, but the with \"with payload\" version is still a little mysterious to me mathematically. The rules around scope and equality are still a little murky to me, which I think is where a lot of my confusion comes from.</p>",
        "id": 398883011,
        "sender_full_name": "Declan Joseph Maguire",
        "timestamp": 1698407446
    },
    {
        "content": "<p>Tags without payloads are enums.</p>",
        "id": 398884037,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1698407882
    },
    {
        "content": "<p>Tags only disappear fully is there is only a single possible tag.</p>",
        "id": 398884190,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1698407928
    },
    {
        "content": "<p>With a payload, a tag is justed an enum and a union of data.</p>",
        "id": 398884309,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1698407977
    },
    {
        "content": "<p>Things get a tiny bit mor complex with recusion</p>",
        "id": 398884373,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1698408001
    },
    {
        "content": "<p>Yeah on a moment-to-moment level I'd understood that's how they worked, I just found it bizzare (if extremely practical) that I could just write one function over here that spits out a Tag, another over there that accepts a Tag, and the two just know that they're talking about the same thing. Like that's not how things normally work, if you defined a type in a function then it wouldn't magically exist elsewhere. I guess it only works because Tags without values have no properties beyond their names and thus having things like that have such a wide scope won't cause things to stop working in one function just because you created a tag elsewhere. The payload is almost the same but opposite, a fungible bag of data unconstrained by its tag.</p>",
        "id": 398885860,
        "sender_full_name": "Declan Joseph Maguire",
        "timestamp": 1698408509
    },
    {
        "content": "<p>Oh, that is really more about our type inference than tags specifically</p>",
        "id": 398886292,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1698408659
    },
    {
        "content": "<p>With hindsight I can see that, but it was just so strange because it clearly would always work, but felt somehow like it shouldn't. Like it should somehow cause problems, contradictions. I think the more abstract side is starting to click though.</p>",
        "id": 398887322,
        "sender_full_name": "Declan Joseph Maguire",
        "timestamp": 1698409051
    },
    {
        "content": "<p>Like I'm confused by backpassing too, but that doesn't bother me because that's currently so opaque that I know it's just a matter of getting it, whereas Tags felt more mysterious because it felt like there was something that wasn't clicking even though I understood the pragmatic use perfectly.</p>",
        "id": 398887650,
        "sender_full_name": "Declan Joseph Maguire",
        "timestamp": 1698409175
    },
    {
        "content": "<p>I think one key point to reconciling this is the fact that almost all types in Roc are structural, rather than nominal (except for opaque types, but we can disregard that here). Unlike in C/Rust/Java where if you declare, for example, and enum in a scope, each variant in the enum is scoped to the “name” of the enum. But in Roc, when enum variants (tags) compose into an enum, the enum does not have a “name” - its type is determined solely by the variants it consists of. That’s why passing a tag A between two functions that declare it separately works - because the types are compared as [A]=[A], which is true - whereas in, for example C++ if you try to compare OneEnum::A=OtherEnum::A, this is false, because the names of the enums are different.</p>",
        "id": 398900787,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1698413910
    },
    {
        "content": "<p>Those are some great searchterms to investigate later. Yeah, the fact that you can be so loose with it, the fact that you don't need a scope or enclosing name, is what's so surprising to me. You can see in the other comments how it slowly dawns on me why this doesn't break things.</p>",
        "id": 398902776,
        "sender_full_name": "Declan Joseph Maguire",
        "timestamp": 1698414638
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"454654\">Ayaz Hafiz</span> <a href=\"#narrow/stream/231634-beginners/topic/What.20actually.20*is*.20a.20tag.3F/near/397854643\">said</a>:</p>\n<blockquote>\n<p>If you are familiar with category theory, we can say precisely that there is some category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>a</mi><mi>g</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">Tags</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">s</span></span></span></span> consisting of all open and closed tag unions, where growing an open tag union by one variant is an endofunctor mapping that particular tag union. And, there is a free functor from a open tag union to a closed one, and a forgetful functor the other way, that form a monad over the category <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>a</mi><mi>g</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">Tags</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">s</span></span></span></span></p>\n</blockquote>\n<p>By the way, I have had this thought at the back of my mind for a while, sorry for resurrecting an old thread <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> ... This sounds like something there should be a paper about. Is anyone writing a paper about this? Or is this based on some paper already? Maybe someone should write a paper about it? <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 410744730,
        "sender_full_name": "Johan Lövgren",
        "timestamp": 1704134471
    },
    {
        "content": "<p>I don't know of any academic literature about that interpretation exactly, but it's the same as the idea of \"pointed sets\" (as opposed to regular sets) in math which are well-studied.</p>",
        "id": 410751536,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1704140346
    },
    {
        "content": "<p>Thanks, that gives me something to read about!</p>",
        "id": 410756291,
        "sender_full_name": "Johan Lövgren",
        "timestamp": 1704142895
    },
    {
        "content": "<p>Hi, I got a bit nerd sniped by that category theory connection / question and tried to work out some details. I mostly ran into problems with that. I don't think the <code>Tags</code> subcategory \"just works\" and would need some work to define what the Objects actually are that is more concrete than \"all Roc types\". Once that Object set has some mathematical modeling, that will directly include a model of open and closed tag unions.</p>\n<p>If you actually do that modelling, you'll probably want to start with a smaller subset of Roc.</p>\n<p>Anyway, here is what I wrote about that earlier, without trying to model what the Objects and Arrows look like.</p>\n<hr>\n<p>I don't think we can throw categories on this and expect it to be simple.</p>\n<blockquote>\n<p>growing an open tag union by one variant is an endofunctor mapping that particular tag union</p>\n</blockquote>\n<p>Here a functor is a mechanism to turn one union type into another union type. The example functor here is \"Adding Sub x y to the union\".</p>\n<p>[Zero] -&gt; [Zero, Sub x y]<br>\n[Zero, Add x y] -&gt; [Zero, Add x y, Sub x y]<br>\n[Roc] -&gt; [Roc, Sub x y]<br>\n[Zero, Add x y, Sub x y] -&gt; [Zero, Add x y, Sub x y]</p>\n<p>Now the last one is a bit weird. It doesn't actually change the type because \"Sub x y\" is already in there. But it hints at a problem this example functor has:</p>\n<p>[Sub Marine] -&gt; TYPE MISMATCH, does not compile.</p>\n<p>So you'll need to define each such functor on a separate subset (sub-category) of the \"Tags\" category.</p>",
        "id": 410776456,
        "sender_full_name": "Rolf Kreibaum",
        "timestamp": 1704157458
    },
    {
        "content": "<hr>\n<blockquote>\n<p>there is a free functor from a open tag union to a closed one, and a forgetful functor the other way</p>\n</blockquote>\n<p>I just arrived here from a podcast on Roc so I had some reading up to do on open and closed. But I don't think you can forget either way. I failed to construct the forgetful functor.</p>\n<p>Here is what I tried:</p>\n<p>Given a Roc function <code>f : [Red Str] -&gt; [Red Nat]</code> (e.g. string length) we can extend it to <code>f*: [Red Str]* -&gt; [Red Nat]*</code> by defining</p>\n<div class=\"codehilite\" data-code-language=\"Elm\"><pre><span></span><code><span class=\"nv\">f</span><span class=\"nf\">*</span><span class=\"w\"> </span><span class=\"nf\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">Red</span><span class=\"w\"> </span><span class=\"kt\">Str</span><span class=\"p\">]</span><span class=\"nf\">*</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">Red</span><span class=\"w\"> </span><span class=\"kt\">Nat</span><span class=\"p\">]</span><span class=\"nf\">*</span>\n<span class=\"nv\">f</span><span class=\"nf\">*</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"nv\">tag</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"nv\">when</span><span class=\"w\"> </span><span class=\"nv\">tag</span><span class=\"w\"> </span><span class=\"nv\">is</span>\n<span class=\"w\">        </span><span class=\"kt\">Red</span><span class=\"w\"> </span><span class=\"nv\">str</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nv\">f</span><span class=\"w\"> </span><span class=\"nv\">str</span>\n<span class=\"w\">        </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nv\">x</span>\n</code></pre></div>\n<p>So in this instance the functor looks ok.</p>\n<p>I don't know if an open tag union is actually allowed in return position in Roc. I assume it is allowed, otherwise we wouldn't have much of a <code>Tags</code> category to start with.</p>\n<p>But let's consider <code>g: [Red] -&gt; [Green Str]</code> with <code>Red -&gt; Green \"Apple\"</code> as definition.<br>\nThe extension would be defined on <code>g*: [Red]* -&gt; [Green Str]*</code> - but where does this map <code>Green 7</code>? It is not allowed to map to <code>Green 7</code>, because the type <code>[Green Str]*</code> guarantees that any value tagged as <code>Green</code> must carry a <code>Str</code> payload.</p>\n<p>I had no success trying to define a functor going the other way either :-(</p>",
        "id": 410782233,
        "sender_full_name": "Rolf Kreibaum",
        "timestamp": 1704161257
    },
    {
        "content": "<hr>\n<p>More on open/closed from the Tutorial</p>\n<blockquote>\n<p>If you have an open union, that means it can accumulate more tags through conditional branches.<br>\nIf you accept an open union, that means you have to handle the possibility that it has a tag you can't know about.</p>\n</blockquote>\n<p>To me this sounds very much like \"an open union you have\" and \"an open union you receive\" are actually two different things that just happen to share a name.</p>\n<p>The \"open union you receive\" seems to be a proper type. It can appear it type signatures.<br>\nThe \"open union you have\" seems to be the type of an expression - and it feels a lot more like a \"closed union\" to me. Because I can pass the value of the expression to functions that require a closed union, I know that only values of type \"closed union\" can actually be the value of this expression.</p>",
        "id": 410783582,
        "sender_full_name": "Rolf Kreibaum",
        "timestamp": 1704162106
    }
]