[
    {
        "content": "<p>Hey all, I'm new to Roc, the separation between platforms and applications is a really cool idea.</p>\n<p>I watched a talk about how Roc's implementation of effects is essentially that the function returns a result object with something indicating what effect should be performed and then that is implemented elsewhere. I'm wondering, is it possible for the platform to expose custom effects to the application that only the platform can handle?</p>\n<p>At work I use a workflow service like cadence / temporal for orchestrating distributed, long running jobs. To use it correctly devs essentially have to write pure functions. Anything producing side effects has to be called in a special way so the workflow library can manage them. If you don't you'll get wierd behavior at runtime.</p>\n<p>Turns out getting everyone to use this thing correctly consistently is impossible. With something like Roc though, I could imagine a framework that could statically catch those problems. For it to work though I think the platform would have to be able to expose some set of effect types that it can manage execution for and then resume running Roc code once the effect result is available.</p>",
        "id": 546683684,
        "sender_full_name": "Michael Stevens",
        "timestamp": 1761226962
    },
    {
        "content": "<blockquote>\n<p>the platform to expose custom effects to the application that only the platform can handle</p>\n</blockquote>\n<blockquote>\n<p>platform would have to be able to expose some set of effect types that it can manage execution for and then resume running Roc code once the effect result is available.</p>\n</blockquote>\n<p>As far as I know, that is exactly how Roc works! All effects in Roc are handled by the platform, and then it hands the return value of the effect back to the application</p>",
        "id": 546692904,
        "sender_full_name": "Hannes",
        "timestamp": 1761229011
    },
    {
        "content": "<p>Let me know if I've misunderstood your question <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 546693022,
        "sender_full_name": "Hannes",
        "timestamp": 1761229035
    },
    {
        "content": "<p>So it's possible to write something like</p>\n<div class=\"codehilite\"><pre><span></span><code>result0 = ctx.run!(&quot;foo&quot;)\nresult1 = ctx.run!(&quot;bar&quot;, result0)\n</code></pre></div>\n<p>Where there's like an hour long gap between the two results where the platform is busy running task \"foo\"?</p>",
        "id": 546713503,
        "sender_full_name": "Michael Stevens",
        "timestamp": 1761234008
    },
    {
        "content": "<p>Such a cool idea combining Roc with Temporal, I think that'd be a great fit!</p>\n<p>I think what you describe should be possible. One way to go about it would be for the platform to keep track of results from previous effects, serialize and store them. Then when the \"current effect\" resolves the platform can rerun the function, return stored results from effect calls, and when a new effect is encountered queue it and exit. The platform would keep doing that until the function can run off stored results to completion. Because the platform is fully in control of what effects are possible and Roc is otherwise pure there'd be no way for users to do anything illegal.</p>",
        "id": 546731218,
        "sender_full_name": "Jasper Woudenberg",
        "timestamp": 1761239263
    },
    {
        "content": "<p>It does seem like a perfect fit. We have another problem where when we push new versions of our service if we aren't extra careful inflight workflows will have unexpected behavior as they start to run on the new code.</p>\n<p>You can solve that with workflow versioning, but that's another footgun that goes off all the time.</p>\n<p>Could I keep multiple versions of the roc application around and always run requests on the same version they started on?</p>",
        "id": 546752785,
        "sender_full_name": "Michael Stevens",
        "timestamp": 1761246908
    },
    {
        "content": "<p>For sure</p>",
        "id": 546758745,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1761249171
    },
    {
        "content": "<p>They are just binaries</p>",
        "id": 546758753,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1761249174
    },
    {
        "content": "<p>Are there any examples of platforms in go/rust/zig that are slightly more complicated than this one? <a href=\"https://roc-lang.org/examples/GoPlatform/README\">https://roc-lang.org/examples/GoPlatform/README</a></p>",
        "id": 546762107,
        "sender_full_name": "Michael Stevens",
        "timestamp": 1761250449
    },
    {
        "content": "<p>Slightly, maybe not, significantly, probably.</p>",
        "id": 546798745,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1761272838
    },
    {
        "content": "<p>We have basic cli and basic webserver in rust</p>",
        "id": 546798761,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1761272846
    },
    {
        "content": "<p>We have this like roc wasm4 in zig</p>",
        "id": 546798771,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1761272856
    },
    {
        "content": "<p>Some links:<br>\n<a href=\"https://github.com/roc-lang/basic-cli\">https://github.com/roc-lang/basic-cli</a><br>\n<a href=\"https://github.com/roc-lang/basic-webserver\">https://github.com/roc-lang/basic-webserver</a><br>\n<a href=\"https://github.com/lukewilliamboswell/roc-wasm4\">https://github.com/lukewilliamboswell/roc-wasm4</a> (this one is not up to date)</p>",
        "id": 546836627,
        "sender_full_name": "Anton",
        "timestamp": 1761293712
    }
]