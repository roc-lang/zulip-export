[
    {
        "content": "<p>I've read the tutorial's take on tag unions and it's saying after an <code>if</code> statement with two different tags as return values, the resulting type would be an open tag unions of those tags. Moreover, if you try to pattern match with <code>when</code> on an open tag union, it's written you should handle all possible cases, which means having a <code>_ -&gt; something</code> case.</p>\n<p>So I was expecting this program to not typecheck properly, but it's currently working without any problem. Is it me not understanding tag unions?</p>\n<p><a href=\"/user_uploads/22008/LI71Iz-AsMyD7UQ_NeZJVgUX/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/22008/LI71Iz-AsMyD7UQ_NeZJVgUX/image.png\" title=\"image.png\"><img src=\"/user_uploads/22008/LI71Iz-AsMyD7UQ_NeZJVgUX/image.png\"></a></div>",
        "id": 304977788,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666192538
    },
    {
        "content": "<p>It's mentioned in the tutorial, look for text: \"when you already have a value which is an open union, you have fewer requirements\"</p>",
        "id": 305008438,
        "sender_full_name": "Michał Łępicki",
        "timestamp": 1666201425
    },
    {
        "content": "<p>The type of <code>a</code> by itself would be <code>[ Err Str, Ok Str ]*</code>. This enables it to merge with other tags if necessary.</p>\n<p>In this specific case, the <code>when</code> clause requested that it would be <code>[ Err Str, Ok Str ]</code>. So the open union is now restricted to being a closed union and it types check.</p>\n<p>Here is concrete integer example that may help:</p>\n<div class=\"codehilite\"><pre><span></span><code>x : Num a\nx = 12\ny : U8\ny = 15\nz = x + y\n</code></pre></div>\n<p>What type is x? Originally <code>x</code> could be any number type. Then it was added to <code>y</code> which is a <code>U8</code>. As such, <code>x</code> has to be a <code>U8</code> as well.</p>",
        "id": 305011099,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666202162
    },
    {
        "content": "<p>The same sort of use limiting the possible type is what is happen with that <code>if</code> and <code>when</code> statement.</p>",
        "id": 305011345,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666202231
    },
    {
        "content": "<p>As another example, these are also valid:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"nx\">Ok</span><span class=\"w\"> </span><span class=\"s\">\"ok\"</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"nx\">Err</span><span class=\"w\"> </span><span class=\"s\">\"err\"</span><span class=\"w\"></span>\n<span class=\"nv\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">when</span><span class=\"w\"> </span><span class=\"nx\">a</span><span class=\"w\"> </span><span class=\"o\">is</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nx\">Ok</span><span class=\"w\"> </span><span class=\"nx\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"yes\"</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nx\">Err</span><span class=\"w\"> </span><span class=\"nx\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"no\"</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nx\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"other?\"</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"nx\">Ok</span><span class=\"w\"> </span><span class=\"s\">\"ok\"</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"nx\">Err</span><span class=\"w\"> </span><span class=\"s\">\"err\"</span><span class=\"w\"></span>\n<span class=\"nv\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">when</span><span class=\"w\"> </span><span class=\"nx\">a</span><span class=\"w\"> </span><span class=\"o\">is</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nx\">Ok</span><span class=\"w\"> </span><span class=\"nx\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"yes\"</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nx\">Err</span><span class=\"w\"> </span><span class=\"nx\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"no\"</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nx\">LastConcrete</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"That other concrete tag\"</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 305012273,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666202515
    },
    {
        "content": "<p>in the first, <code>a</code> would have the type <code>[ Ok Str, Err Str ]*</code>.<br>\nIn the second, <code>a</code> would have the type <code>[ Ok Str, Err Str, LastConcrete ]</code>.</p>",
        "id": 305012901,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666202712
    },
    {
        "content": "<p>Ok so basically the use of <code>when</code> is restricting the value I'm pattern matching on based on the cases I've written. But I don't get how <code>a</code> is being restricted when it's not restricted originally.</p>\n<p>If I have <code>[Ok Str, Err Str]*</code> I can't for sure restrict it to be <code>[Ok Str, Err Str]</code> cause there could be possible different cases for it. And that's what <code>a</code> is in this context.</p>\n<p>Is that the case where the type checker automatically restrict <code>a</code> to be a closed union <code>[Ok Str, Err Str]</code> even in <code>a</code> assignment? So whenever I use <code>a</code> it's a closed union since I've once used it as a closed union in a <code>when</code> inside <code>b</code>? Otherwise I'm not getting it.</p>",
        "id": 305095436,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666251658
    },
    {
        "content": "<p>I mean, the <code>a</code> <code>b</code> is referring to is the same <code>a</code> I've defined on the previous row, right? It's not like I'm using some untyped argument to pattern match on</p>",
        "id": 305095618,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666251754
    },
    {
        "content": "<p>I also realize I don't fully understand this, why is this an error for example?</p>\n<div class=\"codehilite\"><pre><span></span><code>» a = \\e -&gt; if 3 &gt; 4 then Ok &quot;ok&quot; else e\n… b = \\v -&gt; when a v is\n…             Ok &quot;ok&quot; -&gt; &quot;ok&quot;\n…             Err &quot;err&quot; -&gt; &quot;err&quot;\n… b\n\n── UNSAFE PATTERN ──────────────────────────────────────────────────────────────\n\nThis when does not cover all the possibilities:\n\n5│&gt;      b = \\v -&gt; when a v is\n6│&gt;                  Ok &quot;ok&quot; -&gt; &quot;ok&quot;\n7│&gt;                  Err &quot;err&quot; -&gt; &quot;err&quot;\n\nOther possibilities include:\n\n    Err _\n    Ok _\n\nI would have to crash if I saw one of those! Add branches for them!\n</code></pre></div>",
        "id": 305118182,
        "sender_full_name": "Michał Łępicki",
        "timestamp": 1666261229
    },
    {
        "content": "<p>That's because you're working with unknown values given in input, cause both <code>a</code> and <code>b</code> use their arguments which they don't know anything about, so the type checker safely assume they're open</p>",
        "id": 305118436,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666261340
    },
    {
        "content": "<p>Right, that's a bad example because strings are not singleton types themselves, my bad.</p>",
        "id": 305129555,
        "sender_full_name": "Michał Łępicki",
        "timestamp": 1666265096
    },
    {
        "content": "<p>But still, I'm not getting how my <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/304977788\">example</a> type check correctly</p>",
        "id": 305136245,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666267900
    },
    {
        "content": "<p>My understanding is: value <code>a</code> has an \"open\" union type, meaning it could be extended with some other tag so that another value has a different type. But in this case, when passed as an input to the <code>when</code> which expects a \"closed\" union type, it's fine because all possible tag variants in the <code>a</code> type are statically known and compatible. In my example (after fixing <code>when</code>s in the <code>b</code> function), the argument of function <code>b</code> gets narrowed to a closed tag union even though <code>a</code> function has a wider parametrized tag argument type</p>",
        "id": 305137138,
        "sender_full_name": "Michał Łępicki",
        "timestamp": 1666268281
    },
    {
        "content": "<p>I come from a typescript background. If I have a value <code>a</code> which is typed as <code>string | number</code> which means either a string or either a number but I don't know what, if I \"pattern match\" on it to explore all possible cases I can't simply write a single case for <code>string</code> because the type checker would argue I'm missing a branch for <code>number</code> case.</p>\n<p>In my example, I have <code>a</code> typed as <code>[Ok Str, Err Str]*</code> which I understood being the same as \"I don't know which type of tag union this is, due to the * in it could be anything, but for sure if I encounter an Ok or Err tag they have a single value of type Str\".</p>\n<p>So when I pattern match on the <code>a</code> value and I'm explicitly declaring only two branches covering the <code>Ok</code> and <code>Err</code> tags, I'm left with <code>*</code> which could mean <code>a</code> could be anything else other than <code>Ok</code> and <code>Err</code> and I'm not covering that case.</p>",
        "id": 305138693,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666268842
    },
    {
        "content": "<p>That's why I'm expecting a type check error if I'm not handling the <code>*</code> case</p>",
        "id": 305138909,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666268915
    },
    {
        "content": "<p>Maybe <span class=\"user-mention\" data-user-id=\"343810\">@Brendan Hansknecht</span> can answer me based on my last messages, because I'm probably missing something important</p>",
        "id": 305139048,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666268966
    },
    {
        "content": "<blockquote>\n<p>In my example, I have a typed as [Ok Str, Err Str]* which I understood being the same as \"I don't know which type of tag union this is, due to the * in it could be anything, but for sure if I encounter an Ok or Err tag they have a single value of type Str\".</p>\n</blockquote>\n<p>I think that's the difference, in roc this doesn't mean that this value might also have any other tag inside, I think it means that it is known that it's only either <code>Ok Str</code> or <code>Err Str</code> at this point, but it could be composed with other tags for a different value</p>",
        "id": 305139276,
        "sender_full_name": "Michał Łępicki",
        "timestamp": 1666269037
    },
    {
        "content": "<p>I guess a type itself doesn't constraint how a value of said type could be composed with some other values/types. The <code>*</code> there should mean it can be other things other than <code>Ok Str</code> and <code>Err Str</code>,  and I supposed you should cover that case in the <code>when</code>, as you do in the tutorial in <a href=\"https://github.com/roc-lang/roc/blob/main/TUTORIAL.md#open-and-closed-tag-unions\">this</a> first example</p>",
        "id": 305140180,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666269288
    },
    {
        "content": "<p>Which I thought being exactly my case, so requiring a catchall branch</p>",
        "id": 305140315,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666269332
    },
    {
        "content": "<p>Good point, so it's different for concrete values vs function parameters</p>",
        "id": 305143436,
        "sender_full_name": "Michał Łępicki",
        "timestamp": 1666270402
    },
    {
        "content": "<p>I'm guessing here, but after having reread the <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305011099\">answer</a> I've received above, I'm suspecting a thing:</p>\n<ul>\n<li>in the function argument example (the tutorial one) you're forcing your argument to be typed, since you're defining a signature. So the type checker doesn't have to \"guess\" what the argument type is, it's explicitly described in the function signature. So when you actually use it in the <code>when</code> you should cover all cases, which include the <code>*</code> case (\"catch all\")</li>\n<li>in my example, however, my value <code>a</code> has a type guessed by the type checker as <code>[Ok Str, Err Str]*</code> initially, but when I use it in the <code>when</code> expression inside my <code>b</code> value and since I'm defining only two cases, I'm actually restricting <code>a</code> to only be <code>[Ok Str, Err Str]</code> (so without <code>*</code>)</li>\n</ul>",
        "id": 305144561,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666270758
    },
    {
        "content": "<p>The only thing left for me to understand is: why should it be possible to restrict some value type if it doesn't affect the original value type?</p>\n<p>In my example, the two <code>a</code> used are actually the same <code>a</code>, the same value. If I'm using that in my <code>b</code> value and by doing so restricting it to only be <code>[Ok Str, Err Str]</code> (without <code>*</code>), my <code>a</code> value, outside <code>b</code> keep its initial type of <code>[Ok Str, Err Str]*</code>.</p>",
        "id": 305145440,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666271044
    },
    {
        "content": "<p>While I was expecting it to be considered <code>[Ok Str, Err Str]</code> everywhere else</p>",
        "id": 305145597,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666271094
    },
    {
        "content": "<p>I thought I understood but I agree with you, what is the type of <code>a</code> in this example, and why it works?</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"nx\">Ok</span><span class=\"w\"> </span><span class=\"s\">\"ok\"</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"nx\">Err</span><span class=\"w\"> </span><span class=\"s\">\"err\"</span><span class=\"w\"></span>\n<span class=\"nv\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">when</span><span class=\"w\"> </span><span class=\"nx\">a</span><span class=\"w\"> </span><span class=\"o\">is</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">Ok</span><span class=\"w\"> </span><span class=\"nx\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"yes\"</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">Err</span><span class=\"w\"> </span><span class=\"nx\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"no\"</span><span class=\"w\"></span>\n\n<span class=\"nv\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">when</span><span class=\"w\"> </span><span class=\"nx\">a</span><span class=\"w\"> </span><span class=\"o\">is</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">Ok</span><span class=\"w\"> </span><span class=\"nx\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"yes\"</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">Err</span><span class=\"w\"> </span><span class=\"nx\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"no\"</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"?\"</span><span class=\"w\"></span>\n\n<span class=\"nx\">Str</span><span class=\"p\">.</span><span class=\"nx\">concat</span><span class=\"w\"> </span><span class=\"nx\">b</span><span class=\"w\"> </span><span class=\"nx\">c</span><span class=\"w\"></span>\n\n<span class=\"c1\"># \"nono\" : Str</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 305147661,
        "sender_full_name": "Ghislain",
        "timestamp": 1666271754
    },
    {
        "content": "<p>Yeah cause in a mutable environment (so not Roc), you could change <code>a</code> value before using it in <code>b</code> and if type is not restricted (but it's only restricted within <code>b</code>), you could assign any other tag to <code>a</code>, causing <code>b</code> to crash at runtime. That is not the case, due to immutability, but still I'm not getting it</p>",
        "id": 305148164,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666271926
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"528453\">Ghislain</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305147661\">said</a>:</p>\n<blockquote>\n<p>I thought I understood but I agree with you, what is the type of <code>a</code> in this example, and why it works?</p>\n</blockquote>\n<p><code>a</code> still is <code>[Ok Str, Err Str]*</code> which is the more generic alternatives from the two. But why <code>b</code> type check? It should not in your example. Is it correctly working? Have you tried it in the repl?</p>",
        "id": 305148435,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666272021
    },
    {
        "content": "<p>yes, it works</p>",
        "id": 305148499,
        "sender_full_name": "Ghislain",
        "timestamp": 1666272050
    },
    {
        "content": "<p>Maybe the third \"catch all\" case in <code>c</code>, since <code>a</code> is already restricted by <code>b</code>, is redundant. It could be omitted. Maybe that would be a warning in the future. That would explain why <code>b</code> works, but this also implies <code>a</code> type being restricted actually, even if it doesn't seem to</p>",
        "id": 305148862,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666272186
    },
    {
        "content": "<p>Yeah, but I tried this:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nx\">Ok</span><span class=\"w\"> </span><span class=\"nx\">Str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">Err</span><span class=\"w\"> </span><span class=\"nx\">Str</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"w\"></span>\n\n<span class=\"nv\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">when</span><span class=\"w\"> </span><span class=\"nx\">a</span><span class=\"w\"> </span><span class=\"o\">is</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">Ok</span><span class=\"w\"> </span><span class=\"nx\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"yes\"</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">Err</span><span class=\"w\"> </span><span class=\"nx\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"no\"</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"?\"</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and it prints the redundancy:</p>\n<div class=\"codehilite\"><pre><span></span><code>The 3rd pattern is redundant:\n\n10│      c = when a is\n11│        Ok _ -&gt; &quot;yes&quot;\n12│        Err _ -&gt; &quot;no&quot;\n13│        _ -&gt; &quot;?&quot;\n           ^\n\nAny value of this shape will be handled by a previous pattern, so this\none should be removed.\n</code></pre></div>",
        "id": 305149166,
        "sender_full_name": "Ghislain",
        "timestamp": 1666272298
    },
    {
        "content": "<p>by the way I've encountered this right now while playing with it <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> :<br>\n<a href=\"/user_uploads/22008/2ULUGjtNCF4MTXKfsG089PJq/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/22008/2ULUGjtNCF4MTXKfsG089PJq/image.png\" title=\"image.png\"><img src=\"/user_uploads/22008/2ULUGjtNCF4MTXKfsG089PJq/image.png\"></a></div>",
        "id": 305149443,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666272381
    },
    {
        "content": "<p>I guess you have to provide an implementation for <code>a</code></p>",
        "id": 305149538,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666272408
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"528453\">Ghislain</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305149166\">said</a>:</p>\n<blockquote>\n<p>and it prints the redundancy:</p>\n<p><div class=\"codehilite\"><pre><span></span><code>The 3rd pattern is redundant:\n\n10│      c = when a is\n11│        Ok _ -&gt; &quot;yes&quot;\n12│        Err _ -&gt; &quot;no&quot;\n13│        _ -&gt; &quot;?&quot;\n           ^\n\nAny value of this shape will be handled by a previous pattern, so this\none should be removed.\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>That's strange to me :(</p>",
        "id": 305149645,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666272454
    },
    {
        "content": "<p><a href=\"/user_uploads/22008/-D2qUmz4r0HlKI18opHn2Ijl/image.png\">image.png</a> <br>\nthis explains why it's working, but also implies we're not getting it right</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/22008/-D2qUmz4r0HlKI18opHn2Ijl/image.png\" title=\"image.png\"><img src=\"/user_uploads/22008/-D2qUmz4r0HlKI18opHn2Ijl/image.png\"></a></div>",
        "id": 305150046,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666272591
    },
    {
        "content": "<p>the second point in the list</p>",
        "id": 305150119,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666272605
    },
    {
        "content": "<p>I'm not sure I should be able to type this:<br>\n<a href=\"/user_uploads/22008/hxK-D0h0prX2XwdsJkDYGXWC/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/22008/hxK-D0h0prX2XwdsJkDYGXWC/image.png\" title=\"image.png\"><img src=\"/user_uploads/22008/hxK-D0h0prX2XwdsJkDYGXWC/image.png\"></a></div>",
        "id": 305151712,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666273120
    },
    {
        "content": "<p>Maybe something interesting is the output of this <code>expect</code>:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nx\">expect</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nv\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"nx\">Ok</span><span class=\"w\"> </span><span class=\"s\">\"ok\"</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"nx\">Err</span><span class=\"w\"> </span><span class=\"s\">\"err\"</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"nx\">b</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"nx\">b</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\"><pre><span></span><code>b : [Err Str, Ok Str]a\nb = Err &quot;err&quot;\n</code></pre></div>\n<p>it doesn't give <code>[Err Str, Ok Str]*</code>, though I don't exactly understand the difference yet</p>",
        "id": 305152206,
        "sender_full_name": "Ghislain",
        "timestamp": 1666273280
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"528453\">Ghislain</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305152206\">said</a>:</p>\n<blockquote>\n<p>it doesn't give <code>[Err Str, Ok Str]*</code>, though I don't exactly understand the difference yet</p>\n</blockquote>\n<p>The difference should be naming, so that you can refer to \"whatever more there is\" as <code>a</code> when composing tag types, but if it's not used anywhere else it should basically be equivalent as saying <code>*</code> there, cause you're not forcing <code>a</code> to be something appearing somewhere else.</p>",
        "id": 305152551,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666273411
    },
    {
        "content": "<p>Like assigning <code>*</code> to a named type variable <code>a</code> you can use in other points</p>",
        "id": 305152697,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666273452
    },
    {
        "content": "<p>Ok this explains why it's working:<br>\n<a href=\"/user_uploads/22008/qQr9u2xOf9YIMzk1j2dwSV7H/image.png\">image.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/22008/qQr9u2xOf9YIMzk1j2dwSV7H/image.png\" title=\"image.png\"><img src=\"/user_uploads/22008/qQr9u2xOf9YIMzk1j2dwSV7H/image.png\"></a></div><p>At least counterintuitively for me, what is happening here is that the <code>*</code> bit doesn't allow the value you're assigning to be anything else different than what the original tag union is. It's basically only useful when used as a type parameter in functions.</p>\n<p>Even if you use it in function return types as in:</p>\n<div class=\"codehilite\"><pre><span></span><code>c : {} -&gt; [Ok Str]*\n</code></pre></div>\n<p>You're forced to return a tag called <code>Ok</code> with a value <code>Str</code>. You can't return <code>Err \"err\"</code> from <code>c</code></p>",
        "id": 305154966,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666274064
    },
    {
        "content": "<p>That's what you would get:<br>\n<a href=\"/user_uploads/22008/Uvf5VaRJEjhvH7NjS9axeRZN/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/22008/Uvf5VaRJEjhvH7NjS9axeRZN/image.png\" title=\"image.png\"><img src=\"/user_uploads/22008/Uvf5VaRJEjhvH7NjS9axeRZN/image.png\"></a></div>",
        "id": 305155064,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666274100
    },
    {
        "content": "<p>I am not sure how helpful this will be, but something that helps me is to remember that when all things are said and done, open tags like <code>[Ok Str, Err Str]*</code> no longer exist. The final output machine code will only ever specify closed tag types and values.</p>\n<p>What is <code>a</code> in this example?</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"nx\">Ok</span><span class=\"w\"> </span><span class=\"s\">\"ok\"</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"nx\">Err</span><span class=\"w\"> </span><span class=\"s\">\"err\"</span><span class=\"w\"></span>\n<span class=\"nv\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">when</span><span class=\"w\"> </span><span class=\"nx\">a</span><span class=\"w\"> </span><span class=\"o\">is</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">Ok</span><span class=\"w\"> </span><span class=\"nx\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"yes\"</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">Err</span><span class=\"w\"> </span><span class=\"nx\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"no\"</span><span class=\"w\"></span>\n\n<span class=\"nv\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">when</span><span class=\"w\"> </span><span class=\"nx\">a</span><span class=\"w\"> </span><span class=\"o\">is</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">Ok</span><span class=\"w\"> </span><span class=\"nx\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"yes\"</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">Err</span><span class=\"w\"> </span><span class=\"nx\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"no\"</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"?\"</span><span class=\"w\"></span>\n\n<span class=\"nx\">Str</span><span class=\"p\">.</span><span class=\"nx\">concat</span><span class=\"w\"> </span><span class=\"nx\">b</span><span class=\"w\"> </span><span class=\"nx\">c</span><span class=\"w\"></span>\n\n<span class=\"c1\"># \"nono\" : Str</span><span class=\"w\"></span>\n</code></pre></div>\n<p><code>a</code> is a tag that has 2 possible variants. The first variant, <code>Err Str</code> has a tag of 0 and contains a <code>Str</code>. The second variant, <code>Ok Str</code> has a tag of 1 and contains a <code>Str</code>. The physical layout in memory is essentially <code>{ value: Str, tag: bool }</code>. Once types are finalized for the whole program and it is being turned to machine code, there is no possiblity for <code>a</code> to be anything except <code>Err Str</code> or <code>Ok Str</code>.</p>",
        "id": 305159040,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666275325
    },
    {
        "content": "<p>As such, the <code>_ -&gt; \"?\"</code> is literally impossible.</p>",
        "id": 305159354,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666275425
    },
    {
        "content": "<p>Yeah that is simple to reason about. What doesn't help is seeing <code>a</code> typed <code>[Ok Str, Err Str]*</code> from the compiler/type checker/repl. This way your convincing me <code>*</code> could be used when declaring things as a placeholder for <code>this tag could be anything</code> which is not the case.</p>",
        "id": 305159678,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666275526
    },
    {
        "content": "<p>The <code>*</code> is only helpful when accepting something in a more open/wide way, as in function arguments.</p>",
        "id": 305159736,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666275544
    },
    {
        "content": "<p>As I'm understanding it</p>",
        "id": 305159782,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666275561
    },
    {
        "content": "<p>In fact this is an error:<br>\n<a href=\"/user_uploads/22008/DxND71wgr_FfIjnJPjtsZwpw/image.png\">image.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/22008/DxND71wgr_FfIjnJPjtsZwpw/image.png\" title=\"image.png\"><img src=\"/user_uploads/22008/DxND71wgr_FfIjnJPjtsZwpw/image.png\"></a></div><p>And it's counterintuitive for me :)</p>",
        "id": 305160385,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666275735
    },
    {
        "content": "<p>Should this fail like this?<br>\n<a href=\"/user_uploads/22008/x4wrd3M9j1NhCJIawnfQuwwR/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/22008/x4wrd3M9j1NhCJIawnfQuwwR/image.png\" title=\"image.png\"><img src=\"/user_uploads/22008/x4wrd3M9j1NhCJIawnfQuwwR/image.png\"></a></div>",
        "id": 305160560,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666275797
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305012901\">said</a>:</p>\n<blockquote>\n<p>in the first, <code>a</code> would have the type <code>[ Ok Str, Err Str ]*</code>.<br>\nIn the second, <code>a</code> would have the type <code>[ Ok Str, Err Str, LastConcrete ]</code>.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"343810\">@Brendan Hansknecht</span> As I understand what you just said, <code>a</code> would still have the same type <code>[Ok Str, Err Str]*</code> (the <code>when</code> would have no responsibility over the <code>a</code> type)</p>",
        "id": 305162300,
        "sender_full_name": "Ghislain",
        "timestamp": 1666276238
    },
    {
        "content": "<p>I think the main confusion about open tags comes from them acting differently depending on context. These is seen most easily with function arguments and return values.</p>\n<p>^^ yeah, noting star mosly mattering in function arguments is very correct. Though it also maters in return types.</p>\n<p>When handling a function argument, you always need to deal with the <code>_</code> case if it is an open union. This is because a function parameter is not concrete. It is a value that will change on each call. In the end we still have to generate concrete types, but we can't analyze locally and do that.</p>\n<p>When you see:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"w\"> </span><span class=\"nx\">Ok</span><span class=\"w\"> </span><span class=\"nx\">Str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">Err</span><span class=\"w\"> </span><span class=\"nx\">Str</span><span class=\"w\"> </span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nx\">Str</span><span class=\"w\"></span>\n<span class=\"nv\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"nx\">x</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">when</span><span class=\"w\"> </span><span class=\"nx\">x</span><span class=\"w\"> </span><span class=\"o\">is</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">Ok</span><span class=\"w\"> </span><span class=\"nx\">str</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nx\">str</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">Err</span><span class=\"w\"> </span><span class=\"nx\">str</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nx\">str</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"?\"</span><span class=\"w\"></span>\n\n<span class=\"nv\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nx\">Apple</span><span class=\"w\"></span>\n<span class=\"nx\">f</span><span class=\"w\"> </span><span class=\"nx\">c</span><span class=\"w\"></span>\n</code></pre></div>\n<p>what is the concrete type of <code>x</code>? The actual value that is generated by the call <code>f c</code>.<br>\nIt is a tag with 3 variants:</p>\n<ol>\n<li><code>Apple</code> with tag 0 and no value</li>\n<li><code>Err</code> with tag 1 and a value of <code>Str</code></li>\n<li><code>Str</code> with tag 2 and a value of <code>Str</code></li>\n</ol>\n<p>So the in hardware representation is essentially <code>{ value: Str, tag: U8 }</code>, and in the case of <code>Apple</code>, the <code>value</code> is empty and the <code>tag</code> is 0.</p>",
        "id": 305162523,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666276275
    },
    {
        "content": "<p>I'm getting the why and how of open/closed tags now, but it's still confusing how <code>*</code> change importance in different contexts</p>",
        "id": 305164220,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666276599
    },
    {
        "content": "<p>Have you looked at the repl examples I've shown above? <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305160385\">here</a></p>",
        "id": 305164382,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666276641
    },
    {
        "content": "<p>This is counterintuitive at least :)</p>",
        "id": 305164435,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666276657
    },
    {
        "content": "<p>The same goes for <code>List *</code> or wherever you use <code>*</code></p>",
        "id": 305164519,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666276679
    },
    {
        "content": "<p>I get like when creating values directly without using functions it doesn't really make sense to use <code>*</code> in the first place, in fact the type checker errors out and advice you to narrow the type or generalize the value</p>",
        "id": 305164716,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666276729
    },
    {
        "content": "<p>but still, it's confusing :D</p>",
        "id": 305164764,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666276742
    },
    {
        "content": "<p>Now switching to the return case. An important part of a returned tag union is that it is allowed to grow. As such, you might start with <code>[ Ok Str, Err Str ]*</code> and end with <code>[ Ok Str, Err Str, Apple ]</code>.</p>\n<p>another example:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"c1\"># let's just pretend this function is defined:</span><span class=\"w\"></span>\n<span class=\"nv\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">Str</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nx\">Ok</span><span class=\"w\"> </span><span class=\"nx\">Str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">Err</span><span class=\"w\"> </span><span class=\"nx\">Str</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"w\"></span>\n\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"nx\">someBool</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"nx\">f</span><span class=\"w\"> </span><span class=\"s\">\"yay!\"</span><span class=\"w\"></span>\n<span class=\"k\">else</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"nx\">Apple</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This generates the same concrete tag as above. As such, the generated code from <code>f</code> has to be modified. If <code>f</code> were to just generate <code>[Ok Str, Err Str]</code>, <code>Err</code> would have a tag of 10. This would end up leading to a conflict with <code>Apple</code>, which has a tag of 0 in the final tag. As such, the final output type of <code>f</code> is <code>[ Apple, Err Str, Ok Str ]</code>. Though it will only ever generate the <code>Err</code> or <code>Ok</code> case, it has to generate them with a new tag due to the tag union expanding to include <code>Apple</code>.</p>",
        "id": 305165308,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666276885
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"556413\">Kristian Notari</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305164382\">said</a>:</p>\n<blockquote>\n<p>Have you looked at the repl examples I've shown above? <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305160385\">here</a></p>\n</blockquote>\n<p>So we talked about changing the name at some point to growing tag union instead of open. <code>*</code>/<code>[]*</code> really means the current definition of this tag contains no variants, but later it can grow to contain variants. So <code>[Ok, Err]*</code> means. The current tag can either be an <code>Ok</code> or <code>Err</code> variant with the capability to eventually grow to hold other variants.</p>",
        "id": 305166000,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666277066
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305165308\">said</a>:</p>\n<p>Why should the writer of the function <code>f</code> be responsible to open that for you? If the function <code>f</code> only return <code>Ok</code> or <code>Err</code> it should say so in the signature as the return type. What I want to do with that return value after calling <code>f</code> should be caller's responsibility. Is that done for performance reasons only?</p>",
        "id": 305166408,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666277183
    },
    {
        "content": "<p>I get the importance of preserving open tags when accepting them and when you need to return them (after modifying them for example, so they're linked to the argument type), but I'm not getting why I should bother as a function writer how callers will \"union\" tags in the future, after the call to my function</p>",
        "id": 305166599,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666277248
    },
    {
        "content": "<p>If I define <code>Color : [ Red, Green, Blue ]</code>. And have a function <code>f : Str -&gt; Result Color [ NotAColor ]*</code>, I am intentionally constraining the caller of this function. I am telling them that I know all possible colors. You can not take my color and merge it with some other list of colors. You only get red, green, or blue. At the same time, I am leaving the error type open to the user. I am telling them that I might give them a <code>NotAColor</code> error, but they might have tons of other errors they also want to handle.</p>",
        "id": 305167256,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666277447
    },
    {
        "content": "<p>That enables my color to be passed into my other function <code>draw : Shape, Position, Color -&gt; Drawing</code>. If instead I returned a <code>[ Red, Green, Blue ]*</code>, the user would have to match on it and then constrain the result to <code>[ Red, Green, Blue ]</code> before they could pass it to <code>draw</code>. I don't want that tag to expand. It is inconvenient to both myself and the user.</p>",
        "id": 305167888,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666277634
    },
    {
        "content": "<p>Also, I guess it technically isn't important for performance, we could force all functions to always return open tags. That would not hurt performance, but it would make programming less convenient.</p>",
        "id": 305168216,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666277724
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"528453\">@Ghislain</span>, can you be more specific with this comment: <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305162300\">https://roc.zulipchat.com/#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305162300</a></p>",
        "id": 305168848,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666277884
    },
    {
        "content": "<p>Yes, I tried your code (hope that the function doesn't change the behavior, <code>expect</code> doesn't seem to like <code>when</code> in it)</p>\n<div class=\"codehilite\" data-code-language=\"Elm\"><pre><span></span><code><span class=\"nv\">fn</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"nv\">v</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nv\">when</span><span class=\"w\"> </span><span class=\"nv\">v</span><span class=\"w\"> </span><span class=\"nv\">is</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kt\">Ok</span><span class=\"w\"> </span><span class=\"nv\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"yes\"</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kt\">Err</span><span class=\"w\"> </span><span class=\"nv\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"no\"</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kt\">LastConcrete</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"That other concrete tag\"</span><span class=\"w\"></span>\n\n<span class=\"nv\">expect</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nv\">a</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"nf\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"kr\">then</span><span class=\"w\"> </span><span class=\"kt\">Ok</span><span class=\"w\"> </span><span class=\"s\">\"ok\"</span><span class=\"w\"> </span><span class=\"kr\">else</span><span class=\"w\"> </span><span class=\"kt\">Err</span><span class=\"w\"> </span><span class=\"s\">\"err\"</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"nv\">fn</span><span class=\"w\"> </span><span class=\"nv\">a</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"err\">!</span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">fn</span><span class=\"w\"> </span><span class=\"nv\">a</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and it gives:</p>\n<div class=\"codehilite\"><pre><span></span><code>a : [Err Str, Ok Str]a\na = Err &quot;err&quot;\n</code></pre></div>",
        "id": 305169952,
        "sender_full_name": "Ghislain",
        "timestamp": 1666278164
    },
    {
        "content": "<p>Ah, i guess when I talked up above i was also, trying to give the \"concrete\" type that the actual compiled binary would see. Technically the type of <code>a</code> doesn't exactly change. <code>a</code> is a <code>[Err Str, Ok Str]b</code> (used <code>b</code> to avoid confusion below)</p>\n<p>What does actually change is <code>b</code>. In your example, <code>b</code> is <code>[ LastConcrete ]</code>, leading to a final \"concrete\" type of <code>[Err Str, LastConcrete, Ok Str]</code>.</p>",
        "id": 305171040,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666278476
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305167888\">said</a>:</p>\n<blockquote>\n<p>That enables my color to be passed into my other function <code>draw : Shape, Position, Color -&gt; Drawing</code>. If instead I returned a <code>[ Red, Green, Blue ]*</code>, the user would have to match on it and then constrain the result to <code>[ Red, Green, Blue ]</code> before they could pass it to <code>draw</code>. I don't want that tag to expand. It is inconvenient to both myself and the user.</p>\n</blockquote>\n<p>I get it but that's not how it works in other languages and it's confusing me on the reasons why this is needed. If I say my <code>f</code> function return a <code>Color</code> and the caller needs <code>Color</code> to use it in other functions, if it uses a color based on the value returned by:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"c1\"># let's just pretend this function is defined</span><span class=\"w\"></span>\n<span class=\"nv\">Color</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"w\"> </span><span class=\"nx\">Red</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">Green</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">Blue</span><span class=\"w\"> </span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"nv\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">Str</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nx\">Color</span><span class=\"w\"></span>\n\n<span class=\"c1\"># I expect myColor to be [Purple]Color</span><span class=\"w\"></span>\n<span class=\"nv\">myColor</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"nx\">Bool</span><span class=\"p\">.</span><span class=\"nx\">true</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"nx\">f</span><span class=\"w\"> </span><span class=\"s\">\"yay\"</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"nx\">Purple</span><span class=\"w\"></span>\n</code></pre></div>\n<p>That automatically gives him a type error when he tries to call:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nx\">draw</span><span class=\"w\"> </span><span class=\"nx\">shape</span><span class=\"w\"> </span><span class=\"nx\">position</span><span class=\"w\"> </span><span class=\"nx\">myColor</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Cause <code>myColor</code> is not assignable to <code>Color</code>. I don't need to \"help\" the caller or constraint the caller. Signatures says that already.</p>",
        "id": 305171534,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666278577
    },
    {
        "content": "<p>While open/close concept on tags and records is useful when accepting stuff or when linking accepted stuff to returning stuff, in the case of <code>f</code> having the ability to constrain the tag union returned by the function so that the caller can't mess with it, it's confusing for me and I'm not getting why it's a feature</p>",
        "id": 305171848,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666278662
    },
    {
        "content": "<p>Interesting. I come from lower level languages where the default is constrained and there are no other options. An enum is defined once and has no flexibility. As such, defaulting to constrained makes a lot of sense to me. Have never thought about it the way you are mentioning.</p>",
        "id": 305172225,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666278760
    },
    {
        "content": "<p>What is a language that does what you mentioned and also has a static type system?</p>",
        "id": 305172365,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666278798
    },
    {
        "content": "<p>I found that open unions can cause weird inference sometimes, so I appreciate that closed unions exist. Here I see no reason why I would need to handle <code>A</code> in <code>bar</code>, other than open unions weirdness:</p>\n<div class=\"codehilite\"><pre><span></span><code>» foo = \\a -&gt;\n…   when a is\n…     A x -&gt; B x\n…     y -&gt; y\n…\n… bar =\n…   when foo C is\n…     B _ -&gt; &quot;ok&quot;\n…     C -&gt; &quot;ok&quot;\n… bar\n\n── UNSAFE PATTERN ──────────────────────────────────────────────────────────────\n\nThis when does not cover all the possibilities:\n\n10│&gt;        when foo C is\n11│&gt;          B _ -&gt; &quot;ok&quot;\n12│&gt;          C -&gt; &quot;ok&quot;\n\nOther possibilities include:\n\n    A _\n    _\n\nI would have to crash if I saw one of those! Add branches for them!\n</code></pre></div>",
        "id": 305172932,
        "sender_full_name": "Michał Łępicki",
        "timestamp": 1666278956
    },
    {
        "content": "<p>As an aside, open tags can have a cost in terms of generated assembly bloat and memory bloat, that said, without silly mistakes, I would expect this cost generally be zero.</p>",
        "id": 305173165,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666279015
    },
    {
        "content": "<blockquote>\n<p>Here I see no reason why I would need to handle A in bar, other than open unions weirdness</p>\n</blockquote>\n<p>(That said I also wouldn't be able to write this code with closed unions, and I didn't find other weird behavior yet)</p>",
        "id": 305174286,
        "sender_full_name": "Michał Łępicki",
        "timestamp": 1666279340
    },
    {
        "content": "<p>The weirdness is because the input tag and the output tag have to be the same type. This is because <code>y -&gt; y</code> (it is a no-op, we don't re-layout the tag). As such, if the input type can have an <code>A</code> variant, it means the output can theoretically have an <code>A</code> variant. Also, if the input can have any tag, so can the output.</p>\n<p>It's kinda as if you wrote: <code>f : Str -&gt; [ Red, Green, Blue ]</code>, but <code>f</code> only ever returns the <code>Green</code> variant. Even though <code>f</code> will only ever be <code>Green</code>, you still need to match on <code>Red</code> and <code>Blue</code> when using the result of <code>f</code>.</p>",
        "id": 305175402,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666279649
    },
    {
        "content": "<p>I think e.g. Typescript might do better with examples like this because they do flow typing? (I think it's more work for the compiler but I don't know much about it)</p>",
        "id": 305176793,
        "sender_full_name": "Michał Łępicki",
        "timestamp": 1666279977
    },
    {
        "content": "<p>Following the logic: for <code>A</code> the return type is <code>B</code>, for <code>[]* \\ A</code> (anything but <code>A</code>) return type is the same, then combine the branches so the type is <code>[]* -&gt; [B]* \\ A</code><br>\nBut that seems a bit offtopic already, sorry about that</p>",
        "id": 305177717,
        "sender_full_name": "Michał Łępicki",
        "timestamp": 1666280200
    },
    {
        "content": "<p>Yeah, we don't do any \"negative\" types. I'm not exactly sure what to call them.</p>",
        "id": 305178114,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666280301
    },
    {
        "content": "<p>Where it can be any value except something</p>",
        "id": 305178182,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666280320
    },
    {
        "content": "<p>So it is reducing the scope of variants a variable could be.</p>",
        "id": 305178221,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666280330
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"543952\">Michał Łępicki</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305176793\">said</a>:</p>\n<blockquote>\n<p>I think e.g. Typescript might do better with examples like this because they do flow typing? (I think it's more work for the compiler but I don't know much about it)</p>\n</blockquote>\n<p>That's the background I'm coming from and that's why it sounds confusing reasoning about types as it is in Roc</p>",
        "id": 305181357,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666281304
    },
    {
        "content": "<p>Both for \"excluding\" subtypes from types and both for the <code>*</code> context sensitive utility</p>",
        "id": 305181448,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666281332
    },
    {
        "content": "<p>But still, I'm not getting why not to go for something like typescript and rule out things like <code>y -&gt; y</code> with better types or accept things like:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"></span>\n<span class=\"nv\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nx\">Ok</span><span class=\"w\"> </span><span class=\"s\">\"ok\"</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Apart from performance, I don't see the reasons why. Maybe they are good reasons, but I'm curious to know them</p>",
        "id": 305181727,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666281418
    },
    {
        "content": "<p>At a minimum, it would make the compiler more complex and slower, it would have to figure out the underlying concrete type and the possible variants the type could take. So that is more information to collect and propagate. That said, I don't really know the answer. Hopefully someone with more type system knowledge can jump in and expand the explanation.</p>",
        "id": 305183147,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666281810
    },
    {
        "content": "<p>This is going to be a long message, but I hope it will provide more context on how and why this works in Roc. It's a question we get pretty often and a story we've been trying to figure out how to make better, through documentation and/or language changes.</p>\n<p>In rough, I'll try to provide an intuition for how these tags work, why they are useful in applications, and why things are this way - in particular, why not switch to subtyping? Then I'll show one experiment we are considering.</p>\n<h1>Intuition</h1>\n<h2>Basic example, with TypeScript analogies</h2>\n<p>Okay, so the first thing to keep in mind is that Roc does not have subtyping. That means that a value of type <code>A</code> cannot be used where a value of type <code>[A, B]</code> is expected, unlike in e.g. TypeScript, where <code>A</code> can be passed to a function that expects <code>A|B</code>. We'll get to why Roc doesn't have subtyping later, but was this means from an intuition, is that if you try to use a tag union value given as the result of a function, your use must match the returned value <strong>exactly</strong>.</p>\n<p>This means if I have a function</p>\n<div class=\"codehilite\"><pre><span></span><code>openFile : Str -&gt; Result File [OpenFileError ...]\nwriteFile : File, Str -&gt; Result {} [WriteFileError ...]\n\nopenAndWrite : Str, Str -&gt; Result {} [OpenFileError ..., WriteFileError ...]\nopenAndWrite = \\file, content -&gt;\n  when openFile file is\n    Ok f -&gt; writeFile f content\n    Err e -&gt; Err e\n</code></pre></div>\n<p>This does not compile, because despite <code>[OpenFileError ...]</code> (and <code>[WriteFileError ...]</code>) \"fitting\" into <code>[OpenFileError ..., WriteFileError ...]</code> from a subtyping perspective, that is not how Roc does things - because these types do not match exactly, they are not equal. Again, it is a very reasonable question why things cannot be done that way, and I'll elaborate that later on.</p>\n<p>So, where did things go wrong here? The key insight is that our functions <code>openFile</code> and <code>writeFile</code> enumerate the failure cases they might produce, but the <strong>context</strong> those failures are used in is determined only by the user of those functions! Roc enables authors to enumerate variant cases while providing callers flexibility in <em>how</em> they can use those cases via open tag unions.</p>\n<p>I think it may be helpful to look at analogous example in TypeScript here. We can write the following program:</p>\n<div class=\"codehilite\"><pre><span></span><code>interface OpenFileError { ... }\ninterface WriteFileError { ... }\ntype Result&lt;Ok, Err&gt; = ...\n\nfunction openFile&lt;T&gt;(fileName: string) -&gt; Result&lt;File, OpenFileError | T&gt; { ... }\nfunction writeFile&lt;T&gt;(file: File, content: string) -&gt; Result&lt;File, WriteFileError | T&gt; { ... }\n</code></pre></div>\n<p>I hope this might explain more of what's going on - as you can see, <code>T</code> is not useful for anything except for defining the type expected by the caller of that function! Now of course, this might seem totally useless in TypeScript, since <code>OpenFileError</code> always fits into <code>OpenFileError | T</code>, for any <code>T</code>. But I hope you can see that in cases like Roc's, where <code>OpenFileError</code> can be used as <code>OpenFileError | T</code> only if <code>T = []</code>, and otherwise the return value must be exactly <code>OpenFileError | T</code>, this can be useful.</p>\n<p>So, this now corresponds to the Roc program</p>\n<div class=\"codehilite\"><pre><span></span><code>openFile : Str -&gt; Result File [OpenFileError ...]*\nwriteFile : File, Str -&gt; Result {} [WriteFileError ...]*\n</code></pre></div>\n<p>where the TypeScript type parameter <code>&lt;T&gt;</code> is Roc's <code>*</code> here.</p>\n<p>The usage</p>\n<div class=\"codehilite\"><pre><span></span><code>openAndWrite : Str, Str -&gt; Result {} [OpenFileError ..., WriteFileError ...]\nopenAndWrite = \\file, content -&gt;\n  when openFile file is\n    Ok f -&gt; writeFile f content\n    Err e -&gt; Err e\n</code></pre></div>\n<p>from before now compiles, because the Roc compiler will effectively see \"oh, I need to create a <code>openFile</code> where <code>* = WriteFileError</code>\", and generate a specialization of openFile that has exactly the type signature</p>\n<div class=\"codehilite\"><pre><span></span><code>openFile : Str -&gt; Result File [OpenFileError ..., WriteFileError ...]\n</code></pre></div>\n<p>which will be the version used in <code>openAndWrite</code>. That's analogous to instantiating </p>\n<div class=\"codehilite\"><pre><span></span><code>function openFile&lt;T&gt;(fileName: string) -&gt; Result&lt;File, OpenFileError | T&gt; { ... }\n</code></pre></div>\n<p>with a concrete <code>T = WriteFileError</code> to produce a function</p>\n<div class=\"codehilite\"><pre><span></span><code>function openFile(fileName: string) -&gt; Result&lt;File, OpenFileError | WriteFileError&gt; { ... }\n</code></pre></div>\n<h2>Non-function values can be used contextually</h2>\n<p>So, I hope the ethos of \"allow users of a value decide the context it can be used in\" makes sense at this point. I'd like to show how this extends to literal/non-function values as well, since that often trips folks up.</p>\n<p>I think it's good to start with numbers.</p>\n<div class=\"codehilite\"><pre><span></span><code>n : Num *\nn = 1\n</code></pre></div>\n<p>I think this is more intuitive than open tag unions, but the idea is the same - what exactly <code>n</code> is, from a raw-bytes-on-the-machine perspective, isn't determined until you use it in a particular way that resolves it to a concrete type - for example, pass it to a function that expects a U64, or an F32, or something else.</p>\n<p>And this means that you can use <code>n</code> in multiple contexts that you like, because the definer of <code>n</code> gave you the freedom to do so! For example, the following works just fine:</p>\n<div class=\"codehilite\"><pre><span></span><code>n = Num *\nn = 1\n\nrcd : {a : U64, b : F32}\nrcd = {a: n, b: n}\n</code></pre></div>\n<p>The same principle extends to tag unions. I can do something like</p>\n<div class=\"codehilite\"><pre><span></span><code>purple : [Purple]*\npurple = Purple\n\nPastel : [Purple, Pink, Creme]\nDeep : [Purple, DarkBlue, Indigo]\n\nrcd : {pastel: Pastel, deep: Deep}\nrcd = {pastel: purple, deep: purple}\n</code></pre></div>\n<p>You could think of <code>purple : [Purple]*</code> as the TypeScript type signature <code>const purple&lt;T&gt;: Purple|&lt;T&gt;</code>, if TypeScript allowed you to say something like that!</p>\n<p>This might seem contrived, and usually, it is - much more so than allowing callers of functions to use return values in any context they like. It used to be important when Roc's booleans were not an opaque type, and were instead the tags <code>[True, False]</code>. You could write programs like</p>\n<div class=\"codehilite\"><pre><span></span><code>flag = True\n\nif flag then foo {} else bar {}\n</code></pre></div>\n<p>Now, if the type of <code>flag</code> was only <code>[True]</code>, it could not be used in the context <code>[True, False]</code> in the \"if\" statement. By making it <code>[True]*</code>, you add a type variable that tells the compiler \"hey compiler, this is a True value, but allow people to use it any context they like\", and the compiler can then make that particular usage exactly <code>[True, False]</code>.</p>\n<h2>Why can't <code>*</code> capture everything?</h2>\n<p>Finally, let's take a look at the example</p>\n<div class=\"codehilite\"><pre><span></span><code>foo : {} -&gt; [A]*\nfoo = \\{} -&gt; B\n</code></pre></div>\n<p>Maybe you already understand now why this does not type check, but if not, the key to remember here is that <code>*</code> does not add information to the type, and it does not mean \"this tag can be anything else\". It means, \"allow this value to be used in any context that includes itself, or anything more\". So, <code>foo</code>'s API contract is \"I produce an A, and you can use that A in any larger context\". But the contract is a lie, because it actually produces a B!</p>\n<p>This would be analogous to the TypeScript</p>\n<div class=\"codehilite\"><pre><span></span><code>interface A {a: &quot;&quot;}\ninterface B {b : &quot;&quot;}\n\nfunction f&lt;T&gt;() : A | T {\n    return {b: &quot;&quot;}\n}\n</code></pre></div>\n<p>which also does not typecheck, for the same reason. Or even more directly,</p>\n<div class=\"codehilite\"><pre><span></span><code>function f&lt;T&gt;() : number | T {\n    return &quot;&quot;\n}\n</code></pre></div>\n<h1>Why doesn't Roc use subtyping?</h1>\n<p>I won't bore you with the details here, I (and I'm sure others) would be happy to elaborate more to anyone who is interested, but the TLDR is that Roc's model of compiling to efficient, boxed representations of types would break down if Roc used subtyping a-la TypeScript's subtyping. The easiest way to think about this is that with the program</p>\n<div class=\"codehilite\"><pre><span></span><code>openFile : Str -&gt; Result File [OpenFileError ...]*\nwriteFile : File, Str -&gt; Result {} [WriteFileError ...]*\n\nopenAndWrite : Str, Str -&gt; Result {} [OpenFileError ..., WriteFileError ...]\nopenAndWrite = \\file, content -&gt;\n  when openFile file is\n    Ok f -&gt; writeFile f content\n    Err e -&gt; Err e\n</code></pre></div>\n<p>after the type checker figures out how the <code>*</code>s should be instantiated with a concrete type, based on the contextual usages in <code>openAndWrite</code>, we end up with the program</p>\n<div class=\"codehilite\"><pre><span></span><code>openFile : Str -&gt; Result File [OpenFileError ..., WriteFileError ...]\nwriteFile : File, Str -&gt; Result {} [OpenFileError ..., WriteFileError ...]\n\nopenAndWrite : Str, Str -&gt; Result {} [OpenFileError ..., WriteFileError ...]\nopenAndWrite = \\file, content -&gt;\n  when openFile file is\n    Ok f -&gt; writeFile f content   # no conversion needed here!!\n    Err e -&gt; Err e  # no conversion needed here!!\n</code></pre></div>\n<p>And notice in the two branches, we don't need to do any conversions at all to pass the values through with the same types - since they are exactly the same type, they will have exactly the same underlying byte representation on the machine, and can be transparently passed through.</p>\n<p>With how Roc compiles code, the same would not be true if we allowed</p>\n<div class=\"codehilite\"><pre><span></span><code>openFile : Str -&gt; Result File [OpenFileError ...]\nwriteFile : File, Str -&gt; Result {} [WriteFileError ...]\n\nopenAndWrite : Str, Str -&gt; Result {} [OpenFileError ..., WriteFileError ...]\nopenAndWrite = \\file, content -&gt;\n  when openFile file is\n    Ok f -&gt; writeFile f content   # uh-oh, how do I convert?\n    Err e -&gt; Err e  # uh-oh, how do I convert?\n</code></pre></div>\n<p>Now, the types returned from <code>openFile</code> and <code>writeFile</code> are not the same types as they are used in <code>openAndWrite</code>, and so the underlying representation (as it is today) would not be the same. The Roc compiler would have only a few options here:</p>\n<ul>\n<li>Make all values have a uniform representation at runtime (this works, but is very bad for performance!)</li>\n<li>Add implicit conversions to and from everywhere. This is doable, but takes a very very big toll on the compiler's memory usage and compile time, and actually can be undecidable in some instances. So it is not a tradeoff made today!</li>\n</ul>\n<p>I hope that provided a baseline idea of why Roc doesn't use subtyping today, but happy to elaborate more.</p>\n<h1>Can tags be more intuitive.</h1>\n<p>Maybe! We'd like to think so. One idea is that we should always make tag unions open in \"output position\", i.e. when returned by a function, and always allow the user to determine the context they are used in. Here's a playground of what that would look like: <a href=\"https://ayazhafiz.com/plts/playground/cor/easy_tags\">https://ayazhafiz.com/plts/playground/cor/easy_tags</a>, feedback welcome!</p>",
        "id": 305368504,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666362540
    },
    {
        "content": "<p>Hit 9985 chars of the 10000 chars limit there <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> and apparently it can't be edited. Edits:</p>\n<ul>\n<li>Roc compiles to efficient, <strong>un</strong>boxed runtime representations</li>\n</ul>",
        "id": 305368587,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666362570
    },
    {
        "content": "<p>First of all, thanks for taking the time to answer my doubts.</p>\n<p>I've understood the performance reasons behind, the typescript analogies (so how they relate with Roc code as you described) and the subtyping stuff. I'm not getting the lines like:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"454654\">Ayaz Hafiz</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305368504\">said</a>:</p>\n<blockquote>\n<p>So, where did things go wrong here? The key insight is that our functions <code>openFile</code> and <code>writeFile</code> enumerate the failure cases they might produce, but the <strong>context</strong> those failures are used in is determined only by the user of those functions! Roc enables authors to enumerate variant cases while providing callers flexibility in how they can use those cases via open tag unions.</p>\n</blockquote>\n<p>where I assume there's also some \"usability\" reason behind the choice.</p>",
        "id": 305374132,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666364188
    },
    {
        "content": "<p>I mean, I'm not seeing why I, as a library developer, should choose to return closed tag unions, which basically limit what my caller could do with that value</p>",
        "id": 305375058,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666364475
    },
    {
        "content": "<p>Yeah, I don’t think you ever would want to! That’s why open tag unions are useful, to let the caller decide how exactly they want to use it. And it’s the subject of the experiment I mentioned at the bottom, where we can make it so that you cannot say that a tag union is closed if it appears as the return value of a function.</p>",
        "id": 305375430,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666364588
    },
    {
        "content": "<p>Because, from what I've understood, if the return tags were to always be open, they are then implemented, after compilation, depending on how you've used those within your code. So if you only use those for what they are, without ever unioning them with other tags, performance wise that's the same as having closed tags in the first place.</p>",
        "id": 305375456,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666364594
    },
    {
        "content": "<p>Yes exactly. Open tag unions are never a thing at runtime, just like “&lt;T&gt;” type parameters are never a thing at runtime in TS/JS. They exist solely to provide more flexibility in the API surface of programs.</p>",
        "id": 305375751,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666364675
    },
    {
        "content": "<p>Do you have any examples of closed tag unions being useful as return types? Like it's not something that bothers that much, but having a feature in the language which can only be useful partially depending on where you use it smell like something that could be described better using another approach. Not to sound offensive, I'm just trying to better know Roc cause I really want to try it out!!</p>",
        "id": 305376140,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666364787
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"454654\">Ayaz Hafiz</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305368504\">said</a>:</p>\n<blockquote>\n<p>[...] and it does not mean \"this tag can be anything else\". It means, \"allow this value to be used in any context that includes itself, or anything more\"[...]</p>\n</blockquote>\n<p>By the way, this should be written in capital letters in the tutorial page :D if it is not already</p>",
        "id": 305376786,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666364971
    },
    {
        "content": "<p>No you’re totally right. I don’t think it’s all that useful to have closed tag unions in output position. The only example i can think of is if you write a function</p>\n<p>id : [A] -&gt; [A]<br>\nid = \\x -&gt; x</p>\n<p>but i’ve talked about this before with some people, and it seems like you would never actually write such a thing in practice. Which means it may be better to have returned [A] always be open (ie what is [A]* today)</p>",
        "id": 305377803,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666365275
    },
    {
        "content": "<p>Ok so basically you're trying to convert <code>[A]</code> to be by default as you wrote <code>[A]*</code>when used in output positions?</p>",
        "id": 305383566,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666366672
    },
    {
        "content": "<p>Yes</p>",
        "id": 305383663,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666366688
    },
    {
        "content": "<p>And what about direct values? Like:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nx\">A</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"w\"></span>\n<span class=\"c1\"># or</span><span class=\"w\"></span>\n<span class=\"nv\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nx\">A</span><span class=\"p\">]</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 305384069,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666366780
    },
    {
        "content": "<p>Are they the same as output positions for functions?</p>",
        "id": 305384148,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666366797
    },
    {
        "content": "<p>yes</p>",
        "id": 305384281,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666366813
    },
    {
        "content": "<p>So basically the <code>*</code> becomes relevant only in typing function arguments when you don't want to be that strict?</p>",
        "id": 305384897,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666366936
    },
    {
        "content": "<p>It start to smell like variance :D when used as input or output it basically default to the opposite direction</p>",
        "id": 305385264,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666367017
    },
    {
        "content": "<p>Would closed tags be impossible to describe at all in output positions or there would be something new like <code>[A]!</code> to explicitly force closeness?</p>",
        "id": 305386031,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666367176
    },
    {
        "content": "<p>I still think that many things have limited scope. If something has a known limited scope, it should always be a closed union (whether argument or return type). A Bool should always be <code>[True, False]</code>, I don't ever want a Bool to expand to include <code>KindaTruthy</code>.</p>",
        "id": 305386605,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666367292
    },
    {
        "content": "<p>From a definition perspective yes, but you should not limit the caller by defining it closed on the return type of your functions. Because the typechecker already check what you have if you decide to union <code>[Bool, True]</code> with <code>KindaTruthy</code> then booleans operations don't work anymore. Is not something that's hidden from your control. It doesn't affect anything</p>",
        "id": 305388121,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666367581
    },
    {
        "content": "<p>I don't want to write code the enables the user to create something that is more bug prone. Whether intentional or not. If they want a <code>KindaTruthyBool</code>, they can explicitly define it. I get that it would be constrained elsewhere, but I think every location should be as constrained as makes reasonable sense. It makes reasonable sense to constrain a <code>Bool</code> type to never expand.</p>",
        "id": 305389046,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666367756
    },
    {
        "content": "<blockquote>\n<p>the following works just fine:</p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span><code>n = Num *\nn = 1\n\nrcd : {a : U64, b : F32}\nrcd = {a: n, b: n}\n</code></pre></div>\n<p>I am not sure if I find this super cool or really scary. It feels like enabling implicit casts in my mind. As in, the <code>*</code> in <code>Num *</code> should only be able to refer to one things. If it was instead a type parameter <code>T</code>, it would either become <code>U64</code> or <code>F32</code>. The fact it can become both feels like the type system lying. On the other hand, everything in Roc is immutable and it isn't like the type is changing from one line to the next, it is just being defined by each use. Super weird....not sure what to think of it.</p>",
        "id": 305390312,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666367962
    },
    {
        "content": "<p>It's not being two things at once, from what I've understood. It's just open to be concretely implemented by the compiler as the thing it's used for.</p>",
        "id": 305392047,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666368347
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305389046\">said</a>:</p>\n<blockquote>\n<p>I don't want to write code the enables the user to create something that is more bug prone. Whether intentional or not. If they want a <code>KindaTruthyBool</code>, they can explicitly define it. I get that it would be constrained elsewhere, but I think every location should be as constrained as makes reasonable sense. It makes reasonable sense to constrain a <code>Bool</code> type to never expand.</p>\n</blockquote>\n<p>You can't be sure what's error prone, cause the use they do of what you return is solely up to them. What if you have the week workdays as tags and you return a closed tag union of <code>[Monday, Tuesday, ..., Friday]</code> and they want to use it as value for one of their \"Schedule\" values (tags) which also allows Weekends?</p>",
        "id": 305392442,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666368455
    },
    {
        "content": "<p>Moreover, <code>Bool</code> expansion can be useful. Consider the case where you want to describe (not saying it's the best way to do it, but still) how much someone agree with you. You could go for:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">Agreement</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nx\">True</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">False</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">InTheMiddle</span><span class=\"w\"> </span><span class=\"nx\">Num</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">]</span><span class=\"w\"></span>\n</code></pre></div>\n<p>So to have three cases, 100% (yes, True), 0% (no, False), and something in the middle with a percentage.</p>",
        "id": 305393205,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666368670
    },
    {
        "content": "<p>You just defined a different type, not a <code>Bool</code>. It can have a nice <code>fromBool</code> method, but I'd don't think any Bool should implicitly convert to an <code>Agreement</code></p>",
        "id": 305404111,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666372009
    },
    {
        "content": "<p>Implicit conversions are a common source of bugs.</p>",
        "id": 305404747,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666372204
    },
    {
        "content": "<p>You're not converting anything. If you have:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"c1\"># this is my type</span><span class=\"w\"></span>\n<span class=\"nv\">Agreement</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nx\">True</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">False</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">InTheMiddle</span><span class=\"w\"> </span><span class=\"nx\">Num</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">]</span><span class=\"w\"></span>\n\n<span class=\"c1\"># this is an external API that gives me some boolean value back</span><span class=\"w\"></span>\n<span class=\"nv\">getTrueOrFalse</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nx\">True</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">False</span><span class=\"p\">]</span><span class=\"w\"></span>\n\n<span class=\"c1\"># this is my function which should do something then give back my agreement value</span><span class=\"w\"></span>\n<span class=\"nv\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"nx\">something</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"nx\">getTrueOrFalse</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"nx\">InTheMiddle</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"w\"></span>\n</code></pre></div>\n<p>There's no conversion involved, yet it does not type check. Why shouldn't it type check?</p>",
        "id": 305406397,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666372702
    },
    {
        "content": "<p>I guess I just fundamentally see types and conversions differently than you do.</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"c1\"># My type</span><span class=\"w\"></span>\n<span class=\"c1\"># Note, neither Bool nor Agreement are open tags. They explicitly enumerate every state they can ever contain.</span><span class=\"w\"></span>\n<span class=\"nv\">Agreement</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nx\">True</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">False</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">InTheMiddle</span><span class=\"w\"> </span><span class=\"nx\">Num</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">]</span><span class=\"w\"></span>\n\n<span class=\"c1\"># Some function that tells me if a contract is trustworthy or not.</span><span class=\"w\"></span>\n<span class=\"c1\"># Maybe even uses its own type instead of Bool. could be [ Trustworthy, Untrustworthy ]</span><span class=\"w\"></span>\n<span class=\"c1\"># In this case, lets assume bool.</span><span class=\"w\"></span>\n<span class=\"nv\">isTrustworthy</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">Contract</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nx\">Bool</span><span class=\"w\"></span>\n\n<span class=\"c1\"># My function to get an agreement value</span><span class=\"w\"></span>\n<span class=\"nv\">calcAgreement</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">Contract</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nx\">Agreement</span><span class=\"w\"></span>\n<span class=\"nv\">calcAgreement</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"nx\">contract</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"nx\">something</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\"># in this case only the trustworthiness matters. No middle states</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\"># if we just return `isTrustworthy contract` here, I think that should be a bug.</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\"># it is an implicit conversion from `Bool` to `Agreement`.</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\"># they are not the same type. We need to be explicit with the conversion.</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nx\">isTrustworthy</span><span class=\"w\"> </span><span class=\"nx\">contract</span><span class=\"w\"> </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"nx\">Agreement</span><span class=\"p\">.</span><span class=\"nx\">fromBool</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\"># we don't have enough info to use isTrustworthy. So actually do some agree-abality calculation.</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nx\">InTheMiddle</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I think it is very important to note, what happens if <code>isTrustworthy</code> changes it's api.<br>\nIn my example, if <code>isTrustworthy</code> changes to anything other than a <code>Bool</code>, there will be a compiler error.<br>\nThis means whoever changes is <code>isTrustworthy</code> will be forced to consider my code (even if this is me in the future updating some external library).</p>\n<p>If instead, we just return <code>isTrustworthy contract</code> directly because the two tags are merged, we might not get a compiler error when the api of <code>isTrustworthy</code> changes. With this small example, it is likely that either way we will get a compiler error, but with larger tags, it is possible that <code>isTrustworthy</code> could be modified such that it is still a subset of <code>Agreement</code>, but using the tags to mean something different.<br>\nFor this example, which of course will be contrived due to these specific tags, what if <code>isTrustworthy</code> suddenly started returning <code>InTheMiddle 423</code> where this doesn't mean we have <code>423</code> agreement, but instead, the contract is still in the middle of negotiation, so we don't know if it is trustworthy and <code>423</code> is some sort of contract legal code for what stage the contract is in. We just introduced a huge bug due to allowing the result from <code>isTrustworthy</code> to implicity convert to an <code>Agreement</code>.</p>",
        "id": 305422119,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666378178
    },
    {
        "content": "<p>That is compelling, but I don't know if that particular problem is avoidable in general with a language that anonymous structural types. Also, I feel like the payload of <code>InTheMiddle</code> should always be an opaque type/named structural type (e.g. record) in an API like this, so I wonder how likely this is to happen in practice.</p>",
        "id": 305731846,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666574317
    },
    {
        "content": "<p>I think the upside of being able to accumulate tags returned from a function in any context you like, for free, is a huge upside for a language like Roc, that relies heavily on monad-like patterns, that we should try to prioritize making that seamless</p>",
        "id": 305731895,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666574366
    },
    {
        "content": "<p>But, to Brendan's point, there are cases where you might accidentally do too much work based on the tags returned from a function</p>",
        "id": 305731932,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666574397
    },
    {
        "content": "<p>For example</p>\n<div class=\"codehilite\"><pre><span></span><code>get : Url -&gt; Result Response [Http404, Http500, HttpTimeout]*\n\nwhen get &quot;https://roc-lang.org&quot; is\n  Err Http404 | Err Http500 | Err HttpTimeout -&gt; ...\n  Err HttpRedirect -&gt; ... # useless branch!\n  Ok l -&gt; ...\n</code></pre></div>",
        "id": 305732076,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666574502
    },
    {
        "content": "<p>That second branch in the <code>when</code> is useless, but it would be admitted currently</p>",
        "id": 305732140,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666574529
    },
    {
        "content": "<p>however there are ways the compiler can help you out here, for example \"bidirectional exhaustiveness checking\", where we check that the branches possibly returned by the \"when\" condition (in this case <code>get \"https://roc-lang.org\"</code>) are exhaustive or redundant relative to the branches that are matched in the when condition. So it's like normal exhaustiveness checking, but going the other way</p>",
        "id": 305732231,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666574613
    },
    {
        "content": "<p>That would catch this case, helping you avoid some of the common pitfalls of these kinds of tag unions. I actually have a branch implementing that, and it works pretty well!</p>",
        "id": 305732310,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666574647
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"556413\">Kristian Notari</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305386031\">said</a>:</p>\n<blockquote>\n<p>Would closed tags be impossible to describe at all in output positions or there would be something new like <code>[A]!</code> to explicitly force closeness?</p>\n</blockquote>\n<p>I would be inclined to say \"no\", because that seems like it could make things as confusing as they are today for folks who do not grok the \"open means usable in any context\" definition of tag unions. But obviously I don't really know any of the right answers here</p>",
        "id": 305732641,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666574885
    },
    {
        "content": "<p>Yeah, i definitely agree that my example is relatively unlikely. I am probably being overly defensive, but I am used to the explicit nature of enum like types. I probably need to play around with open tags a lot more to see the benefits. Currently my only use case for open tags is error types.</p>\n<p>Question: If we defaulted to returning open unions from functions, would there be a way to explicitly close them?</p>",
        "id": 305734423,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666576172
    },
    {
        "content": "<p>I guess you could always just make them opaque?</p>",
        "id": 305734520,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666576214
    },
    {
        "content": "<p>That’s what Kristan’s question I quoted above is asking. I think the answer should be no, you can’t (otherwise it could be equally confusing as the current state of things)</p>",
        "id": 305735393,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666576483
    },
    {
        "content": "<p>Ok</p>",
        "id": 305735683,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666576726
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305422119\">said</a>:<br>\nYour example is correct and I agree with you more separation between domains is a good thing in general. The problem is that even with a domain translator function like <code>Agreement.fromBool</code> you're always subject to change in other's APIs. What if <code>isTrustworthy</code> start returning always <code>true</code> or always <code>false</code>? No compiler error, everything's fine, you notice later in production cause every agreement turns out to be True or False.</p>\n<p>Ideally this kind of corner cases are already covered by testing, because there's no way to defend your code 100% from changes to other APIs if the signature/type still matches.</p>",
        "id": 305760633,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666596092
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"556413\">@Kristian Notari</span> I am pretty sure you just described a different class of error. Yes, always true or always false is a bug that should be tested for. Unit tests should catch that.</p>\n<p>On the other hand, roc has a a<br>\nstatic type system. You should never need to write a test that a function actually returns a specific type. The type system should automatically catch all errors of this class. Only in a dynamic language would you need a test of that variety.</p>",
        "id": 305834768,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666622308
    },
    {
        "content": "<p>Having strong guarantees that mean you don't even need a test is much better than writing many many tests and hoping you didn't miss an edge case.</p>",
        "id": 305834922,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666622367
    },
    {
        "content": "<p>Also, <code>isTrustworthy</code> always returning false is not a change in it's API. It still is returning a bool, which is all that its API guarantees. Again, it is still likely a bug, but it is not related to the API.</p>",
        "id": 305835253,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666622464
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305834922\">said</a>:</p>\n<blockquote>\n<p>Having strong guarantees that mean you don't even need a test is much better than writing many many tests and hoping you didn't miss an edge case.</p>\n</blockquote>\n<p>You need tests in both cases. It's not a different class of errors. </p>\n<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305422119\">said</a>:</p>\n<blockquote>\n<p>With this small example, it is likely that either way we will get a compiler error, but with larger tags, it is possible that <code>isTrustworthy</code> could be modified such that it is still a subset of <code>Agreement</code>, but using the tags to mean something different.</p>\n</blockquote>\n<p>This ^^ wrote by you is the same class of errors as the one I was telling you about with my example. Not a \"change in the signature\" but a change in the API behavior still worth noticing.</p>\n<p>You always have to check things.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305422119\">said</a>:</p>\n<blockquote>\n<p>For this example, which of course will be contrived due to these specific tags, what if isTrustworthy suddenly started returning InTheMiddle 423 where this doesn't mean we have 423 agreement, but instead, the contract is still in the middle of negotiation, so we don't know if it is trustworthy and 423 is some sort of contract legal code for what stage the contract is in. We just introduced a huge bug due to allowing the result from isTrustworthy to implicity convert to an Agreement.</p>\n</blockquote>\n<p>And this ^^ too would be checked only by tests. As soon as the function you're using (<code>isTrustworthy</code>) or the function you're creating (<code>calcAgreement</code>) keep their signature, everything can change, even after you add closed tags, it's just more uncomfortable to wrap/unwrap them every single time.</p>",
        "id": 305836451,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666622844
    },
    {
        "content": "<p>If you're always adhering to the type signatures of functions (so no compiler error) everything's fine and what's left is tests goal to test, if needed.</p>",
        "id": 305836738,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666622928
    },
    {
        "content": "<p>It doesn't really matter if tags are closed or not, if you can easily translate to and from tags with wrapping or with implicit tag merging</p>",
        "id": 305836844,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666622968
    },
    {
        "content": "<p>Those two quotes both only happen if you don't have <code>Agreement.fromBool</code> and don't enforce explicit casts. With explicit casts, they are both impossible.</p>",
        "id": 305837007,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666623011
    },
    {
        "content": "<p>You're just moving the problem to the wrapping/unwrapping. What if <code>Agreement.fromBool</code> changes to return a <code>InTheMiddle 42</code> ?</p>",
        "id": 305837189,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666623068
    },
    {
        "content": "<p>you can't prevent that to happen by just using types</p>",
        "id": 305837251,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666623087
    },
    {
        "content": "<p>You are greatly misrepresenting my point. The types make you safer and remove a class of problems. They help to scope issues and give you some guarantees. This does not mean they guarantees no bugs. This does not mean you don't have to test. An explicit cast can still have a bug, but it is much easier to test 1 explicit cast function than it is to test ever single location that could have an implicit cast.</p>",
        "id": 305837765,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666623224
    },
    {
        "content": "<p>\"The types make you safer and remove a class of problems\" --&gt; I hope we all agree on that one since we're here for Roc <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> and I agree too</p>",
        "id": 305838213,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666623337
    },
    {
        "content": "<p>In this case, the types simply guarantee that isTrustworthy returns a Bool. I should never need to test whether or not <code>isTrustworthy</code> returns <code>InTheMiddle 42</code>.</p>",
        "id": 305838495,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666623419
    },
    {
        "content": "<p>With implicit casts, you do need to test for that.</p>",
        "id": 305838612,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666623454
    },
    {
        "content": "<p>Yeah but just define a helper function that chain <code>isTrustworthy</code> with <code>Agreement.fromBool</code>. Does that fulfill your requirements for having less bugs? Because from <code>calcAgreement</code> you now call a function which return a <code>Agreement</code> but you really don't know what. The problem's still there</p>",
        "id": 305839544,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666623672
    },
    {
        "content": "<p>I still think that is much better than the implicit cast. It is a single testable function instead of needing to test every location that could have an implicit cast.</p>",
        "id": 305840005,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666623772
    },
    {
        "content": "<p>Tags are great, once you have them there's no really the need of wrapping/unwrapping things if they just get merged easily as with typescript. You'd only need wrapping/unwrapping (the casting you were referring to) if you need to add data to them or you want them to have different names, to group them, or something similar (readability). It doesn't alter correctness</p>",
        "id": 305840420,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666623862
    },
    {
        "content": "<p>Besides limited cases, like error tags, i have not seen uses where I would consider tags automatically merging beneficial. I would love to learn otherwise, but I have not seen examples where I would want to default to open tag unions. So I see open tags as a valuable feature in some cases, but not something I would expect to default to.</p>",
        "id": 305841178,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666624057
    },
    {
        "content": "<p>In my typescript experience, I use string literals as types (I mean everyone does). In the typescript type system <code>\"mystring\"</code> is a subtype of <code>string</code>,  so you can precisely type string literals as if they were tags (no data attached, but can workaround that in other ways). There are part of the domain which are focused on some bits and other parts focused on others. When you compose those parts, the resulting \"type\" should be the union of those \"string literals\" you're returning.</p>\n<p>So in our example, the code which handle the true or false bit could be somewhere and somewhere else there could be the code that handle the InTheMiddle case. When you \"join\" those bits in your \"upper level\" code it's not mandatory nor beneficial (unless you want to add other info, wrap them with different names or something similar which has nothing to do with correctness or bugs) to wrap them with other \"strings\" or other types.</p>\n<p>So in a typescript example:</p>\n<div class=\"codehilite\" data-code-language=\"TypeScript\"><pre><span></span><code><span class=\"kr\">type</span><span class=\"w\"> </span><span class=\"nx\">ContractTrustworthy</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s2\">\"true\"</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s2\">\"false\"</span><span class=\"w\"></span>\n<span class=\"kr\">declare</span><span class=\"w\"> </span><span class=\"kd\">function</span><span class=\"w\"> </span><span class=\"nx\">isTrustworthy</span><span class=\"p\">(</span><span class=\"nx\">contract</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Contract</span><span class=\"p\">)</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">ContractTrustworthy</span><span class=\"w\"></span>\n\n<span class=\"kr\">type</span><span class=\"w\"> </span><span class=\"nx\">Undecided</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s2\">\"in-the-middle\"</span><span class=\"w\"> </span><span class=\"c1\">// ignore the number bit for a second</span><span class=\"w\"></span>\n<span class=\"kr\">declare</span><span class=\"w\"> </span><span class=\"kd\">function</span><span class=\"w\"> </span><span class=\"nx\">makeInTheMiddle</span><span class=\"p\">(</span><span class=\"nx\">contract</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Contract</span><span class=\"p\">)</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">Undecided</span><span class=\"w\"></span>\n\n<span class=\"kr\">type</span><span class=\"w\"> </span><span class=\"nx\">Agreement</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nx\">ContractTrustworthy</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"nx\">Undecided</span><span class=\"w\"></span>\n<span class=\"kr\">declare</span><span class=\"w\"> </span><span class=\"kd\">function</span><span class=\"w\"> </span><span class=\"nx\">calcAgreement</span><span class=\"p\">(</span><span class=\"nx\">contract</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Contract</span><span class=\"p\">)</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">Agreement</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 305843743,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666624709
    },
    {
        "content": "<p>and then the body would be:</p>\n<div class=\"codehilite\" data-code-language=\"TypeScript\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nx\">something</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nx\">isTrustworthy</span><span class=\"p\">(</span><span class=\"nx\">contract</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nx\">makeInTheMiddle</span><span class=\"p\">(</span><span class=\"nx\">contract</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 305844026,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666624795
    },
    {
        "content": "<p>Type are automatically merged (that is unioned) and you get an <code>Agreement</code> out of the two branches, which is the merging of both <code>ContractTrustworthy</code> and <code>Undecided</code>. It's common with errors, so errors merge with other errors giving you a list of reasons things could possibly fail for</p>",
        "id": 305844382,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666624895
    },
    {
        "content": "<p>But there's nothing less/more error prone in doing it this way or with wrapping types</p>",
        "id": 305844543,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666624932
    },
    {
        "content": "<p>One can object refactoring/readability/noticing future bugs can be easier/harder with one approach or the other (don't know which honestly), but that's pure developer friendliness, the two approaches doesn't change the program correctness underneat.</p>",
        "id": 305844829,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666625030
    },
    {
        "content": "<p>(here I'm using true and false as string literals instead of the types <code>true</code> and <code>false</code> which typescript has, boolean type, just to better adhere to the tags example in Roc)</p>",
        "id": 305845236,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666625148
    },
    {
        "content": "<p>Yeah, the fundamental difference is just if you have to be explicit or not. That is all.</p>\n<p>With closed unions, you either have to wrap or convert.</p>\n<p>convert:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">Agreement</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"w\"> </span><span class=\"nx\">True</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">False</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">InTheMiddle</span><span class=\"w\"> </span><span class=\"nx\">U64</span><span class=\"w\"> </span><span class=\"p\">]</span><span class=\"w\"></span>\n\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"nx\">something</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">isTrustworthy</span><span class=\"w\"> </span><span class=\"nx\">contract</span><span class=\"w\"> </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"nx\">fromTrustworthy</span><span class=\"w\"></span>\n<span class=\"k\">else</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">makeInTheMiddle</span><span class=\"w\"> </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"nx\">fromInTheMiddle</span><span class=\"w\"></span>\n</code></pre></div>\n<p>wrap:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">Agreement</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"w\"> </span><span class=\"nx\">ExactAgreement</span><span class=\"w\"> </span><span class=\"nx\">ConstractTrustworthy</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">FuzzyAgreement</span><span class=\"w\"> </span><span class=\"nx\">Undecided</span><span class=\"w\"> </span><span class=\"p\">]</span><span class=\"w\"></span>\n\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"nx\">something</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">isTrustworthy</span><span class=\"w\"> </span><span class=\"nx\">contract</span><span class=\"w\"> </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"nx\">ExactAgreement</span><span class=\"w\"></span>\n<span class=\"k\">else</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">makeInTheMiddle</span><span class=\"w\"> </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"nx\">FuzzyAgreement</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 305847446,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666625667
    },
    {
        "content": "<p>Another example I can give on \"consider tags automatically merging\" is that from a mental model perspective (at least mine), they're unions of things. I assume you can always say \"this OR that\", in whatever language you like. And that's what you basically want, except you need a wrapping/casting/converting pass as you've just describer before you actually can do that if you have closed tags.</p>",
        "id": 305847644,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666625727
    },
    {
        "content": "<p>I think it has been shown in a lot of languages, that most of the time it is more preferable to be explicit because implicit casts lead to more bugs. As such, I prefer closed unions as the default. I understand the use of an open union. I think they are great for error tags, but errors are a special case where accumulating anything and everything makes a lot of sense.</p>",
        "id": 305847838,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666625784
    },
    {
        "content": "<p>From my mental model what I see is (not valid Roc code):</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">Agreement</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">True</span><span class=\"w\"> </span><span class=\"nx\">OR</span><span class=\"w\"> </span><span class=\"nx\">False</span><span class=\"w\"> </span><span class=\"nx\">OR</span><span class=\"w\"> </span><span class=\"nx\">InTheMiddle</span><span class=\"w\"> </span><span class=\"nx\">U64</span><span class=\"w\"></span>\n\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"nx\">something</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">isTrustworthy</span><span class=\"w\"> </span><span class=\"nx\">contract</span><span class=\"w\"> </span><span class=\"c1\"># True OR False</span><span class=\"w\"></span>\n<span class=\"k\">else</span><span class=\"w\"> </span><span class=\"c1\"># OR</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">makeInTheMiddle</span><span class=\"w\"> </span><span class=\"c1\"># InTheMiddle U64</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 305847913,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666625810
    },
    {
        "content": "<p>The fact I can't express this simple use case because some library author wrote their <code>isTrustworthy</code> function with closed tags is a no go personally. It shouldn't be his right to decide</p>",
        "id": 305848074,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666625863
    },
    {
        "content": "<p>Also, I think it would be different if we had another way to define a tag as something like this:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">Agreement</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">ContractTrustworthy</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"nx\">Undecided</span><span class=\"w\"></span>\n</code></pre></div>\n<p>In this case, I am explicitly saying that an <code>Agreeement</code> is the merging of <code>ContractTrustworthy</code> and <code>Undecided</code>. In that case, you are kinda opting into implicit conversion. Roc does not currently support this, but if it did, I think it would have value.</p>",
        "id": 305848276,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666625924
    },
    {
        "content": "<p>^^ Yeah, essentially what you said with different wording.</p>",
        "id": 305848393,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666625959
    },
    {
        "content": "<p>You can actually do that in Roc from my understanding of the Tutorial:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">Agreement</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[]</span><span class=\"nx\">ContractTrustworthy</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 305848447,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666625976
    },
    {
        "content": "<p>I don't know how to union multiple ones, but you actually can</p>",
        "id": 305848494,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666625991
    },
    {
        "content": "<p>The same with records</p>",
        "id": 305848851,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666626086
    },
    {
        "content": "<p>Strange syntax IMO but working I guess <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 305848929,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666626111
    },
    {
        "content": "<p>So I guess, my statement has to shift.</p>\n<p>I like closed unions as the default. I think open unions should only be used in special cases like error types. All that said, I definitely think there would be value in having the ability to define a type that explicitly merges multiple closed unions into a bigger union (still closed). This type would then enable the implicit cast use case, but at least it is documented in the type system by the new type being defined as the merging of multiple sub-unions.</p>",
        "id": 305849169,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666626183
    },
    {
        "content": "<p>The problem being: the function author should not be able to choose how his tags \"closeness\" affect my code</p>",
        "id": 305849479,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666626276
    },
    {
        "content": "<p>It should be a caller problem</p>",
        "id": 305849510,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666626288
    },
    {
        "content": "<p>Cause you don't know what makes sense to close or open beforehand. Different context and domains should be able to decide on their own</p>",
        "id": 305849620,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666626323
    },
    {
        "content": "<p>Which if you could define agreement as <code>Agreement: ContractTrustworthy | Undecided</code>, that would not be a problem. You just are explicitly changing your type to extend the closed <code>ContractTrustworthy</code></p>",
        "id": 305849624,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666626324
    },
    {
        "content": "<p>Instead of defining an arguable different type: <code>Agreement : [True, False, InTheMiddle Num *]</code> and then implicitly casting</p>",
        "id": 305849909,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666626403
    },
    {
        "content": "<p>Yeah with Roc \"uniqueness of tag\" philosophy I agree I should not recreate \"True\" tag and hope it will be considered the same as the function return type tag I'm calling, that's a thing</p>",
        "id": 305850110,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666626462
    },
    {
        "content": "<p>Which I guess as you said could theoretically be written like: <code>Agreement: [InTheMiddle Num *]ContractTrustworthy</code>, assuming you are extending and not merging two different unions</p>",
        "id": 305850244,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666626493
    },
    {
        "content": "<p>But my Roc syntax before is not invented I'm pretty sure I've read it on the Tutorial. You could write <code>Agreement : []ContractTrustworthy,Undecided</code> or something similar and it just union them</p>",
        "id": 305850308,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666626509
    },
    {
        "content": "<p>yeah that</p>",
        "id": 305850370,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666626522
    },
    {
        "content": "<p>The problem being, even if that's valid Roc syntax and we both agree you should be able to write your <code>Agreement</code> type like that, if the author of the <code>isTrustworthy</code> function says the return type is a CLOSED tag then you literally CAN'T merge it, even if your <code>Agreement</code> type says so, cause if/else must return the same type in both branches</p>",
        "id": 305850672,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666626593
    },
    {
        "content": "<p>and the Roc typechecker would argue it cannot \"merge\" the closed union tag returned by <code>isTrustworthy</code></p>",
        "id": 305850815,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666626616
    },
    {
        "content": "<p>that's why they're defaulting to change this behaviur in Roc to \"output types should have open tags only\"</p>",
        "id": 305850952,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666626655
    },
    {
        "content": "<p>So yeah, I guess my opinion is:</p>\n<blockquote>\n<p>output types should have open tags only</p>\n</blockquote>\n<p>currently strongly disagree</p>\n<blockquote>\n<p>Closed tags should have some way to be unioned to fix this underlying issues</p>\n</blockquote>\n<p>I am totally for that.</p>",
        "id": 305851307,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666626737
    },
    {
        "content": "<p>we're making progress here <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 305851551,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666626804
    },
    {
        "content": "<p>now we disagree on different things</p>",
        "id": 305851578,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666626812
    },
    {
        "content": "<p>haha</p>",
        "id": 305851603,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666626816
    },
    {
        "content": "<p>than before</p>",
        "id": 305851624,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666626826
    },
    {
        "content": "<p>I'm feeling your worry for \"my <code>True</code> tag being considered the same as someone else's <code>True</code> tag without anything explicitly written for it\"</p>",
        "id": 305851840,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666626887
    },
    {
        "content": "<p>And I can agree with you it's not ideal, if the all tag feature thing in the language seems to prioritize uniqueness</p>",
        "id": 305851986,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666626935
    },
    {
        "content": "<p>But my opinion is that considering the two <code>True</code> to be identical (so allowing what you call as \"implicit casting\") is better than having closed tags decided by function authors.</p>",
        "id": 305852488,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666627075
    },
    {
        "content": "<blockquote>\n<p>Closed tags should have some way to be unioned to fix this underlying issues</p>\n</blockquote>\n<p>We technically should be able to do this, the one disadvantage of it, is that it would have some sort of runtime cost. The compiler would just generate a conversion function that in the minimal case would just change an integer. In the worst case, might have to copy around a solid bit of data.</p>\n<p>So returning open tags does have a performance advantage, but I think in most cases it would be minimal, and as long as we still had open tags, you would have an explicit way to work around it.</p>",
        "id": 305852505,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666627079
    },
    {
        "content": "<p>The problem still is: \"is my <code>True</code> tag the same as the <code>True</code> tag defined in someone else's code?\"</p>",
        "id": 305852876,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666627183
    },
    {
        "content": "<p>One extra piece of information that probably actually argues for returning an open tag. If two unions have all the exact same tags with the same data, the compiler will consider them the exact same type unless they are opaque.</p>\n<div class=\"codehilite\"><pre><span></span><code>Agreement : [Agree, Disagree]\n\nQuestionAnswer : [Agree, Disagree]\n</code></pre></div>\n<p>Since these two aliases happened to be 100% identical, they are the same type to the compiler.</p>",
        "id": 305853458,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666627333
    },
    {
        "content": "<p>Oh I thought they were considered as separate things right now</p>",
        "id": 305854078,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666627507
    },
    {
        "content": "<p>So Roc point is not that much about uniqueness as I thought</p>",
        "id": 305854154,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666627530
    },
    {
        "content": "<p>I mean, if you really want to make things \"closed\" you just make it opaque I guess</p>",
        "id": 305854384,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666627597
    },
    {
        "content": "<blockquote>\n<p>Closed tags should have some way to be unioned to fix this underlying issues</p>\n</blockquote>\n<p>As Kristian mentioned you can do this today, if you have something like</p>\n<div class=\"codehilite\"><pre><span></span><code>ContractTrustworthy a : [True, False]a\nUndecided a : [Undecided U64]a\n\nCombined : ContractTrustworthy(Undecided [])\n</code></pre></div>\n<p>I'm not sure I see how this helps though. You are still forced to do an explicit conversion if you want to convert <code>ContractTrustworthy[]</code> to <code>Combined</code>, at least today.</p>",
        "id": 305854408,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666627605
    },
    {
        "content": "<p>It was about considering <code>Combined</code> as \"creatable\" via tag values defined in the tag type it's defined from</p>",
        "id": 305854801,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666627727
    },
    {
        "content": "<p>without explicit conversion basically, based on how you define your tags</p>",
        "id": 305854857,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666627743
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">Combined</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nx\">True</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">False</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">Undecided</span><span class=\"w\"> </span><span class=\"nx\">U64</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"c1\"># this should be its own definition</span><span class=\"w\"></span>\n<span class=\"nv\">Combined</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">ContractTrustworthy</span><span class=\"p\">(</span><span class=\"nx\">Undecided</span><span class=\"w\"> </span><span class=\"p\">[])</span><span class=\"w\"> </span><span class=\"c1\"># this should be populated simply with ContractTrustworthy or Undecided tag values directly</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 305855162,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666627825
    },
    {
        "content": "<p>Because in the first case I'm expecting to use MY OWN VALUES for <code>Combined</code>, while in the second example I'm expecting to use other tag values as values for <code>Combined</code>.</p>",
        "id": 305855364,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666627883
    },
    {
        "content": "<p>I think I see what you're getting at, but those two definitions are the same today. The alias names <code>Combined</code>, <code>ContractTrustworthy</code> don't matter in measuring type equality; you have to use opaque types to make them distinct, as you mentioned.</p>",
        "id": 305855404,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666627893
    },
    {
        "content": "<p>Ah, I was hoping you could define <code>Combined : ContractTrustworthy(Undecided [])</code> -&gt; allow implicit casts from the sub unions to the combined union.</p>",
        "id": 305855592,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666627946
    },
    {
        "content": "<p>Yeah now it makes sense, but before I was thinking tags were like enums, so each one with its own value, different from others even if called the same</p>",
        "id": 305855674,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666627969
    },
    {
        "content": "<p>Like the compiler would create the casts for you since you wrote a unioned type.</p>",
        "id": 305855687,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666627971
    },
    {
        "content": "<p>I agree re your previous point, I think if you really want things to be closed you should use an opaque type. In my mind tags are mostly for light-weight, contextual data that is unambiguous. If you want to encode domain-specific information that should be preserved faithfully, opaque types are a better choice.</p>\n<p>I think we see this with Roc programs today already. Tags are mostly used only for collecting errors/effects, or for small, localized function calls that don't escape out anywhere (like <code>List.walkUntil</code>, which uses <code>[Continue state, Break state]</code>), and things that do need to escape further away are hidden behind an opaque type (e.g. <code>Parser</code>, <code>File</code> in the cli platform). It also is the case in the original motivating example for this discussion - Ok/Err tags.</p>",
        "id": 305855800,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666628011
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"343810\">@Brendan Hansknecht</span> the fact this leads to the same type being defined twice:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">Agreement</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nx\">Agree</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">Disagree</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"nv\">QuestionAnswer</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nx\">Agree</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">Disagree</span><span class=\"p\">]</span><span class=\"w\"></span>\n</code></pre></div>\n<p>remove the whole problem of \"implicit/explicit\" casting based on how tags are defined, if with direct values or if combined with existing values</p>",
        "id": 305856066,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666628084
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305855592\">said</a>:</p>\n<blockquote>\n<p>Ah, I was hoping you could define <code>Combined : ContractTrustworthy(Undecided [])</code> -&gt; allow implicit casts from the sub unions to the combined union.</p>\n</blockquote>\n<p>so this doesn't matter anymore, it should not be a thing</p>",
        "id": 305856149,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666628104
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"454654\">Ayaz Hafiz</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305855800\">said</a>:</p>\n<p>I think this answers everything, does it for you too <span class=\"user-mention\" data-user-id=\"343810\">@Brendan Hansknecht</span> ?</p>",
        "id": 305856398,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666628177
    },
    {
        "content": "<blockquote>\n<p>If you want to encode domain-specific information that should be preserved faithfully, opaque types are a better choice.</p>\n</blockquote>\n<p>I guess that is fair.</p>",
        "id": 305856557,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666628229
    },
    {
        "content": "<p>If that is the recomendation, I think it is reasonable</p>",
        "id": 305856595,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666628242
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"454654\">@Ayaz Hafiz</span> what happens with the following definition:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">MyOpaqueTag</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nx\">A</span><span class=\"p\">,</span><span class=\"nx\">B</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"c1\"># don't know how to write opaque tags yet sorry</span><span class=\"w\"></span>\n<span class=\"nv\">MyOpenTag</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nx\">A</span><span class=\"p\">,</span><span class=\"nx\">B</span><span class=\"p\">]</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Are these two equivalent? So, is the only discriminant for equality here the tag's name? If I have:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">MyOpaqueTag</span><span class=\"w\"></span>\n<span class=\"nv\">g</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">MyOpenTag</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Can I use <code>f</code> and <code>g</code> interchangeably?</p>",
        "id": 305856882,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666628332
    },
    {
        "content": "<p>no</p>",
        "id": 305856959,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666628353
    },
    {
        "content": "<p>The two opaque tags would be unique even if they have the exact same variants</p>",
        "id": 305857067,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666628382
    },
    {
        "content": "<p>And an opaque tag is unique from a non opaque tag</p>",
        "id": 305857181,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666628407
    },
    {
        "content": "<p>When using them in code, they are essentially wrapped tags that are wrapped with a special tag that is always going to be unique from other tags.</p>",
        "id": 305857294,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666628448
    },
    {
        "content": "<p>Also, definition of an opaque type is just <code>:=</code></p>",
        "id": 305857385,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666628478
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305855592\">said</a>:</p>\n<blockquote>\n<p>Ah, I was hoping you could define <code>Combined : ContractTrustworthy(Undecided [])</code> -&gt; allow implicit casts from the sub unions to the combined union.</p>\n</blockquote>\n<p>fwiw if closed unions in output are kept around, I would like this too. For example we have code like this that does transformations of tags solely for the sake of upcasting: <a href=\"https://github.com/roc-lang/roc/blob/50fac9cc9e4eaee584c750cdfe8fd397458c3d83/crates/compiler/builtins/roc/Decode.roc#L89-L98\">https://github.com/roc-lang/roc/blob/50fac9cc9e4eaee584c750cdfe8fd397458c3d83/crates/compiler/builtins/roc/Decode.roc#L89-L98</a>. I think it would be nice to tell the compiler to automatically do the transformation for you via e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"w\">fromBytes : List U8, fmt -&gt; Result val [Leftover (List U8)]DecodeError | val has Decoding, fmt has DecoderFormatting</span>\n<span class=\"w\">fromBytes = \\bytes, fmt -&gt;</span>\n<span class=\"w\"> </span>   when fromBytesPartial bytes fmt is<span class=\"w\"></span>\n<span class=\"w\"> </span>       { result, rest } -&gt;<span class=\"w\"></span>\n<span class=\"w\"> </span>           if List.isEmpty rest then<span class=\"w\"></span>\n<span class=\"w\"> </span>               when result is<span class=\"w\"></span>\n<span class=\"gi\">+                   result as finalResult -&gt; finalResult</span><span class=\"w\"></span>\n<span class=\"gd\">-                   Ok val -&gt; Ok val</span><span class=\"w\"></span>\n<span class=\"gd\">-                   Err TooShort -&gt; Err TooShort</span><span class=\"w\"></span>\n<span class=\"w\"> </span>           else<span class=\"w\"></span>\n<span class=\"w\"> </span>               Err (Leftover rest)<span class=\"w\"></span>\n</code></pre></div>\n<p>I have an experiment for that too <span aria-label=\"laughter tears\" class=\"emoji emoji-1f602\" role=\"img\" title=\"laughter tears\">:laughter_tears:</span></p>",
        "id": 305858181,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666628730
    },
    {
        "content": "<p>Anyway, I still think I like explicit casts by default, but I understand the sentiment and goals with being more open. Especially when think of tags as light weight and temporary rather than exact and for domain model. As was said, when you have a type that you want to be exact, you have opaque types.</p>",
        "id": 305858440,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666628801
    },
    {
        "content": "<p>Yeah but having:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">A</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nx\">True</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">False</span><span class=\"p\">]</span><span class=\"w\"></span>\n\n<span class=\"nv\">Mine</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">A</span><span class=\"w\"></span>\n<span class=\"nv\">Mine</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nx\">True</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">False</span><span class=\"p\">]</span><span class=\"w\"></span>\n</code></pre></div>\n<p>mean two different things for <code>Mine</code> casting wise it's hard to easily explain. It's not what you would expect</p>",
        "id": 305858527,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666628826
    },
    {
        "content": "<p>For implicit casting I am thinking of the underlying structural type, not based on the alias name. Relying on the alias name for structural aliases (not opaque types) has a lot of problems. But this is an aside, I don't want to take this thread off topic.</p>",
        "id": 305858927,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666628927
    },
    {
        "content": "<p>Not sure if this is a can of worms and should just be pushed to implementation time or a different discussion, but how does syntax work if returned tags are always open?</p>\n<p><code>myFunc : [ A, B] -&gt; [ B, C]</code> -&gt; This would be closed tag to open tag?<br>\n<code>myFunc : [ A, B]* -&gt; [ B, C]</code> -&gt; This would be open tag to open tag?<br>\n<code>myFunc : [ A, B]* -&gt; [ B, C]*</code> -&gt; This would be invalid syntax  because only function inputs can be explicitly labeled as open now?</p>",
        "id": 305859194,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666629003
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"454654\">Ayaz Hafiz</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305858927\">said</a>:<br>\nwhat do you mean by \"underlying structural type\" ?</p>",
        "id": 305859279,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666629016
    },
    {
        "content": "<p>Oh you mean, if my tag type has values <code>[A,B]</code> and I'm receiving a subtype set of those values I should just <code>as</code> them to my type?</p>",
        "id": 305859608,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666629104
    },
    {
        "content": "<p>But should that be explicit? I mean, if they are a subtype my opinion on this is that they should be converted implicitly. But again, this is not done due to performance reasons right? You have to explicitly tell the compiler you're converting them? With <code>as</code> keyword or something?</p>",
        "id": 305861305,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666629650
    },
    {
        "content": "<p>I think this is talking about if the tags weren't open by default. Since the tags are closed, this is one way to implement the conversion instead of needing to write your own <code>Argument.fromBool</code>. You would just use <code>as Argument</code>. This should not be required in the case the functions return open tags by default.</p>",
        "id": 305862347,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1666629979
    },
    {
        "content": "<blockquote>\n<p>Not sure if this is a can of worms and should just be pushed to implementation time or a different discussion, but how does syntax work if returned tags are always open?</p>\n</blockquote>\n<p>yeah the rules get messy. What you described is what I was thinking, and Richard and I previously talked about how that would extend to aliases and it seems correct there too. One thing that isn't clear to me is what should happen for tags behind opaque types, that seems trickier.</p>",
        "id": 305863436,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666630353
    },
    {
        "content": "<p>I think it might be helpful to go back to the original motivation though, which is that <span class=\"user-mention\" data-user-id=\"556413\">@Kristian Notari</span> initially found the behavior of open tag unions confusing. Do you feel like you have a better grasp on them now <span class=\"user-mention\" data-user-id=\"556413\">@Kristian Notari</span> ?</p>\n<p>If so, what do you think helped - the framing of \"being able to use the tags in any context\", or something else? And, if so, would changing how open/closed tag unions behaved help, in your opinion, or is this a documentation/teaching problem&gt;</p>\n<p>And if not, what do you continue to find challenging to understand about the behavior of open tag unions, given this thread?</p>",
        "id": 305863789,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1666630482
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"454654\">Ayaz Hafiz</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305855800\">said</a>:</p>\n<blockquote>\n<p>I think if you really want things to be closed you should use an opaque type.</p>\n</blockquote>\n<p>interestingly, <code>Bool</code> now models this technique!</p>",
        "id": 305882228,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1666633776
    },
    {
        "content": "<p>also interesting: if it's the only way to do it (e.g. if we change it so that you can no longer have closed tag unions in the output position), then it becomes very clear that this is what you should do when you want things to be closed, because that becomes the only way to do it!</p>",
        "id": 305883158,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1666634093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"454654\">Ayaz Hafiz</span> <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305863789\">said</a>:</p>\n<p>The confusing bits around tags (and more generally the <code>*</code> or \"extensions/unions\" in types, even for records) were about the framing. You've cleared my doubts with the sentence I've reported <a href=\"#narrow/stream/231634-beginners/topic/Open.20tag.20unions/near/305376786\">here</a> already.</p>\n<p>I don't find anything challenging anymore. Now I'm curious to see where this type system bits in Roc are going to lead, because from my perspective things that are structurally equal are equal, when it comes to thinking about tags or records, despite the fact one would like to have some more control over the making and accessing of values of a specific type. I come from a typescript background so that answers the why I'm more inclined to see everything as structural instead of named. I mean, I know of nominative type systems but still. And I don't know how many name clashes with tags are going to happen nor how that plays well in actual development because I have no experience with Roc whatsoever so I'm willing to try.</p>\n<p>One last thing, for the open/closeness of types: since the \"defaulting to open depending on input/output position\" discussion we had, I had the doubt this is one of those times where (going abstract here) a concept that covers A is being used to solve B. I don't know if that's the case but when you adopt a concept and then you need cases and branches to say \"yes but that thing in this context means another thing\" maybe it's a clue that should not be the right approach or at least not the best way to let the user approach it. Don't know, I really don't want to judge with so few experiences in Roc, I'm just being honest and giving you a clear and honest opinion on what I have been feeling reading through the docs and writing with you here on this thread.</p>\n<p>At the end of the day I just want to see Roc grow cause I was waiting for it these past months refreshing the website to see more talks from Richard that were not appearing and then I checked back and it was \"available\" so I'm already pleased a project like this (goals-wise) exists.</p>",
        "id": 305896538,
        "sender_full_name": "Kristian Notari",
        "timestamp": 1666638745
    }
]