[
    {
        "content": "<p>I am not sure what to call this, other than type wrapping.  I am new to Roc and no more than intermediate level experience with strong (functional) types.  My goal, which is possibly misguided, is to take a List(U8) and specialize it with a known length and intended usage.  e.g. 32-byte sk, 32-byte pk, 64-byte sig</p>\n<p>Under roc-alpha-4, I used opaque types with some success for this.  But my focus is now roc-nightly.  With the resources I've gathered for how roc-nightly works, I did a lot of exploratory testing with LLMs to determine how to solve this problem.  Here are my findings: </p>\n<p><a href=\"https://gist.github.com/rickhull/733e6020e1995c0997016559e291b0cc\">https://gist.github.com/rickhull/733e6020e1995c0997016559e291b0cc</a></p>\n<blockquote>\n<h2>Single-variant tag unions - open type</h2>\n<p>PublicKey := [PublicKeyBytes(List(U8)), ..]<br>\nSecretKey := [SecretKeyBytes(List(U8)), ..]</p>\n<h2>Simple constructors - just wrap the bytes, no validation yet</h2>\n<p>make_public_key = |bytes| PublicKeyBytes(bytes)<br>\nmake_secret_key = |bytes| SecretKeyBytes(bytes)</p>\n</blockquote>\n<blockquote>\n<p>Single-variant tag unions are the <strong>idiomatic and working solution</strong> for type-safe wrappers in Roc. The pattern:</p>\n<ol>\n<li><strong>Use open tag unions</strong> with <code>..</code> for compatibility with Try.Ok</li>\n<li><strong>Use pattern matching</strong> for extraction (verbose but type-safe)</li>\n<li><strong>Get compile-time type safety</strong> - PublicKey ≠ SecretKey</li>\n</ol>\n<p>This is how core types like <code>Bool</code> and <code>Try</code> work in Builtin.roc.</p>\n</blockquote>\n<p>As to whether these findings are accurate, this is an open question for me.  I am not here to burden the channel with fixing my LLM dalliances, but I would like some validation, positive or negative, if I am barking up the right tree.  Thanks!</p>",
        "id": 568707118,
        "sender_full_name": "Rick Hull",
        "timestamp": 1768785041
    },
    {
        "content": "<p>Do you want to be able to hide the internal bytes so that e.g. only some functions of a specific module can access the raw bytes?</p>",
        "id": 568777019,
        "sender_full_name": "Anton",
        "timestamp": 1768821381
    },
    {
        "content": "<p>it's a chunk of data, but I want to associate a type with this chunk of data.  the type says: it is Red, not Blue.  it has this size.  So now I have Red32, Red64, Blue32, Blue64.  and the compiler can enforce that make_orange only takes Red32 and not any chunk of data.</p>\n<p>e.g. At runtime, the user provides some user input.  This could be the chunk of data.  The roc program takes the user input and constructs a Red32 according to some validation rules.  This can fail, and the user might be reprompted.</p>\n<p>Is there something flawed or wrongheaded about this idea?</p>",
        "id": 568780401,
        "sender_full_name": "Rick Hull",
        "timestamp": 1768822563
    },
    {
        "content": "<p>from what I understand, a nominal tag union with a method <code>bytes</code> that returns List(U8) would be nice.  I struggled to make this work.</p>",
        "id": 568786319,
        "sender_full_name": "Rick Hull",
        "timestamp": 1768824665
    },
    {
        "content": "<p>it's actually working great now.  Currently I have a Signature, with methods <code>create</code> and <code>bytes</code>.  there is only a single internal representation, List(U8), so I don't want to use from/to in the method names.  I was thinking of <code>create</code> / <code>resolve</code> as a more generic interface.  thoughts on method names?</p>",
        "id": 568792079,
        "sender_full_name": "Rick Hull",
        "timestamp": 1768826626
    },
    {
        "content": "<blockquote>\n<p>Is there something flawed or wrongheaded about this idea?</p>\n</blockquote>\n<p>Nope, you're good, it's a relatively common pattern. See also <a href=\"https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/\">https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/</a></p>",
        "id": 568800544,
        "sender_full_name": "Anton",
        "timestamp": 1768829136
    },
    {
        "content": "<blockquote>\n<p>thoughts on method names?</p>\n</blockquote>\n<p>I do not think that we have really built conventions around this</p>",
        "id": 568801325,
        "sender_full_name": "Anton",
        "timestamp": 1768829366
    },
    {
        "content": "<p>i don't want to use <code>unwrap</code> as that feels overloaded.  Signature \"resolves\" to a List(U8)[64] (my notation).  but i think <code>create</code> and <code>bytes</code> reads naturally and intuitively</p>",
        "id": 568806414,
        "sender_full_name": "Rick Hull",
        "timestamp": 1768830770
    },
    {
        "content": "<p>I completely agree with \"shotgun parsing\" as an antipattern.  have a defined \"filter layer\" at the front of the data pipeline that only lets \"well formed objects\" through.</p>",
        "id": 568807821,
        "sender_full_name": "Rick Hull",
        "timestamp": 1768831128
    },
    {
        "content": "<p>I've seen people use 'pack' and 'unpack' as the pair of names for this kind of thing</p>",
        "id": 568814193,
        "sender_full_name": "Dan G Knutson",
        "timestamp": 1768832773
    },
    {
        "content": "<p>ooh, that's a good one, kind of like wrap/unwrap but without overloading those terms.  in ruby and perl (C?), pack and unpack are quite sophisticated in terms of constructing binary data, whereas I am just doing simple validation.  interesting</p>",
        "id": 568820220,
        "sender_full_name": "Rick Hull",
        "timestamp": 1768834298
    },
    {
        "content": "<p>not sure if this is the right place... I'm working through Exercism and working on the Collatz one, and suddenly realized... I'm not sure how to fmap easily in Roc? </p>\n<p>I'm doing this recursively, so in a <code>when...is...</code> block, i'm pattern matching on whether it's odd/even, and adding 1 to the recursive <code>steps</code> function call. In Haskell I might `even n = succ &lt;$&gt; steps (3*n+1)</p>\n<p>But how can I add 1 to Ok(1) easily without changing the signature of <code>steps</code> to be <code>Result U64 -&gt; Result U64</code> to enable pattern matching, when I don't have <code>fmap</code>?</p>",
        "id": 569336058,
        "sender_full_name": "Rachael Sexton",
        "timestamp": 1769023075
    },
    {
        "content": "<p>(This is wrong, I know, but it should get the idea of what I'm trying to do) </p>\n<div class=\"codehilite\" data-code-language=\"roc\"><pre><span></span><code>steps : U64 -&gt; Result U64 _\nsteps = |x|\n    when x is\n        0 -&gt; Err\n        1 -&gt; Ok(0)\n        _ if Num.is_even(x) -&gt; steps(x/2) + 1\n        _ -&gt; steps(3*x + 1) + 1\n</code></pre></div>",
        "id": 569336233,
        "sender_full_name": "Rachael Sexton",
        "timestamp": 1769023135
    },
    {
        "content": "<p>Hi Rachael, I wish I could help more.  I can't tell at a glance, but are you on the new compiler or old compiler?</p>",
        "id": 569378806,
        "sender_full_name": "Rick Hull",
        "timestamp": 1769038668
    },
    {
        "content": "<p>The Exercism track is still using the old compiler, isn’t it?</p>",
        "id": 569396735,
        "sender_full_name": "Claude Précourt",
        "timestamp": 1769049307
    },
    {
        "content": "<p>Not sure, this is the roc-cli version it's unit tests are depending on <br>\n<code>pf: platform \"https://github.com/roc-lang/basic-cli/releases/download/0.20.0/X73hGh05nNTkDHU06FHC0YfFaQB1pimX7gncRcao5mU.tar.br\",</code></p>",
        "id": 569399489,
        "sender_full_name": "Rachael Sexton",
        "timestamp": 1769051261
    },
    {
        "content": "<p>Yes, almost certainly the stable Roc version documented on the website.  Outside of my very limited comfort zone.</p>",
        "id": 569400960,
        "sender_full_name": "Rick Hull",
        "timestamp": 1769052319
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"1017059\">@Rachael Sexton</span>,<br>\nYou can use the <a href=\"https://www.roc-lang.org/examples/TryOperatorDesugaring/README\"><code>?</code> operator</a> or <a href=\"https://roc-lang.org/builtins/main/Result/#map_ok\">Result.map_ok</a></p>",
        "id": 569856246,
        "sender_full_name": "Anton",
        "timestamp": 1769251953
    }
]