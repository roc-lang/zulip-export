[
    {
        "content": "<p>Hey, this is my first message here, so first congrats for making Roc, I am having a really good time digging the project!</p>\n<p>I however have some difficulties really grasping the difference between open and closed tag unions. If I send this piece of code to the REPL, I am expecting that the return type would be inferred to a closed tag as the pattern matching in the definition states all the possible return tags (and no \"_\"), but it infers an open tag instead. Is there a reason why?</p>\n<div class=\"codehilite\"><pre><span></span><code>» something = 0\n…\n… stoplightColor =\n…     if something &gt; 0 then\n…         Red\n…     else if something == 0 then\n…         Yellow\n…     else\n…         Green\n…\n… stoplightColor\n\nYellow : [ Green, Red, Yellow ]*\n</code></pre></div>\n<p>Thanks</p>",
        "id": 272773361,
        "sender_full_name": "Loric Brevet",
        "timestamp": 1645519186
    },
    {
        "content": "<p>So I could be wrong cause I don't intimately know the details of tags, but to my understand this is an open tag union, because it could be other values. There is a chance your color tag might also have <code>Purple</code> or <code>Grey</code>, but that can't be inferred from your code sample. All because the result can only be 1 of 3 possible values does not mean a color must be one of those 3 possible values.</p>",
        "id": 272776225,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645520859
    },
    {
        "content": "<p>If instead you were matching on a color like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>when color is\n    Red -&gt; #do something\n    Yellow -&gt; #another thing\n    Green -&gt; # last thing\n</code></pre></div>\n<p>That would limit to a closed union. In the <code>when</code> statement, you must deal with all the cases. Therefore, no other cases can exist in your color union</p>",
        "id": 272776370,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645520941
    },
    {
        "content": "<p>Of course, you could just add:<br>\n<code>stoplightColor : [ Green, Red, Yellow]</code><br>\nand that would also tell the compiler the type and force it to be a closed union. (not sure if that works in the repl though)</p>",
        "id": 272776581,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645521074
    },
    {
        "content": "<p>Thanks for your help, I have tried to adapt my example to use a <code>when</code> <code>is</code>, but the inferred tag is also open.</p>\n<div class=\"codehilite\"><pre><span></span><code>» something = Positive\n…\n… stoplightColor =\n…     when something is\n…         Positive -&gt; Red\n…         Negative -&gt; Yellow\n…         Equal -&gt; Green\n…\n… stoplightColor\n\nRed : [ Green, Red, Yellow ]*\n</code></pre></div>\n<p>Of course, if I change my implementation, there \"could\" be other tags introduced, but with that specific definition, I am not sure to understand why Roc does not report a closed tag union, as all the return values are explicited.</p>",
        "id": 272785411,
        "sender_full_name": "Loric Brevet",
        "timestamp": 1645526440
    },
    {
        "content": "<p>So with that example if you look at the type of <code>something</code>, it should be a closed tag for <code>[ Positive, Negative, Equal ]</code>, but <code>stoplightColor</code> is still in the same situation as before. Since it is only a result of an expressions there is no guarantee those are all of the possible values. So it is still open. The big difference is being the result of a when vs being used as the variable being matched by the when.</p>",
        "id": 272833086,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645549110
    },
    {
        "content": "<p>I've been using Roc for a few months now, and I still don't really understand open vs closed tag unions. I think that inferred openness is a default behavior in order to make a def more usable (by default) as an argument to a later function that accepts a superset of those tags.</p>",
        "id": 272841269,
        "sender_full_name": "jan kili",
        "timestamp": 1645552408
    },
    {
        "content": "<p>Essentially, I think closed tag unions <del>are kind of useless as currently implemented :/</del> are rarely preferable to open ones, for values that you're passing around (unless their implementation for function arguments is different than I remember) but I don't want to hijack this topic lol</p>",
        "id": 272841708,
        "sender_full_name": "jan kili",
        "timestamp": 1645552602
    },
    {
        "content": "<p>yeah I think I need to iterate on how to teach this; I don't think I've found a great way to teach it yet</p>",
        "id": 272843308,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645553214
    },
    {
        "content": "<p>For example (building on your last example), if <code>stringify : [ Blue, Green, Red, Yellow ] -&gt; Str</code> then I think you can't do the function call <code>stringify stoplightColor</code> if stoplightColor was closed. However, you can do it since stoplightColor is open.</p>",
        "id": 272843322,
        "sender_full_name": "jan kili",
        "timestamp": 1645553222
    },
    {
        "content": "<p>so if we didn't have closed unions, we couldn't have exhaustiveness checking</p>",
        "id": 272843379,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645553243
    },
    {
        "content": "<p>in other words, if we didn't have closed unions, all <code>when</code>s would need a <code>_ -&gt;</code> branch</p>",
        "id": 272843402,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645553255
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281383\">@Richard Feldman</span> In <span class=\"user-mention\" data-user-id=\"479004\">@Loric Brevet</span>'s last example, why is <code>stoplightColor</code> inferred to be open?</p>",
        "id": 272843646,
        "sender_full_name": "jan kili",
        "timestamp": 1645553374
    },
    {
        "content": "<p>one way to think of the answer to that question:</p>",
        "id": 272843832,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645553471
    },
    {
        "content": "<p>if I wrote <code>stoplightColor = Red</code>, then it would be open</p>",
        "id": 272843850,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645553480
    },
    {
        "content": "<p>(yeah, good reduction, that confuses me equally haha)</p>",
        "id": 272843915,
        "sender_full_name": "jan kili",
        "timestamp": 1645553517
    },
    {
        "content": "<p>if I write <code>stoplightColor =</code> and then either <code>Red</code> or <code>Green</code>, then both <code>Red</code> and <code>Green</code> are open, so no matter what, I'm still assigning it to an open union</p>",
        "id": 272843963,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645553523
    },
    {
        "content": "<p>also, if I wrote this:</p>\n<div class=\"codehilite\"><pre><span></span><code>stoplightColor =\n    when something is\n        Positive -&gt;\n            closedRed : [ Red ]\n            closedRed = Red\n\n            closedRed\n\n        Negative -&gt; Yellow\n        Equal -&gt; Green\n</code></pre></div>",
        "id": 272844101,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645553592
    },
    {
        "content": "<p>I'd get a type mismatch</p>",
        "id": 272844123,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645553602
    },
    {
        "content": "<p>because closed unions can't grow (they're closed!)</p>",
        "id": 272844147,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645553614
    },
    {
        "content": "<p>and all branches of a conditional have to be type-compatible</p>",
        "id": 272844176,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645553631
    },
    {
        "content": "<p>so when you have multiple branches of a conditional that are all open unions, it's ok - they all union together to be a bigger open union</p>",
        "id": 272844250,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645553648
    },
    {
        "content": "<p>but if any branch is a closed union, then all branches have to be exactly that closed union</p>",
        "id": 272844266,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645553657
    },
    {
        "content": "<p>otherwise type mismatch</p>",
        "id": 272844272,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645553660
    },
    {
        "content": "<p>(dang, going into dentist, this is more fun, bye)</p>",
        "id": 272844277,
        "sender_full_name": "jan kili",
        "timestamp": 1645553664
    },
    {
        "content": "<p>I think what doesn't make sense is that a function which takes a closed record can't accept an open record, but a function that takes a closed tag union can seemingly accept an open tag union value, right?</p>\n<p>Intuitively if I have a value of type <code>[Red]*</code> that means it could be <code>Red</code> or it could be any other tag at all. So how can I pass that into a function which takes <code>[Red]</code> -- if my value is <code>Blue</code> then it's incompatible with <code>[Red]</code>! Somehow this compiles:</p>\n<div class=\"codehilite\"><pre><span></span><code>main =\n  f : [Red] -&gt; Str\n  f = \\a -&gt;\n    when a is\n      Red -&gt; &quot;something&quot;\n\n  x = Red\n\n  f x\n</code></pre></div>\n<p>even though x is an open union?</p>\n<p>In my head the explanation is \"the compiler knows <code>x</code> is only ever Red even though its type is an open union\" but I'm not sure what other parts of the type system work this way -- where just from looking at the types I can give an example where exhaustiveness checking would fail, but from looking at the actual implementation I know that can't happen?</p>",
        "id": 272847089,
        "sender_full_name": "Tommy Graves",
        "timestamp": 1645554802
    },
    {
        "content": "<p>yeah, I wonder if the name \"open union\" is part of the problem <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 272847514,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645554972
    },
    {
        "content": "<p>I wonder if there's a better name that might help</p>",
        "id": 272847533,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645554979
    },
    {
        "content": "<p>like really the way the system works is that it has some very nice properties:</p>\n<ul>\n<li>soundness</li>\n<li>complete (decidable, principal) type inference</li>\n<li>compiles very fast</li>\n<li>open unions compose in a nice way with errors in particular</li>\n</ul>",
        "id": 272847650,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645555049
    },
    {
        "content": "<p>but the way it has those nice properties requires this concept that doesn't seem to map neatly onto something that appears elsewhere in programming</p>",
        "id": 272847763,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645555089
    },
    {
        "content": "<p>there's no \"open unions are basically like ______\" because they're not basically like anything I can think of <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 272847808,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645555107
    },
    {
        "content": "<p>they're a unique concept, as far as I'm aware</p>",
        "id": 272847843,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645555117
    },
    {
        "content": "<p>I have this feeling that there's a good way to teach them that gives a good intuition for how they work - I'm just not sure what that is yet! <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 272847901,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645555149
    },
    {
        "content": "<p>The good news is that <em>what</em> happens is actually intuitive (looking from the code snippet I gave before, I think it would be very surprising if it did not compile!). It's just when you actually inspect the type of a value that it gets confusing. I wonder if the type for <code>x</code> when <code>x = Red</code> should be displayed or formatted differently than <code>[ Red ]*</code> -- it's almost like there are three concepts (closed tag union, open tag union as a type annotation for a function parameter, and open tag union as the type of a value)</p>",
        "id": 272848354,
        "sender_full_name": "Tommy Graves",
        "timestamp": 1645555354
    },
    {
        "content": "<p>yeah as long as you don't include any type annotations or talk about types, everything feels intuitive <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 272848951,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645555664
    },
    {
        "content": "<p>which, to be fair, is another nice property of the system!</p>",
        "id": 272849051,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645555694
    },
    {
        "content": "<p>I return with clean teeth to find my own views expressed better than I could express them! Wonderful.</p>",
        "id": 272849159,
        "sender_full_name": "jan kili",
        "timestamp": 1645555744
    },
    {
        "content": "<p>I also don't get what \"growing\" means in the context of \"closed can't grow\"</p>",
        "id": 272849331,
        "sender_full_name": "jan kili",
        "timestamp": 1645555818
    },
    {
        "content": "<p>Yeah, I think words like \"grow\"and \"accumulate\" are tricky to understand in a language without mutation</p>",
        "id": 272849399,
        "sender_full_name": "Tommy Graves",
        "timestamp": 1645555861
    },
    {
        "content": "<p>hrm yeah, what I mean is that the union can't combine with other unions</p>",
        "id": 272849717,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645556018
    },
    {
        "content": "<p>like how in that conditional we have the tag unions <code>[ Red ]*</code>,  <code>[ Yellow ]*</code> and <code>[ Green ]*</code>, and because they're each used in a different branch of the conditional, they combine to make the entire conditional be <code>[ Red, Yellow, Green ]*</code></p>",
        "id": 272849844,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645556063
    },
    {
        "content": "<p>but closed unions in conditionals don't do that, they just give type mismatches</p>",
        "id": 272849864,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645556074
    },
    {
        "content": "<p>I think we should reimagine the syntax and terminology from a script author's perspective, since it currently feels oriented toward compiler developers</p>",
        "id": 272850653,
        "sender_full_name": "jan kili",
        "timestamp": 1645556397
    },
    {
        "content": "<p>For example, maybe we'd find that the open/closed distinction is not useful in scripts, and then we could just let it be an under-the-hood compiler inferencing/checking implementation detail</p>",
        "id": 272851122,
        "sender_full_name": "jan kili",
        "timestamp": 1645556528
    },
    {
        "content": "<p>What problems in developer space were the concepts/features around open/closed tag unions created to solve?</p>",
        "id": 272851330,
        "sender_full_name": "jan kili",
        "timestamp": 1645556639
    },
    {
        "content": "<p>Yeah, from a user perspective, I feel like they are something like \"restricted\" and \"expandable\" unions.</p>",
        "id": 272853513,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645557581
    },
    {
        "content": "<p>One with a restricted list of exact values, the other that could expand to contain anything.</p>",
        "id": 272853597,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645557609
    },
    {
        "content": "<p>exhaustive / nonexhaustive might work too, which is similar to language Rust uses for marking enums?</p>",
        "id": 272853963,
        "sender_full_name": "Emi",
        "timestamp": 1645557775
    },
    {
        "content": "<p>(Should we move this reimagination discussion to another topic? Perhaps there is a parallel how-to discussion to be had here.)</p>",
        "id": 272858140,
        "sender_full_name": "jan kili",
        "timestamp": 1645559811
    },
    {
        "content": "<p>I think it's fine to discuss here <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 272858341,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645559890
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"462053\">JanCVanB</span> <a href=\"#narrow/stream/231634-beginners/topic/open.20and.20closed.20tag.20unions/near/272851122\">said</a>:</p>\n<blockquote>\n<p>maybe we'd find that the open/closed distinction is not useful in scripts, and then we could just let it be an under-the-hood compiler inferencing/checking implementation detail</p>\n</blockquote>\n<p>we talked about this at some point, and I don't think it really works</p>",
        "id": 272858369,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645559908
    },
    {
        "content": "<p>or at least, not the way we'd been talking about it</p>",
        "id": 272858385,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645559919
    },
    {
        "content": "<p>there has to be a type variable there - that's really important</p>",
        "id": 272858450,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645559949
    },
    {
        "content": "<p>and sometimes it's not <code>*</code></p>",
        "id": 272858460,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645559953
    },
    {
        "content": "<p>(although to be fair, that's pretty rare)</p>",
        "id": 272858471,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645559958
    },
    {
        "content": "<p>I don't think we should have language syntax or semantics vary by platform</p>",
        "id": 272858548,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645559999
    },
    {
        "content": "<p>Haskell has per-project syntax/semantics and it's a big pain point in the ecosystem</p>",
        "id": 272858640,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645560018
    },
    {
        "content": "<p>one problem with hiding it syntactically in the type - that is, making there be no observable distinction between the type signature of an open or closed tag union, except in the specific and rare case that there has to be a named type variable - is that you'd sometimes get surprising type mismatches</p>",
        "id": 272859122,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645560233
    },
    {
        "content": "<p>Observations:</p>\n<ul>\n<li>Tags are great</li>\n<li>Writing <code>_ -&gt; ...</code> in every <code>when</code> could be annoying or noisy (sometimes illogical?)</li>\n<li><code>_ -&gt; ...</code> requires \"openness\" as it's currently called</li>\n</ul>",
        "id": 272859178,
        "sender_full_name": "jan kili",
        "timestamp": 1645560249
    },
    {
        "content": "<p>like a type rendered as <code>[ A, B, C ]</code> would sometimes be type-compatible with another type rendered as <code>[ A, B ]</code> and other times not, depending on whether they were secretly open or closed under the hood</p>",
        "id": 272859231,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645560276
    },
    {
        "content": "<p>that seems like it would be less confusing when it works, but <em>super</em> confusing when it didn't work</p>",
        "id": 272859257,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645560291
    },
    {
        "content": "<p><code>_ -&gt; ...</code> isn't just noisy and sometimes illogical, but also having it means you lose out on a great feature of tags</p>",
        "id": 272859349,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645560337
    },
    {
        "content": "<p>namely that if you add a new tag, you get type mismatches everywhere you need to account for it</p>",
        "id": 272859371,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645560350
    },
    {
        "content": "<p>that's a wonderful feature, and if you had <code>_ -&gt;</code> everywhere, you wouldn't get that</p>",
        "id": 272859451,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645560368
    },
    {
        "content": "<p>Could removing <code>_ -&gt; ...</code> from Roc actually be a good thing?</p>",
        "id": 272859600,
        "sender_full_name": "jan kili",
        "timestamp": 1645560458
    },
    {
        "content": "<p>good luck matching on all the integers  exhaustively</p>",
        "id": 272860068,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645560704
    },
    {
        "content": "<p>or worse, strings</p>",
        "id": 272860082,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645560712
    },
    {
        "content": "<p>I was toying around with alternative type renderings, like:<br>\nfor a parameter's type signature, display it as <code>[ A, B, _ ]</code> instead of <code>[ A, B ]*</code><br>\nfor a value's type, render it as <code>[ A, B ]+</code> instead of <code>[ A, B ]*</code></p>\n<p>Those obscure that the * is a type variable, though, which I suppose is probably relevant?</p>",
        "id": 272860166,
        "sender_full_name": "Tommy Graves",
        "timestamp": 1645560737
    },
    {
        "content": "<p><code>[ A, B, _ ]</code> has some intriguing value to me because it matches how you would pattern match the options but I'm not sure it actually helps with the conceptual problem we are talking about</p>",
        "id": 272860255,
        "sender_full_name": "Tommy Graves",
        "timestamp": 1645560795
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281543\">@Folkert de Vries</span> </p>\n<blockquote>\n<p>Could removing <code>_ -&gt; ...</code> from Roc actually be a good thing?</p>\n</blockquote>\n<p>... for tags only? Idk if that's possible...</p>",
        "id": 272860393,
        "sender_full_name": "jan kili",
        "timestamp": 1645560859
    },
    {
        "content": "<p>in theory, but in practice that will just be very annoying I think. Having a catch-all is very convenient</p>",
        "id": 272860508,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645560921
    },
    {
        "content": "<p>New observation: <code>_ -&gt; ...</code> in a tag-parsing <code>when</code> block only requires \"openness\" if the tag union isn't otherwise constrained.<br>\nExample of using a catch-all without requiring \"openness\":</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"nf\">light</span><span class=\"w\"> </span><span class=\"kt\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">Red</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Yellow</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Green</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"nf\">when</span><span class=\"w\"> </span><span class=\"n\">light</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kt\">Red</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 272865124,
        "sender_full_name": "jan kili",
        "timestamp": 1645563351
    },
    {
        "content": "<p>What if using a tag catch-all for an unconstrained tag type was disallowed? Are there any use cases that would be hindered by that?</p>",
        "id": 272865288,
        "sender_full_name": "jan kili",
        "timestamp": 1645563419
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>lightParser = \\light -&gt;\n    when light is\n        Green -&gt; &quot;good&quot;\n        _ -&gt; &quot;oh no&quot;\nlightParser Yellow\n</code></pre></div>\n<p><code>Error: Unconstrained Tag Union: lightParser must have an annotation or drop its catch-all case.</code><br>\nThis might make sense to me as a developer, but I it would be a blemish on Roc's stellar type inference claims :/</p>",
        "id": 272866268,
        "sender_full_name": "jan kili",
        "timestamp": 1645563678
    },
    {
        "content": "<p>I want something to change, but I'll stop prematurely jumping to solutions now <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 272866410,
        "sender_full_name": "jan kili",
        "timestamp": 1645563724
    },
    {
        "content": "<p>honestly, I don't think removing catch-all would help here</p>",
        "id": 272867644,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645564391
    },
    {
        "content": "<p>whether or not there's a catch-all branch, it's still the case that we very much want (and indeed need) it to be possible to return different tags from different branches of a conditional</p>",
        "id": 272867697,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645564423
    },
    {
        "content": "<p>for example, this has to work:</p>\n<div class=\"codehilite\"><pre><span></span><code>if blah then\n    True\nelse\n    False\n</code></pre></div>",
        "id": 272867719,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645564435
    },
    {
        "content": "<p><code>else</code> has the same semantics as <code>_ -&gt;</code> in <code>when</code>, and obviously we're not removing <code>else</code> <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 272867792,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645564459
    },
    {
        "content": "<p>for that conditional to work, it has to be possible to have different tags in different branches</p>",
        "id": 272867818,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645564480
    },
    {
        "content": "<p>which in turn means those can't be inferred as <code>[ True ]</code> and <code>[ False ]</code></p>",
        "id": 272867833,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645564492
    },
    {
        "content": "<p>or else that would be a type mismatch</p>",
        "id": 272867840,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645564498
    },
    {
        "content": "<p>I still feel kind of confused by this, in terms of types. It feels like [ Red ]* is treated like a subtype of [ Red ] and [ Red, Green ] while working out what returns from a branching statement, but we're telling the compiler to pretend [ Red ] isn't a subtype of [ Red, Green ] when trying to figure out what the return type of a branching thing is?</p>",
        "id": 272868844,
        "sender_full_name": "Nicholas Cahill",
        "timestamp": 1645565102
    },
    {
        "content": "<p>Here's a weird train of thought, coming from someone who doesn't know type theory, set theory, category theory, or FP:</p>\n<ul>\n<li>A type is a quantized space of possible values.</li>\n<li>A value is a point in its type's space.</li>\n<li>The <code>I8</code> type is a 1-dimensional finite space of possible <code>I8</code> values.</li>\n<li>An <code>I8</code> value is a point in <code>I8</code> space.</li>\n<li>A <code>p2 : { x : I8, y : I8 }</code> type is a 2-dimensional finite space of possible <code>p2</code> values.</li>\n<li>A <code>p2</code> value is a point in <code>p2</code> space.</li>\n<li>The <code>Str</code> type is a 1-dimensional infinite space of possible <code>Str</code> values.</li>\n<li>An <code>Str</code> value is a point in <code>Str</code> space.</li>\n<li>The tag type is a 1-dimensional infinite space of possible tag values.</li>\n<li>A tag value is a point in tag space.</li>\n<li>An open tag union is a 1-dimensional infinite discontinuous subspace of tag space?</li>\n<li>A closed tag union is a 1-dimensional finite discontinuous subspace of tag space?</li>\n<li>These type mismatches are a result of it being impossible/irresponsible (for some reason) to union non-identical finite subspaces?</li>\n<li>The tag type is the only type with subspaces, and confusion about open/closed is actually just confusion about subspaces?<br>\n<em>Alternatively, records and tags are a special \"super-\"/\"meta-\" type/space, and the aforementioned subtypes/subspaces are just normal types/spaces? My brain is hitting a theory wall... <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></em></li>\n</ul>",
        "id": 272869179,
        "sender_full_name": "jan kili",
        "timestamp": 1645565301
    },
    {
        "content": "<p>Also the idea that I can pass a [ Red ]* value to a function that needs [ Red ]</p>",
        "id": 272870336,
        "sender_full_name": "Nicholas Cahill",
        "timestamp": 1645565999
    },
    {
        "content": "<p>thinking of this as subtyping is misleading I think. Our types work with unification, basically the idea that 2 types are the same if I can substitute variables in the one type to get to the other type</p>",
        "id": 272873174,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645567586
    },
    {
        "content": "<p>so in the case of <code>[ Red ]*</code>, I can substitute <code>* = []</code> to get to <code>[ Red ]</code></p>",
        "id": 272873212,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645567609
    },
    {
        "content": "<p>but in the case of <code>[ Red ]</code>, there are no substitutions I can make to turn that into <code>[ Red, Green ]</code></p>",
        "id": 272873233,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645567624
    },
    {
        "content": "<p>yeah the way the compiler works is: whenever more than one type needs to get \"unified\" into a single type (for example, the types of each branch of a conditional must get unified into a single type, because the conditional expression as a whole needs to have a single type), there are rules for how unification works</p>",
        "id": 272876182,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645569177
    },
    {
        "content": "<p>one of the rules is that if an open tag union unifies with another open tag union, you get a new open tag union containing all the tags of both</p>",
        "id": 272876244,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645569216
    },
    {
        "content": "<p>another of the rules is that if a closed tag union unifies with a closed tag union, they must have identical type mismatch or else unification fails (which is what we call a type mismatch)</p>",
        "id": 272876323,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645569247
    },
    {
        "content": "<p>and one last rule is that whenever an open union and a closed union unify together, if the closed union contains all the tags in the open union, then they unify to the closed union...but if the open union has any tags the closed union doesn't have, then unification fails and it's a type mismatch</p>",
        "id": 272876420,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645569302
    },
    {
        "content": "<p>so those are the rules</p>",
        "id": 272876460,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645569326
    },
    {
        "content": "<p>the question is, is there a better way to explain them than just to lay them out like that?</p>",
        "id": 272876482,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645569339
    },
    {
        "content": "<p>(maybe there isn't!)</p>",
        "id": 272876498,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645569345
    },
    {
        "content": "<p>Wow, those are super direct+clear explanations, which greatly help my understanding of the system implementation. Thanks, F&amp;R!</p>",
        "id": 272877295,
        "sender_full_name": "jan kili",
        "timestamp": 1645569834
    },
    {
        "content": "<p>I think a lot of the confusion around tag unions, therefore, boils down to dissatisfaction with the unifier's level of pessimism/caution - for example, why can't two different closed tag unions be unified as a union of the two? The \"uni-\" (unify, union, union) vocabulary also reinforces that expectation.</p>",
        "id": 272877496,
        "sender_full_name": "jan kili",
        "timestamp": 1645569962
    },
    {
        "content": "<p>unification has a precise technical meaning here. If you can give me a substitution, then 2 types are \"equal up to unification\" which for us means they have an equivalent type</p>",
        "id": 272878254,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645570445
    },
    {
        "content": "<p>there is just no substitution to give between <code>[ Red ]</code> and <code>[ Red, Green ]</code> because there are no variables to even substitute</p>",
        "id": 272878285,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645570470
    },
    {
        "content": "<p>I imagine that union-y/optimistic unification might a be a bad thing to do in some situations? I feel like this pessimistic unification is shifting some kind of complexity onto developers, leading them to make every tag union open, for fear of mismatches. If that's a good practice, then we should make it a syntactically (and terminologically) simpler choice.</p>",
        "id": 272878365,
        "sender_full_name": "jan kili",
        "timestamp": 1645570512
    },
    {
        "content": "<p>there is no real thought or value judgement in these rules: this is just how the formalism works. It's a bit like why 1 + 1 is not 11. That's just not what <code>+</code> does, even though it has its own logic</p>",
        "id": 272878488,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645570569
    },
    {
        "content": "<p>We might be talking past each other here: I'm sure that tag unions are implemented in a theoretically sound manner with respect to compilers and type systems, but to Roc app developers they are marketed as a tool for domain modeling. They don't work as expected for domain modeling.</p>",
        "id": 272878697,
        "sender_full_name": "jan kili",
        "timestamp": 1645570694
    },
    {
        "content": "<p>sure, it's just that any system you come up with ultimately should work within this framework of substitutions</p>",
        "id": 272878868,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645570795
    },
    {
        "content": "<p>also a more restrictive version of this (sum types) seems to work fine in elm/haskell/ocaml/...</p>",
        "id": 272879035,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645570843
    },
    {
        "content": "<p>we already provide a bunch more  flexibility</p>",
        "id": 272879072,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645570862
    },
    {
        "content": "<p>I feel like with domain modeling you essentially always want closed unions. You are trying to capture all of the possibilities of each piece of your domain. As such, to merge two unions, you have to make a wrapper union</p>\n<div class=\"codehilite\"><pre><span></span><code>A : [ Foo, Bar ]\nB : [ Baz, Bump ]\nAorB : [ SomeA A, SomeB B ]\n</code></pre></div>\n<p>That would be merging A and B. It wouldn't make sense to do it otherwise.</p>",
        "id": 272879293,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645570997
    },
    {
        "content": "<p>I don't think you want the super union of <code>AB : [ Foo, Bar Baz, Bump ]</code></p>",
        "id": 272879344,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645571041
    },
    {
        "content": "<p>That elides information about the orginal unions they came from.</p>",
        "id": 272879398,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645571057
    },
    {
        "content": "<p>right, and if that is what you want then you can write the functions to make it happen</p>",
        "id": 272879461,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645571100
    },
    {
        "content": "<p>What should be done here? (Genuinely asking, as I'm still learning DDD.)</p>\n<div class=\"codehilite\"><pre><span></span><code>Animal : [ Cat, Dog, Lion, Tiger ]\nPet : [ Cat, Dog ]\nbreed : Animal, Animal -&gt; List Animal\ndog1 : [ Dog ]\ndog2 : [ Dog ]\n</code></pre></div>\n<p>I want to do <code>puppies = breed dog1 dog2</code>, but I think that would generate a type mismatch because Pet can't be unified with Animal.</p>",
        "id": 272880114,
        "sender_full_name": "jan kili",
        "timestamp": 1645571552
    },
    {
        "content": "<p>yes</p>",
        "id": 272880267,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645571686
    },
    {
        "content": "<p>you're trying to do subtyping</p>",
        "id": 272880274,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645571694
    },
    {
        "content": "<p>why?</p>",
        "id": 272880276,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645571695
    },
    {
        "content": "<p>One option:</p>\n<div class=\"codehilite\"><pre><span></span><code>Animal : [ Pet Pet, Wild Wild ]\nPet : [ Cat, Dog ]\nWild : [ Lion, Tiger ]\n</code></pre></div>\n<p>Another :</p>\n<div class=\"codehilite\"><pre><span></span><code>Animal : [ Cat, Dog, Lion, Tiger ]\nisPet : Animal -&gt; Bool\n</code></pre></div>",
        "id": 272880330,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645571742
    },
    {
        "content": "<p>Specifically, for the function:</p>\n<div class=\"codehilite\"><pre><span></span><code>dog1 : Animal\ndog1  = Pet (Dog &quot;whatever properties&quot;)\n</code></pre></div>\n<p>Then with the  breed you would just match on the union. It will fail on an animal type mismatch. Returning a result with an error</p>",
        "id": 272880563,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645571902
    },
    {
        "content": "<p>for a bit more context: this example looks exactly like the sort of thing you'd as the first example of class hierarchies in object-oriented programming and coming from the FP tradition that just does not make sense to me</p>",
        "id": 272880608,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645571943
    },
    {
        "content": "<p>That's 100% true, but we still have to enable a way to model it. That model may 100% throw out the hierarchy or do thing very different, but if someone wants to solve a problem like this, there still needs to be a solution.</p>",
        "id": 272880736,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645572025
    },
    {
        "content": "<p>yeah but then my question is what the shared behavior actually is here</p>",
        "id": 272880930,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645572163
    },
    {
        "content": "<p>Side note, I'm unsure how to proceed because:</p>\n<ol>\n<li>I accidentally picked an OOP-like example, but my real point was that I think it's weird that tag functions reject inputs for being too-specific</li>\n<li>I want to learn FP and ditch my problematic OOP tendencies</li>\n<li>I want Roc to be welcoming to emigrants from OOP</li>\n</ol>\n<p><span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 272881493,
        "sender_full_name": "jan kili",
        "timestamp": 1645572581
    },
    {
        "content": "<p>I guess my question is why is <code>dog1</code> a <code>[ Dog ]</code> in your example? Just make it a <code>[ Dog ]*</code> or <code>Animal</code> and everything  works.</p>",
        "id": 272882864,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645573482
    },
    {
        "content": "<p>Also, I am totally for trying to take a few full baked OOP examples and then trying to convert them into idiomatic Roc. That would probably be a good mini tutorial repo.</p>",
        "id": 272883033,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645573575
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"343810\">@Brendan Hansknecht</span></p>\n<blockquote>\n<p>I guess my question is why is <code>dog1</code> a <code>[ Dog ]</code> in your example? Just make it a <code>[ Dog ]*</code> or <code>Animal</code> and everything  works.</p>\n</blockquote>\n<p>In the context of domain modeling, is it always best to use closed tag unions for all type aliases and open tag unions for all value annotations? It seems that way, to maximize flexibility.</p>",
        "id": 272889004,
        "sender_full_name": "jan kili",
        "timestamp": 1645577846
    },
    {
        "content": "<p>I'd hesitate to say \"always\" whenever it comes to domain modeling, but off the top of my head I can't think of a situation where it would be a good idea to use an open tag union for domain modeling <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 272889176,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645577980
    },
    {
        "content": "<p>that said, I think it's fine to annotate values as closed unions if you know that's how they're going to be used</p>",
        "id": 272889238,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645578004
    },
    {
        "content": "<p>for example, I think annotating something as <code>Bool</code> (which is a type alias for <code>[ True, False ]</code>) is better than annotating it as <code>[ True ]*</code> even if that's technically more flexible <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 272889334,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645578043
    },
    {
        "content": "<p>I mean, let's be honest - you know that <code>[ True ]*</code> is gonna end up as a <code>Bool</code></p>",
        "id": 272889357,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645578068
    },
    {
        "content": "<p>and if it doesn't, it's because I made a mistake and I'd rather the compiler told me about it!</p>",
        "id": 272889372,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645578084
    },
    {
        "content": "<p>Okay yeah; I think describing these things as tag unions made me _really_ want to think of them as union types</p>",
        "id": 272894293,
        "sender_full_name": "Nicholas Cahill",
        "timestamp": 1645580906
    },
    {
        "content": "<p>Are they somehow not union types? I am not sure I understand the comment. Can you define union types?</p>",
        "id": 272894972,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645581506
    },
    {
        "content": "<p>They're unions with extra rules: closed unions can't be unioned further, and open unions are somewhat infinite</p>",
        "id": 272895219,
        "sender_full_name": "jan kili",
        "timestamp": 1645581655
    },
    {
        "content": "<p>A union type is a type that has its union members as subtypes, so you get variances in values and function constraints from them.</p>",
        "id": 272895255,
        "sender_full_name": "Nicholas Cahill",
        "timestamp": 1645581693
    },
    {
        "content": "<p>Should the takeaway for app developers be \"in your tag types, delete this asterisk to get stricter type checking by disallowing passage to more-general-purpose functions\"? If so, maybe they should be renamed like this</p>\n<ul>\n<li>\"open tag union\" --&gt; \"tag set\" or \"tag subset\" or \"tag subdomain\"... to communicate their unionability and that their handlers can handle other things, too</li>\n<li>\"closed tag union\" --&gt; \"strict tag set\" or \"final/total tag set\" or \"tag domain\"... to communicate their un-unionability and that their handlers must explicitly handle all of their (and only their) cases</li>\n</ul>\n<p>A complementary syntax change for <code>[ A, B, C ]*</code> / <code>[ A, B, C ]</code> might be <code>[ A, B, C ]</code> / <code>[[ A, B, C ]]</code> or <code>( A, B, C )</code> / <code>[ A, B, C ]</code>, to make the former simpler &amp; gentler. (This ignores <code>[ A, B ]c</code> because I don't grasp its intuitions yet.)</p>",
        "id": 272895373,
        "sender_full_name": "jan kili",
        "timestamp": 1645581767
    },
    {
        "content": "<p>Like, Result = [ Ok Str, Err Str ] isn't a union of an Ok type and an Err type. Conceptually anyway. It's just its own type, and Ok Str isn't a subtype of it</p>",
        "id": 272895530,
        "sender_full_name": "Nicholas Cahill",
        "timestamp": 1645581924
    },
    {
        "content": "<p>Like when I say Ok \"okay okay\", I didn't instantiate an Ok, I instantiated a Result</p>",
        "id": 272895628,
        "sender_full_name": "Nicholas Cahill",
        "timestamp": 1645582026
    },
    {
        "content": "<p>It might be helpful to not try to think in terms of subtyping, because there is no subtyping in Roc</p>",
        "id": 272895724,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1645582119
    },
    {
        "content": "<p>Ok, so I get the result comment.<br>\nWhat is an example of a proper union type?</p>",
        "id": 272895752,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645582157
    },
    {
        "content": "<p>Let's see. So if I was writing Elixir, I could do something like</p>\n<div class=\"codehilite\" data-code-language=\"Elixir\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">magnitude</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">when</span><span class=\"w\"> </span><span class=\"n\">is_number</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"k\">end</span><span class=\"w\"></span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">magnitude</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">when</span><span class=\"w\"> </span><span class=\"n\">is_string</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"nc\">String</span><span class=\"o\">.</span><span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"k\">end</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Then magnitude is a function that can take a string or an integer, no tags or anything like that.</p>",
        "id": 272897096,
        "sender_full_name": "Nicholas Cahill",
        "timestamp": 1645583426
    },
    {
        "content": "<p>I really need to learn how to make things look nicer in Zulip...</p>",
        "id": 272897107,
        "sender_full_name": "Nicholas Cahill",
        "timestamp": 1645583452
    },
    {
        "content": "<p>Replace these single-quotes with backticks:</p>\n<div class=\"codehilite\"><pre><span></span><code>&#39;&#39;&#39;\ncode\n&#39;&#39;&#39;\n</code></pre></div>",
        "id": 272897167,
        "sender_full_name": "jan kili",
        "timestamp": 1645583511
    },
    {
        "content": "<p>You also can add the language name after the first set of backticks to get syntax highlighting if the language is supported.</p>",
        "id": 272897378,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645583691
    },
    {
        "content": "<p>And interesting example, that would have never crossed my mind as a union at all. More like an interesting for of overloading a function. But I guess my background in unions come from c/c++ and rust.</p>",
        "id": 272897415,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645583749
    },
    {
        "content": "<p>I think the name \"tag set\" is interesting <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 272897484,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645583800
    },
    {
        "content": "<p>Using these tagged types, it might look more like this:</p>\n<div class=\"codehilite\" data-code-language=\"Elixir\"><pre><span></span><code><span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">magnitude</span><span class=\"p\">({</span><span class=\"ss\">:int</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">i</span><span class=\"w\"></span>\n<span class=\"k\">end</span><span class=\"w\"></span>\n<span class=\"kd\">def</span><span class=\"w\"> </span><span class=\"n\">magnitude</span><span class=\"p\">({</span><span class=\"ss\">:string</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">do</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nc\">String</span><span class=\"o\">.</span><span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"k\">end</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This input type would be something like [Int Int, String String]</p>",
        "id": 272897491,
        "sender_full_name": "Nicholas Cahill",
        "timestamp": 1645583815
    },
    {
        "content": "<p>Oh yeah, knowing how to format stuff rules</p>",
        "id": 272897500,
        "sender_full_name": "Nicholas Cahill",
        "timestamp": 1645583847
    },
    {
        "content": "<p>That example isn't quite perfect either, you'd want to use a struct to make it pickier</p>",
        "id": 272897605,
        "sender_full_name": "Nicholas Cahill",
        "timestamp": 1645583980
    },
    {
        "content": "<p>Yeah, and in roc, it would be something like:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">magnitude : </span><span class=\"p\">[</span> <span class=\"nx\">Int</span> <span class=\"nx\">I64</span><span class=\"p\">,</span> <span class=\"nx\">Str</span> <span class=\"nx\">Str</span> <span class=\"p\">]</span> <span class=\"nf\">-&gt;</span> <span class=\"nx\">I64</span>\n<span class=\"nv\">magnitude = </span><span class=\"err\">\\</span><span class=\"nx\">x</span> <span class=\"nf\">-&gt;</span>\n    <span class=\"k\">when</span> <span class=\"nx\">x</span> <span class=\"o\">is</span>\n        <span class=\"nx\">Int</span> <span class=\"nx\">i</span> <span class=\"nf\">-&gt;</span> <span class=\"nx\">i</span>\n        <span class=\"nx\">Str</span> <span class=\"nx\">s</span> <span class=\"nf\">-&gt;</span> <span class=\"nx\">Str</span><span class=\"p\">.</span><span class=\"nx\">len</span> <span class=\"nx\">s</span>\n</code></pre></div>",
        "id": 272897615,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645583995
    },
    {
        "content": "<p>(incidentally, the reason they're called \"tag unions\" is in large part because in memory they are <a href=\"https://en.wikipedia.org/wiki/Tagged_union\">tagged unions</a>)</p>",
        "id": 272897620,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1645584000
    },
    {
        "content": "<p>Definitely quite different from how the first example would actually compile and work, but similar to your second example, just with a single function and a match.</p>",
        "id": 272897705,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645584065
    },
    {
        "content": "<p>Yeah. That Elixir example is maybe a bad one because it still IS kind of a union. I think in most languages you're forced to give something like [ Int I64, Str Str] a name and reference that name when instantiating it, so it's clearer that it doesn't necessarily have anything to do (in terms of not having any kind of subtype/supertype relationship ) with [ Int I64, Str Str, Bool Bool ]</p>",
        "id": 272898352,
        "sender_full_name": "Nicholas Cahill",
        "timestamp": 1645584760
    },
    {
        "content": "<p>Like a Rust Result has Ok and Err in it, but Ok and Err don't mean anything outside of the context of Result. They're really Result::Ok and Result::Err</p>",
        "id": 272898516,
        "sender_full_name": "Nicholas Cahill",
        "timestamp": 1645584922
    },
    {
        "content": "<p>I get the feeling that there is a more defined question lurking beneath this discussion. I think it might be \"open to whom?\"</p>\n<p>When returning tags from a function or a conditional, I know that no one can add additional tags. So while all the tags I use should combine, the result is a closed union.</p>\n<p>When I use a tag union, I need to know if I am seeing all possible tags. If I own all the code, I'm good. What the compiler sees is all there is. But if I am exposing a function, I need to decide whether people can only use the tags I specified or whether I allow them to use additional ones.</p>\n<p>So maybe there is some useful line to draw for internal and exposed types?</p>",
        "id": 273078515,
        "sender_full_name": "Johannes Maas",
        "timestamp": 1645703237
    },
    {
        "content": "<p>In the use case of a function, from a developer's point of view, I feel that we can also think differently depending on inputs/outputs.</p>\n<p>To me, and as a true beginner in Roc (this topic was the first message I posted on Zulip after having dug Roc for a few days), I can see two different definitions of open/closed for inputs and outputs.</p>\n<p>For inputs, it is rather understandable for someone new to the language.</p>\n<p>Inputs of a function:</p>\n<ul>\n<li>A closed tag union means that the function only accepts a predefined (closed) set of tags and nothing else.</li>\n<li>An open tag union means the function may accept more tags, and so it provides a \"_\" to handle a tag that does not belong to the expected ones.</li>\n</ul>\n<p>From what I read from this discussion, the way it works for outputs is more because of the implementation details. The compiler has to have a type that combines all the possible tags of a pattern matching, and this results in an open tag union. So the difference between a returned open tag union and a closed tag union is more difficult to understand out of the box.</p>\n<p>If I try to define them.</p>\n<p>Outputs of a function:</p>\n<ul>\n<li>A returned closed tag union represents the entire set of tags that the function can return (easy).</li>\n<li>An returned open tag union is ??? It seems it also represents the entire set of tags that the function can return, but in a way that it can be expanded later on in the program?</li>\n</ul>\n<p>To me, this is the last one that is hard to comprehend easily.</p>",
        "id": 273103783,
        "sender_full_name": "Loric Brevet",
        "timestamp": 1645716426
    },
    {
        "content": "<p>right its a tag union with at least the tags that this function can return, but others can add to it</p>",
        "id": 273104315,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645716648
    },
    {
        "content": "<p>this happens often when dealing with errors</p>",
        "id": 273104332,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645716655
    },
    {
        "content": "<p>a particular function can only return (say) 3 different errors, but then you combine it with another function that can return 2 different ones</p>",
        "id": 273104387,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1645716682
    },
    {
        "content": "<p>Loric phrased it better than I did: Does it help to automatically manage the openness of outputs and only bother the developer with that for inputs?</p>",
        "id": 273107473,
        "sender_full_name": "Johannes Maas",
        "timestamp": 1645717935
    },
    {
        "content": "<p>This example for errors makes sense.</p>\n<p>But on that occasion, wouldn’t it be better to have a type alias that aliases to the full set of available errors (so a closed tag union), so that the function can return this specifically?</p>\n<div class=\"codehilite\"><pre><span></span><code>HttpError : [ NotFound, BadGateway, Unauthorized ]\n\ntoHttpError : [ NothingHere, NotAuthenticated ]* -&gt; HttpError\ntoHttpError = \\err -&gt;\n    when err is\n        NothingHere -&gt; NotFound\n        NotAuthenticated -&gt; Unauthorized\n        _ -&gt; NotFound\n</code></pre></div>\n<p>If <code>toHttpError</code> would not be annotated, the compiler would still infer that to <code>[ NotFound, Unauthorized ]*</code>, but from a design perspective, annotating with the alias could make more sense?</p>",
        "id": 273107662,
        "sender_full_name": "Loric Brevet",
        "timestamp": 1645718014
    },
    {
        "content": "<p>I think the advantage of open tag unions is that it is quite bothersome to manage that alias. In Rust I tend to have to create many different error types and adding a new error variant is tedious.</p>\n<p>In that case implicitly declaring the variants using an open union is much more ergonomic without an obvious downside.</p>",
        "id": 273108086,
        "sender_full_name": "Johannes Maas",
        "timestamp": 1645718180
    },
    {
        "content": "<p>I'm wondering, what is a use case for accepting an open union in e. g. a function? Why would I want to handle external variants?</p>",
        "id": 273108250,
        "sender_full_name": "Johannes Maas",
        "timestamp": 1645718264
    },
    {
        "content": "<p>I'm wondering the same thing. <del>Having a catch-all case (<code>_ -&gt;</code>) for tags requires that function accepting an open tag union, and this pattern is prevalent in the tutorial:</del></p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"nf\">stoplightStr</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">when</span><span class=\"w\"> </span><span class=\"n\">stoplightColor</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kt\">Red</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"red\"</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"not red\"</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 273111994,
        "sender_full_name": "jan kili",
        "timestamp": 1645719709
    },
    {
        "content": "<p><del>However, is this an anti-pattern? What are some real-world use cases where this convenience/flexibility leads to better code than explicitly handling every tag in the union?</del></p>",
        "id": 273112155,
        "sender_full_name": "jan kili",
        "timestamp": 1645719767
    },
    {
        "content": "<p>I started to come up with an example:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"nf\">format</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"ne\">error</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">when</span><span class=\"w\"> </span><span class=\"ne\">error</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kt\">Unauthorized</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"kt\">:</span><span class=\"w\"> </span><span class=\"mi\">401</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">message</span><span class=\"kt\">:</span><span class=\"w\"> </span><span class=\"s\">\"Unauthorized\"</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kt\">NotFound</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"kt\">:</span><span class=\"w\"> </span><span class=\"mi\">404</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">message</span><span class=\"kt\">:</span><span class=\"w\"> </span><span class=\"s\">\"Not Found\"</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kt\">BadGateway</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"kt\">:</span><span class=\"w\"> </span><span class=\"mi\">502</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">message</span><span class=\"kt\">:</span><span class=\"w\"> </span><span class=\"s\">\"Bad Gateway\"</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"kt\">:</span><span class=\"w\"> </span><span class=\"mi\">500</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">message</span><span class=\"kt\">:</span><span class=\"w\"> </span><span class=\"s\">\"Internal Server Error\"</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>but I don't see how this code wouldn't benefit from the addition of an <code>InternalServerError</code> or <code>Other</code> tag.</p>",
        "id": 273112240,
        "sender_full_name": "jan kili",
        "timestamp": 1645719815
    },
    {
        "content": "<p>Especially since handling multiple cases is concise:</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"nf\">stoplightStr</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">when</span><span class=\"w\"> </span><span class=\"n\">stoplightColor</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kt\">Red</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"red\"</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kt\">Yellow</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">Green</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"not red\"</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 273112347,
        "sender_full_name": "jan kili",
        "timestamp": 1645719848
    },
    {
        "content": "<p>Actually, the catch-all case doesn't require open tag union input, nevermind:</p>\n<div class=\"codehilite\" data-code-language=\"Pan\"><pre><span></span><code>»<span class=\"w\"> </span>f<span class=\"w\"> </span>:<span class=\"w\"> </span><span class=\"o\">[</span><span class=\"w\"> </span>A,<span class=\"w\"> </span>B,<span class=\"w\"> </span>C<span class=\"w\"> </span><span class=\"o\">]</span><span class=\"w\"> </span>-&gt;<span class=\"w\"> </span>Str<span class=\"w\"></span>\n…<span class=\"w\"> </span><span class=\"nv\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"se\">\\t</span><span class=\"w\"> </span>-&gt;<span class=\"w\"></span>\n…<span class=\"w\">     </span>when<span class=\"w\"> </span>t<span class=\"w\"> </span>is<span class=\"w\"></span>\n…<span class=\"w\">         </span>A<span class=\"w\"> </span>-&gt;<span class=\"w\"> </span><span class=\"s2\">\"a\"</span><span class=\"w\"></span>\n…<span class=\"w\">         </span>_<span class=\"w\"> </span>-&gt;<span class=\"w\"> </span><span class=\"s2\">\"x\"</span><span class=\"w\"></span>\n…<span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span>a:<span class=\"w\"> </span>f<span class=\"w\"> </span>A,<span class=\"w\"> </span>b:<span class=\"w\"> </span>f<span class=\"w\"> </span>B,<span class=\"w\"> </span>c:<span class=\"w\"> </span>f<span class=\"w\"> </span>C<span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"></span>\n\n<span class=\"o\">{</span><span class=\"w\"> </span>a:<span class=\"w\"> </span><span class=\"s2\">\"a\"</span>,<span class=\"w\"> </span>b:<span class=\"w\"> </span><span class=\"s2\">\"x\"</span>,<span class=\"w\"> </span>c:<span class=\"w\"> </span><span class=\"s2\">\"x\"</span><span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"> </span>:<span class=\"w\"> </span><span class=\"o\">{</span><span class=\"w\"> </span>a<span class=\"w\"> </span>:<span class=\"w\"> </span>Str,<span class=\"w\"> </span>b<span class=\"w\"> </span>:<span class=\"w\"> </span>Str,<span class=\"w\"> </span>c<span class=\"w\"> </span>:<span class=\"w\"> </span>Str<span class=\"w\"> </span><span class=\"o\">}</span><span class=\"w\"></span>\n\n»<span class=\"w\"></span>\n</code></pre></div>",
        "id": 273112865,
        "sender_full_name": "jan kili",
        "timestamp": 1645720065
    },
    {
        "content": "<p>So, if <code>_ -&gt;</code> can still be used to handle all remaining tags in a closed tag union, the use case in question (for open tag unions as function inputs) seems to shrink to (a) some kind of polymorphism and (b) parsing tag unions defined outside your codebase. These seem like they could be useful in a library, but what are some real-world examples?</p>",
        "id": 273113083,
        "sender_full_name": "jan kili",
        "timestamp": 1645720158
    },
    {
        "content": "<p>On another note, after private messaging with <span class=\"user-mention\" data-user-id=\"454654\">@Ayaz Hafiz</span> the other night, I feel like I understand the ideas behind open/closed tag unions much better now. Thanks, Ayaz :)</p>",
        "id": 273113247,
        "sender_full_name": "jan kili",
        "timestamp": 1645720227
    },
    {
        "content": "<p>I'm happy to share, but I don't want to steal Ayaz's thunder if a big post is coming soon</p>",
        "id": 273113394,
        "sender_full_name": "jan kili",
        "timestamp": 1645720283
    },
    {
        "content": "<p>Each day I'm feeling less sure about how to improve tag unions, because as I learn more about them I'm less eager to downgrade/nerf/gut their powerful flexibility... but they're still so confusing...</p>",
        "id": 273113889,
        "sender_full_name": "jan kili",
        "timestamp": 1645720481
    },
    {
        "content": "<p>I feel like a rioting peasant who has been invited into the castle to dine with the king, and now that I've gotten to know him I'm unsure about beheading him... <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 273114243,
        "sender_full_name": "jan kili",
        "timestamp": 1645720615
    },
    {
        "content": "<p>Frankly, I essentially just see open tag unions as a way to make type checking simpler, and to make more dynamic roc program easier to write.</p>\n<p>If I was writing a large production grade app, I would probably use closed tag unions almost all of the time. Even with error types, if you use an open union you may end up getting multiple essentially identical variants. It's better to control and centralize that list and share an alias than to generate it from merging unions.</p>",
        "id": 273116135,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645721341
    },
    {
        "content": "<p>Of course I can think of exceptions. For example, maybe an error returned from a library should be an open union so that it can be used more flexibly and get merged into the applications error type. But it also wouldn't harm an application much if it wasn't open. The application would just have to wrap or transform the libraries union.</p>",
        "id": 273116672,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1645721530
    },
    {
        "content": "<p>I think I have the same feeling <span class=\"user-mention\" data-user-id=\"462053\">@JanCVanB</span> about understanding those tags better each day, and accepting this design as being correct. And yes there will be exceptions where open unions will make more sense. And maybe this will lead to some patterns that could become \"idiomatic\" in Roc in the future.</p>\n<p>The real problem with all of that is the learning curve for beginners. I am sure plenty of people will have the same questioning and so the answer might be to \"simply\" find the correct way to teach them, as <span class=\"user-mention\" data-user-id=\"281383\">@Richard Feldman</span> told in a previous comment. But I am sure that explained slowly and iteratively, it could become rapidly at hand for newcomers.</p>\n<p>I would look forward to reading a good blog post about it if anyone decides to take the plunge!</p>",
        "id": 273119569,
        "sender_full_name": "Loric Brevet",
        "timestamp": 1645722693
    },
    {
        "content": "<p>The good news is that we've recognized early on that this is a major point of confusion. I think by the time the language \"goes public\" there will be a very well rehearsed, compelling, and sensible way to explain them -- and I am pretty confident the terminology of open/closed will get replaced with something much more illuminating.</p>",
        "id": 273119913,
        "sender_full_name": "Tommy Graves",
        "timestamp": 1645722834
    },
    {
        "content": "<p>I intend to write a more full description of why these kinds of tag unions (and extensible records) are useful and give intuitions for their behavior at some point. I think we have a few good partial explanations floating around, and there are good external resources too, they just need to be aggregated and exposed in a more accessible way.</p>\n<p>In the meantime, here is a short note I wrote to try to help explain the difference between how Roc's tag unions work and how subtyping works, that I shared with <span class=\"user-mention\" data-user-id=\"462053\">@JanCVanB</span>. It's not polished and may not be the most helpful in the world, but I hope someone can get something out of it, if they are wondering. <a href=\"https://gist.github.com/ayazhafiz/bfeb59736e746d150678bdabfb5226cd\">https://gist.github.com/ayazhafiz/bfeb59736e746d150678bdabfb5226cd</a></p>",
        "id": 273121142,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1645723326
    },
    {
        "content": "<p>Thanks for that gist, Ayaz, it's great</p>",
        "id": 273127315,
        "sender_full_name": "jan kili",
        "timestamp": 1645725995
    },
    {
        "content": "<p>Making connections between <code>[ A ]*</code> and <code>Int *</code> is helpful</p>",
        "id": 273127444,
        "sender_full_name": "jan kili",
        "timestamp": 1645726061
    },
    {
        "content": "<p>I'm finding that there is no common app-level intuition for what <code>*</code> means - it means something different in tags vs records vs numbers. However, it always means the same thing from a compiler perspective - specialization.</p>",
        "id": 273127690,
        "sender_full_name": "jan kili",
        "timestamp": 1645726165
    },
    {
        "content": "<p>That is an excellent explanation Ayaz!</p>",
        "id": 273127951,
        "sender_full_name": "Tommy Graves",
        "timestamp": 1645726300
    },
    {
        "content": "<p>I had some fun gathering my thoughts and working out a document. I think I managed to lay out a slight modification (allowing composition of closed tag unions) that might help with this problem: <a href=\"https://gist.github.com/j-maas/ed3d2811d808d0fa1386478575df928d\">https://gist.github.com/j-maas/ed3d2811d808d0fa1386478575df928d</a></p>\n<p>Feel free to point out any mistakes in that argumentation! :)</p>",
        "id": 273553464,
        "sender_full_name": "Johannes Maas",
        "timestamp": 1646082139
    }
]