[
    {
        "content": "<p>Hi, I installed ROC today and started playing around a bit to try to learn the language, and Iâ€™m finding it really interesting so far.</p>\n<p>I got a question about how to access a Tuple or a Record based on a variable, for example:</p>\n<div class=\"codehilite\"><pre><span></span><code>record = { foo: &quot;bar&quot;, fizz: &quot;buzz&quot; }\nkey = &quot;fizz&quot;\n# how can I access the field based on the value of `key` without hardcoding record.fizz?\n</code></pre></div>\n<div class=\"codehilite\"><pre><span></span><code>tuple = (&quot;foo&quot;, &quot;bar&quot;)\nindex = 1\n# how can I access the element at `index` in the tuple using the variable `index`\n# without hardcoding tuple.1?\n</code></pre></div>",
        "id": 562277011,
        "sender_full_name": "Minato 13",
        "timestamp": 1765071296
    },
    {
        "content": "<p>You have two main options</p>",
        "id": 562281446,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1765077688
    },
    {
        "content": "<p>One, use different data structures for dynamic acces. Instead of a record, use a dictionary. Instead of a tuple, use a list.</p>",
        "id": 562281457,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1765077714
    },
    {
        "content": "<p>Two, write a mapping function for access. (Though maybe we should autogenerate this for tuple at least).</p>",
        "id": 562281476,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1765077742
    },
    {
        "content": "<p>Something like (I hope this is the right syntax for match):</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"n\">getTup</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">tup</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">index</span><span class=\"o\">|</span><span class=\"w\">  </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">match</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"no\">Ok</span><span class=\"p\">(</span><span class=\"n\">tup</span><span class=\"o\">.</span><span class=\"mi\">0</span><span class=\"p\">),</span>\n<span class=\"w\">        </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"no\">Ok</span><span class=\"p\">(</span><span class=\"n\">tup</span><span class=\"o\">.</span><span class=\"mi\">1</span><span class=\"p\">),</span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"no\">Err</span><span class=\"p\">(</span><span class=\"no\">OutOfBounds</span><span class=\"p\">),</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 562281552,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1765077864
    },
    {
        "content": "<p>Can do something equivalent for the string keys and the record.</p>",
        "id": 562281558,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1765077880
    },
    {
        "content": "<p>Oh, one other note for these. You can also use lambdas.</p>",
        "id": 562281571,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1765077907
    },
    {
        "content": "<p>So <code>.foo</code> should give you a function to extra the foo field from a record. Some with <code>.1</code> for a tuple.</p>",
        "id": 562281581,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1765077932
    },
    {
        "content": "<p>That might also be enough for your use case.</p>",
        "id": 562281583,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1765077939
    },
    {
        "content": "<p>+1 to what Brendan has said. Roc doesn't have runtime type information, so when you want to do something truly dynamic (e.g. you read a string from stdin and you access <code>record.&lt;str-content-here&gt;</code>, in JS it would be <code>record[strContent]</code>), you have to do the mapping at compile time (Brendan's <code>getTup</code> is like that), or you need a datastructure that will do that mapping for you at runtime. </p>\n<p><em>In hindsight I see, I've gone way overboard with this answer. Don't worry, you don't have to understand this to use roc.</em></p>\n<p>A record is just like a tuple in Roc, except the fields have a \"proper\" name, not just numbers. They are both like a C struct if you're familiar with them. Your <code>record</code> var will take up 48 bytes. 24 for each of the 2 strings. A string is 8+8+8 bytes on your system (A pointer to the start of the string, a length and another number that helps with managing its memory).  These 2 strings are just one-after-another when your program executes and the interpreter doesn't know what the name of each field in your source code was. For that, it would have to store those names as well, making the struct double its size. You could imagine a simple algorithm running on <code>record[strContent]</code> that would search for strContent in the record's list of fieldnames and when it finds it (if it finds it), returns the value with the same index. But that wouldn't be enough either, because if you have a <code>record = { foo: \"bar\", fizz: True, buzz: False }</code>,  <code>record</code> takes up (24+1+1) bytes, 1 byte for each boolean. There it's not enough to say \"get the 3rd element\", because how do you know where that is? It is at offset byte 25 (zero-indexed) from the start of the struct, but for that to be dynamic, we would have to know at runtime how big each of the fields are (runtime type information), so that we could do the calculation of \"it starts at offset 24+1\". All that to say, structs are not dictionaries that have all this machinery in them, but we have (will have once implemented) Dict-s that handle this use case. They are also nicer in that they handle the case when there isn't such key as you have provided, while structs and tuples will only access fields that are guaranteed there.</p>",
        "id": 562289808,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1765090123
    }
]