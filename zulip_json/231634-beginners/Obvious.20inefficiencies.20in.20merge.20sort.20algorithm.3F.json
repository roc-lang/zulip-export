[
    {
        "content": "<p>Can anyone see any obvious inefficiencies in my merge sort algorithm here? Implemented just for fun in Roc (as well as quicksort). However my mergesort is an order of magnitude (or several depending on list size) worse than my quicksort, despite them having theoretically the same time complexity - O(n log n)</p>\n<p>Note that in order to sort the 100k element list with mergesort, I had to quadruple my stack limit from 8mb to 32mb (quicksort has no issues with a 1m list). </p>\n<p>The mergesort is of course using recursion instead of List.walk to do the main sorting, which will increase stack usage, but <code>merge</code> should still recurse at most O(n) at each level of mergesort recursion, just like List.walk is O(n) at each level of recursion in quicksort.</p>\n<p>Either way, the change from walking the list to recursion doesn't explain 3 orders of magnitude difference to me...</p>\n<div class=\"codehilite\"><pre><span></span><code>&gt; List.sortWith: sorted 100k elements in 117ms\n----------------------------------\n&gt; Sort.quicksort: sorted 100k elements in 248ms\n----------------------------------\n&gt; Sort.mergesort: sorted 100k elements in 122340ms\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Elm\"><pre><span></span><code><span class=\"nv\">mergesort</span><span class=\"w\"> </span><span class=\"nf\">:</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"nv\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">a</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">LT</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">EQ</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">GT</span><span class=\"p\">])</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"nv\">a</span>\n<span class=\"nv\">mergesort</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"nv\">list</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">compare</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"nv\">list</span><span class=\"w\"> </span><span class=\"nf\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"kr\">then</span>\n<span class=\"w\">        </span><span class=\"nv\">list</span>\n<span class=\"w\">    </span><span class=\"kr\">else</span>\n<span class=\"w\">        </span><span class=\"nv\">midpoint</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"nv\">list</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nf\">//</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">        </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nv\">before</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">others</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">split</span><span class=\"w\"> </span><span class=\"nv\">list</span><span class=\"w\"> </span><span class=\"nv\">midpoint</span>\n<span class=\"w\">        </span><span class=\"nv\">merge</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">mergesort</span><span class=\"w\"> </span><span class=\"nv\">before</span><span class=\"w\"> </span><span class=\"nv\">compare</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">mergesort</span><span class=\"w\"> </span><span class=\"nv\">others</span><span class=\"w\"> </span><span class=\"nv\">compare</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">compare</span>\n\n<span class=\"nv\">merge</span><span class=\"w\"> </span><span class=\"nf\">:</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"nv\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"nv\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">a</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">LT</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">EQ</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">GT</span><span class=\"p\">])</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"nv\">a</span>\n<span class=\"nv\">merge</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"nv\">left</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">right</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">compare</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"nv\">when</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">left</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">right</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">is</span>\n<span class=\"w\">        </span><span class=\"p\">([],</span><span class=\"w\"> </span><span class=\"nv\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nv\">right</span>\n<span class=\"w\">        </span><span class=\"p\">(</span><span class=\"nv\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[])</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nv\">left</span>\n<span class=\"w\">        </span><span class=\"p\">([</span><span class=\"nv\">l</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nf\">..</span><span class=\"w\"> </span><span class=\"kr\">as</span><span class=\"w\"> </span><span class=\"nv\">ls</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nv\">r</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nf\">..</span><span class=\"w\"> </span><span class=\"kr\">as</span><span class=\"w\"> </span><span class=\"nv\">rs</span><span class=\"p\">])</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">            </span><span class=\"nv\">when</span><span class=\"w\"> </span><span class=\"nv\">compare</span><span class=\"w\"> </span><span class=\"nv\">l</span><span class=\"w\"> </span><span class=\"nv\">r</span><span class=\"w\"> </span><span class=\"nv\">is</span>\n<span class=\"w\">                </span><span class=\"kt\">GT</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">prepend</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">merge</span><span class=\"w\"> </span><span class=\"nv\">left</span><span class=\"w\"> </span><span class=\"nv\">rs</span><span class=\"w\"> </span><span class=\"nv\">compare</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">r</span>\n<span class=\"w\">                </span><span class=\"nv\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">prepend</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">merge</span><span class=\"w\"> </span><span class=\"nv\">ls</span><span class=\"w\"> </span><span class=\"nv\">right</span><span class=\"w\"> </span><span class=\"nv\">compare</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">l</span>\n<span class=\"w\">        </span><span class=\"p\">(</span><span class=\"nv\">_</span><span class=\"p\">,</span><span class=\"nv\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">            </span><span class=\"nv\">crash</span><span class=\"w\"> </span><span class=\"s\">\"merge: The previous cases should be exhaustive.\"</span>\n</code></pre></div>",
        "id": 445149324,
        "sender_full_name": "Ian McLerran",
        "timestamp": 1718635188
    },
    {
        "content": "<ol>\n<li><code>prepend</code> is a bad idea. You would be better appending and then reversing at the last moment. Every <code>prepend</code> will copy the entire list</li>\n</ol>",
        "id": 445156271,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1718636984
    },
    {
        "content": "<ol start=\"2\">\n<li>you really should preallocate the output lists. So some sort of structure where you start with <code>List.withCapacity</code>. That way <code>List.prepend</code>/<code>List.append</code> won't be allocating a bunch.</li>\n</ol>",
        "id": 445156931,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1718637127
    },
    {
        "content": "<ol start=\"3\">\n<li>If you actually want merge sort to be as fast as possible, you probably need to do it in place with indices.</li>\n</ol>",
        "id": 445157081,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1718637172
    },
    {
        "content": "<p>As an extra note, <code>List.sortWith</code> is actually really slow compared to how fast it could be. <a class=\"stream-topic\" data-stream-id=\"395097\" href=\"/#narrow/stream/395097-compiler-development/topic/slow.20sorting\">#compiler development &gt; slow sorting</a>.</p>",
        "id": 445158021,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1718637376
    },
    {
        "content": "<p>Oh also, the stack limit issue is probably due to <a href=\"https://github.com/roc-lang/roc/issues/6434\">#6434</a>.</p>",
        "id": 445158326,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1718637458
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/445157081\">said</a>:</p>\n<blockquote>\n<ol start=\"3\">\n<li>If you actually want merge sort to be as fast as possible, you probably need to do it in place with indices</li>\n</ol>\n</blockquote>\n<p>Except that until in-place <code>List</code> mutations get more efficient as per our \"bit-twiddling prime sieving\" discussion, it is still going to be about 20 times slower than it should be...</p>\n<p>Just for a point of reference, sorting a million random integers takes only a 100 or two milliseconds using arrays in languages that support direct array access, with \"boxed\" values as what Python is handling a bit slower in in something in the range of a half a second.  Roc doesn't really have the tools to be able to do this \"in native\" nor can it be properly tested without bringing in random data from outside Roc as has been mentioned.  An immutable Linked List implementation in Roc for the \"bottom-up\" merge sort is as follows:</p>\n<div class=\"codehilite\" data-code-language=\"roc\"><pre><span></span><code>app [main] { pf: platform \"https://github.com/roc-lang/basic-cli/releases/download/0.10.0/vNe6s9hWzoTZtFmNkvEICPErI9ptji_ySjicO6CkucY.tar.br\" }\n\nimport pf.Stdout\nimport pf.Task\n\ncSIZE : I32\ncSIZE = 1000000\n\nLinkedList a : [Empty, Cons a (LinkedList a)]\n\nshowLL : LinkedList a -&gt; Str where a implements Inspect\nshowLL = \\ lst -&gt;\n  shw = \\ ill, oslst -&gt;\n    when ill is\n      Empty -&gt; Str.joinWith oslst \", \"\n      Cons v nxtll -&gt; shw nxtll (List.append oslst (Inspect.toStr v))\n  shw lst []\n\nreverseLL : LinkedList a -&gt; LinkedList a\nreverseLL = \\ lst -&gt;\n  rvs = \\ ilst, olst -&gt;\n    when ilst is\n      Empty -&gt; olst\n      Cons v nxtll -&gt; rvs nxtll (Cons v olst)\n  rvs lst Empty\n\n# generates a LinkedList of I32' in reverse order to zero...\nbuildList : I32 -&gt; LinkedList I32\nbuildList = \\ size -&gt;\n  bld = \\ n, lst -&gt;\n    if n &lt; 0 then lst\n    else bld (n - 1) (Cons n lst)\n  bld (size - 1) Empty\n\nmakelsts : LinkedList I32, LinkedList (LinkedList I32)\n             -&gt; LinkedList (LinkedList I32)\nmakelsts = \\ lst, rlstlst -&gt;\n  when lst is\n    Empty -&gt; rlstlst\n    Cons f ftl -&gt;\n      when ftl is\n        Empty -&gt; Cons (Cons f Empty) rlstlst\n        Cons s stl -&gt;\n          if f &lt;= s then makelsts stl (Cons (Cons f (Cons s Empty)) rlstlst)\n          else makelsts stl (Cons (Cons s (Cons f Empty)) rlstlst)\n\nappend : LinkedList a, LinkedList a -&gt; LinkedList a\nappend = \\ llst, rlst -&gt;\n  when llst is\n    Empty -&gt; reverseLL rlst\n    Cons v vtl -&gt; append vtl (Cons v rlst)\n\nmerge : LinkedList I32, LinkedList I32, LinkedList I32 -&gt; LinkedList I32\nmerge = \\ lstx, lsty, rlst -&gt;\n  when lstx is\n    Empty -&gt; append lsty rlst\n    Cons x xtl -&gt;\n      when lsty is\n        Empty -&gt; append lstx rlst\n        Cons y ytl -&gt;\n          if x &lt;= y then merge xtl lsty (Cons x rlst)\n          else merge lstx ytl (Cons y rlst)\n\npairs : LinkedList (LinkedList I32), LinkedList (LinkedList I32)\n          -&gt; LinkedList (LinkedList I32)\npairs = \\ lstlst, rlstlst -&gt;\n  when lstlst is\n    Empty -&gt; reverseLL rlstlst\n    Cons xs xstl -&gt;\n      when xstl is\n        Empty -&gt; reverseLL (Cons xs rlstlst)\n        Cons ys ystl -&gt; pairs ystl (Cons (merge xs ys Empty) rlstlst)\n\nloop : LinkedList (LinkedList I32) -&gt; LinkedList I32\nloop = \\ lstlst -&gt;\n  when lstlst is\n    Empty -&gt; Empty\n    Cons lst lsttl -&gt;\n      when lsttl is\n        Empty -&gt; lst\n        _ -&gt; loop (pairs lstlst Empty)\n\n# can't be generallized b because no Sort ability...\nmergeSort : LinkedList I32 -&gt; LinkedList I32\nmergeSort = \\ lst -&gt;\n  loop (makelsts lst Empty)\n\ntestSort : LinkedList I32 -&gt; Str\ntestSort = \\ list -&gt;\n  tst  = \\ lst, last -&gt;\n    when lst is\n      Empty -&gt; \"Linked List is sorted!\"\n      Cons v vtl -&gt;\n        if v &gt;= last then tst vtl v\n        else \"Failed to sort Linked List!!!!!\"\n  when list is\n    Empty -&gt; \"Empty Linked Lists are considered sorted.\"\n    Cons f ftl -&gt; tst ftl f\n\nmain =\n  Stdout.line! \"Merge Sorting \\(Inspect.toStr cSIZE) 32-bit integers...\"\n  Stdout.line! (buildList 100 |&gt; mergeSort |&gt; showLL)\n  Stdout.line! (buildList cSIZE |&gt; mergeSort |&gt; testSort)\n</code></pre></div>\n<p>The above sorts a million values in about a quarter of a second, but that isn't really worst case as they are already mostly sorted meaning that there won't be many missed branch predictions or cache misses with list nodes scattered all over heap memory; I would expect it to get three times or more slower if we could provide random data...</p>",
        "id": 445287206,
        "sender_full_name": "GordonBGood",
        "timestamp": 1718695009
    },
    {
        "content": "<p>Why are you showing a linked list?</p>",
        "id": 445379484,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1718722312
    },
    {
        "content": "<p>That will just make performance even worse due to pointer chasing.</p>",
        "id": 445379594,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1718722331
    },
    {
        "content": "<p>If you want a simple but kinda effecient mergesort, I would do this:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>alg</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Elm\"><pre><span></span><code><span class=\"nv\">mergeSort</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"nv\">list</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">  </span><span class=\"nv\">when</span><span class=\"w\"> </span><span class=\"nv\">list</span><span class=\"w\"> </span><span class=\"nv\">is</span>\n<span class=\"w\">    </span><span class=\"p\">[]</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">      </span><span class=\"p\">[]</span>\n<span class=\"w\">    </span><span class=\"p\">[</span><span class=\"nv\">_</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">      </span><span class=\"nv\">list</span>\n<span class=\"w\">    </span><span class=\"p\">[</span><span class=\"nv\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">b</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">      </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"nv\">a</span><span class=\"w\"> </span><span class=\"nf\">&lt;=</span><span class=\"w\"> </span><span class=\"nv\">b</span><span class=\"w\"> </span><span class=\"kr\">then</span>\n<span class=\"w\">        </span><span class=\"nv\">list</span>\n<span class=\"w\">      </span><span class=\"kr\">else</span>\n<span class=\"w\">        </span><span class=\"p\">[</span><span class=\"nv\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">a</span><span class=\"p\">]</span>\n<span class=\"w\">    </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">      </span><span class=\"nv\">l</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"nv\">x</span>\n<span class=\"w\">      </span><span class=\"nv\">m</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nv\">l</span><span class=\"w\"> </span><span class=\"nf\">//</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">      </span><span class=\"nv\">left</span><span class=\"w\"> </span><span class=\"nf\">=</span>\n<span class=\"w\">        </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">takeFirst</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">m</span>\n<span class=\"w\">        </span><span class=\"nf\">|&gt;</span><span class=\"w\"> </span><span class=\"nv\">mergeSort</span>\n<span class=\"w\">      </span><span class=\"nv\">right</span><span class=\"w\"> </span><span class=\"nf\">=</span>\n<span class=\"w\">        </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">dropFirst</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nv\">m</span>\n<span class=\"w\">        </span><span class=\"nf\">|&gt;</span><span class=\"w\"> </span><span class=\"nv\">mergeSort</span>\n<span class=\"w\">      </span><span class=\"nv\">merge</span><span class=\"w\"> </span><span class=\"nv\">left</span><span class=\"w\"> </span><span class=\"nv\">right</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">withCapacity</span><span class=\"w\"> </span><span class=\"nv\">l</span><span class=\"p\">)</span>\n\n<span class=\"nv\">merge</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"nv\">left</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">right</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">out</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">  </span><span class=\"nv\">when</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">left</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">right</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">is</span>\n<span class=\"w\">    </span><span class=\"p\">([</span><span class=\"nv\">l</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nf\">..</span><span class=\"w\"> </span><span class=\"kr\">as</span><span class=\"w\"> </span><span class=\"nv\">ls</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nv\">r</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nf\">..</span><span class=\"w\"> </span><span class=\"kr\">as</span><span class=\"w\"> </span><span class=\"nv\">rs</span><span class=\"p\">])</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">      </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"nv\">l</span><span class=\"w\"> </span><span class=\"nf\">&lt;=</span><span class=\"w\"> </span><span class=\"nv\">r</span><span class=\"w\"> </span><span class=\"kr\">then</span>\n<span class=\"w\">        </span><span class=\"nv\">merge</span><span class=\"w\"> </span><span class=\"nv\">ls</span><span class=\"w\"> </span><span class=\"nv\">right</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">append</span><span class=\"w\"> </span><span class=\"nv\">out</span><span class=\"w\"> </span><span class=\"nv\">l</span><span class=\"p\">)</span>\n<span class=\"w\">      </span><span class=\"kr\">else</span>\n<span class=\"w\">        </span><span class=\"nv\">merge</span><span class=\"w\"> </span><span class=\"nv\">left</span><span class=\"w\"> </span><span class=\"nv\">rs</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">append</span><span class=\"w\"> </span><span class=\"nv\">out</span><span class=\"w\"> </span><span class=\"nv\">r</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"nv\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[])</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">      </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">concat</span><span class=\"w\"> </span><span class=\"nv\">out</span><span class=\"w\"> </span><span class=\"nv\">left</span>\n<span class=\"w\">    </span><span class=\"p\">([],</span><span class=\"w\"> </span><span class=\"nv\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">      </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">concat</span><span class=\"w\"> </span><span class=\"nv\">out</span><span class=\"w\"> </span><span class=\"nv\">right</span>\n</code></pre></div>\n</div></div>",
        "id": 445468370,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1718747721
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/445379484\">said</a>:</p>\n<blockquote>\n<p>Why are you showing a linked list?<br>\nThat will just make performance even worse due to pointer chasing.</p>\n</blockquote>\n<p>That's my point:  This linked list implementation is actually showing better performance than the current built-in \"native\" implementation of <code>List.sortWith</code>(althouugh that is using quickSort under the covers) and ais currently much faster than using a custom merge sort using the current state of List indexing due to the non-optimized in-place mutation...</p>\n<p>In Elm, Linked List's are all we have that are suitable for writing alternate sorting algorithms, and code such as this sorting a million random Int's runs a sort in a little over a second and is comparable in speed to Haskell's built-in (lazy) List sort doing the same, although a little over twice as slow as Elm's built-in sort calling the JavaScript engine's implementation of an array sort usually implemented as an array Timsort written in C/C++ (converting the links list to a JavaScript array at the beginning and back at the end) although slower in having to deal with JavaScript's boxed objects...</p>\n<p>So the following is an implementation of merge sort using List indexing:</p>\n<div class=\"codehilite\" data-code-language=\"Elm\"><pre><span></span><code><span class=\"nv\">buildList</span><span class=\"w\"> </span><span class=\"nf\">:</span><span class=\"w\"> </span><span class=\"kt\">U64</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"kt\">I32</span>\n<span class=\"nv\">buildList</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"w\"> </span><span class=\"nv\">size</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">  </span><span class=\"nv\">loopi</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"w\"> </span><span class=\"nv\">lst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nf\">&gt;=</span><span class=\"w\"> </span><span class=\"nv\">size</span><span class=\"w\"> </span><span class=\"kr\">then</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">reverse</span><span class=\"w\"> </span><span class=\"nv\">lst</span>\n<span class=\"w\">    </span><span class=\"kr\">else</span><span class=\"w\"> </span><span class=\"nv\">loopi</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">set</span><span class=\"w\"> </span><span class=\"nv\">lst</span><span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Num</span><span class=\"nf\">.</span><span class=\"nv\">intCast</span><span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nf\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">repeat</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"nv\">size</span><span class=\"w\"> </span><span class=\"nf\">|&gt;</span><span class=\"w\"> </span><span class=\"nv\">loopi</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"nv\">sortByTwos</span><span class=\"w\"> </span><span class=\"nf\">:</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"kt\">I32</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"kt\">I32</span>\n<span class=\"nv\">sortByTwos</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"w\"> </span><span class=\"nv\">list</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">  </span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"nv\">list</span>\n<span class=\"w\">  </span><span class=\"nv\">loopi</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"w\"> </span><span class=\"nv\">lst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nf\">&gt;=</span><span class=\"w\"> </span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"kr\">then</span><span class=\"w\"> </span><span class=\"nv\">lst</span><span class=\"w\"> </span><span class=\"kr\">else</span>\n<span class=\"w\">    </span><span class=\"nv\">lft</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">get</span><span class=\"w\"> </span><span class=\"nv\">lst</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nf\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"nf\">|&gt;</span><span class=\"w\"> </span><span class=\"kt\">Result</span><span class=\"nf\">.</span><span class=\"nv\">withDefault</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"nv\">rgt</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">get</span><span class=\"w\"> </span><span class=\"nv\">lst</span><span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nf\">|&gt;</span><span class=\"w\"> </span><span class=\"kt\">Result</span><span class=\"nf\">.</span><span class=\"nv\">withDefault</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"nv\">lft</span><span class=\"w\"> </span><span class=\"nf\">&gt;</span><span class=\"w\"> </span><span class=\"nv\">rgt</span><span class=\"w\"> </span><span class=\"kr\">then</span>\n<span class=\"w\">      </span><span class=\"nv\">loopi</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">swap</span><span class=\"w\"> </span><span class=\"nv\">lst</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nf\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nf\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"kr\">else</span><span class=\"w\"> </span><span class=\"nv\">loopi</span><span class=\"w\"> </span><span class=\"nv\">lst</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nf\">+</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"nv\">loopi</span><span class=\"w\"> </span><span class=\"nv\">list</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n\n<span class=\"nv\">copylst</span><span class=\"w\"> </span><span class=\"nf\">:</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"kt\">I32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">U64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"kt\">I32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">U64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">U64</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"kt\">I32</span>\n<span class=\"nv\">copylst</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"w\"> </span><span class=\"nv\">srclst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">si</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">dstlst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">di</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">num</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">  </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"nv\">num</span><span class=\"w\"> </span><span class=\"nf\">&lt;=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"kr\">then</span><span class=\"w\"> </span><span class=\"nv\">dstlst</span><span class=\"w\"> </span><span class=\"kr\">else</span>\n<span class=\"w\">  </span><span class=\"nv\">sv</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">get</span><span class=\"w\"> </span><span class=\"nv\">srclst</span><span class=\"w\"> </span><span class=\"nv\">si</span><span class=\"w\"> </span><span class=\"nf\">|&gt;</span><span class=\"w\"> </span><span class=\"kt\">Result</span><span class=\"nf\">.</span><span class=\"nv\">withDefault</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">  </span><span class=\"nv\">copylst</span><span class=\"w\"> </span><span class=\"nv\">srclst</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">si</span><span class=\"w\"> </span><span class=\"nf\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"w\">          </span><span class=\"p\">(</span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">set</span><span class=\"w\"> </span><span class=\"nv\">dstlst</span><span class=\"w\"> </span><span class=\"nv\">di</span><span class=\"w\"> </span><span class=\"nv\">sv</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">di</span><span class=\"w\"> </span><span class=\"nf\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"w\">          </span><span class=\"p\">(</span><span class=\"nv\">num</span><span class=\"w\"> </span><span class=\"nf\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"nv\">merge</span><span class=\"w\"> </span><span class=\"nf\">:</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"kt\">I32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">U64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">U64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">U64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">U64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"kt\">I32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">U64</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"kt\">I32</span>\n<span class=\"nv\">merge</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"w\"> </span><span class=\"nv\">ilst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">xi</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">xlmt</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">yi</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">ylmt</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">olst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">oi</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">  </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"nv\">xi</span><span class=\"w\"> </span><span class=\"nf\">&gt;=</span><span class=\"w\"> </span><span class=\"nv\">xlmt</span><span class=\"w\"> </span><span class=\"kr\">then</span><span class=\"w\"> </span><span class=\"nv\">copylst</span><span class=\"w\"> </span><span class=\"nv\">ilst</span><span class=\"w\"> </span><span class=\"nv\">yi</span><span class=\"w\"> </span><span class=\"nv\">olst</span><span class=\"w\"> </span><span class=\"nv\">oi</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">ylmt</span><span class=\"w\"> </span><span class=\"nf\">-</span><span class=\"w\"> </span><span class=\"nv\">yi</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"kr\">else</span><span class=\"w\"> </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"nv\">yi</span><span class=\"w\"> </span><span class=\"nf\">&gt;=</span><span class=\"w\"> </span><span class=\"nv\">ylmt</span><span class=\"w\"> </span><span class=\"kr\">then</span><span class=\"w\"> </span><span class=\"nv\">copylst</span><span class=\"w\"> </span><span class=\"nv\">ilst</span><span class=\"w\"> </span><span class=\"nv\">xi</span><span class=\"w\"> </span><span class=\"nv\">olst</span><span class=\"w\"> </span><span class=\"nv\">oi</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">xlmt</span><span class=\"w\"> </span><span class=\"nf\">-</span><span class=\"w\"> </span><span class=\"nv\">xi</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"kr\">else</span>\n<span class=\"w\">    </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">get</span><span class=\"w\"> </span><span class=\"nv\">ilst</span><span class=\"w\"> </span><span class=\"nv\">xi</span><span class=\"w\"> </span><span class=\"nf\">|&gt;</span><span class=\"w\"> </span><span class=\"kt\">Result</span><span class=\"nf\">.</span><span class=\"nv\">withDefault</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"nv\">y</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">get</span><span class=\"w\"> </span><span class=\"nv\">ilst</span><span class=\"w\"> </span><span class=\"nv\">yi</span><span class=\"w\"> </span><span class=\"nf\">|&gt;</span><span class=\"w\"> </span><span class=\"kt\">Result</span><span class=\"nf\">.</span><span class=\"nv\">withDefault</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"w\"> </span><span class=\"nf\">&lt;=</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"w\"> </span><span class=\"kr\">then</span><span class=\"w\"> </span><span class=\"nv\">merge</span><span class=\"w\"> </span><span class=\"nv\">ilst</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">xi</span><span class=\"w\"> </span><span class=\"nf\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">xlmt</span><span class=\"w\"> </span><span class=\"nv\">yi</span><span class=\"w\"> </span><span class=\"nv\">ylmt</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">set</span><span class=\"w\"> </span><span class=\"nv\">olst</span><span class=\"w\"> </span><span class=\"nv\">oi</span><span class=\"w\"> </span><span class=\"nv\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">oi</span><span class=\"w\"> </span><span class=\"nf\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"kr\">else</span><span class=\"w\"> </span><span class=\"nv\">merge</span><span class=\"w\"> </span><span class=\"nv\">ilst</span><span class=\"w\"> </span><span class=\"nv\">xi</span><span class=\"w\"> </span><span class=\"nv\">xlmt</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">yi</span><span class=\"w\"> </span><span class=\"nf\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">ylmt</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">set</span><span class=\"w\"> </span><span class=\"nv\">olst</span><span class=\"w\"> </span><span class=\"nv\">oi</span><span class=\"w\"> </span><span class=\"nv\">y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">oi</span><span class=\"w\"> </span><span class=\"nf\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"nv\">pairs</span><span class=\"w\"> </span><span class=\"nf\">:</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"kt\">I32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"kt\">I32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">U64</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"kt\">I32</span>\n<span class=\"nv\">pairs</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"w\"> </span><span class=\"nv\">srclst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">dstlst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">mrgsz</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">  </span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"nv\">srclst</span>\n<span class=\"w\">  </span><span class=\"nv\">loopi</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"w\"> </span><span class=\"nv\">dlst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nf\">&gt;=</span><span class=\"w\"> </span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"kr\">then</span><span class=\"w\"> </span><span class=\"nv\">dlst</span><span class=\"w\"> </span><span class=\"kr\">else</span>\n<span class=\"w\">    </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nf\">+</span><span class=\"w\"> </span><span class=\"nv\">mrgsz</span><span class=\"w\"> </span><span class=\"nf\">&gt;=</span><span class=\"w\"> </span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"kr\">then</span><span class=\"w\"> </span><span class=\"nv\">copylst</span><span class=\"w\"> </span><span class=\"nv\">srclst</span><span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nv\">dlst</span><span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"nf\">-</span><span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kr\">else</span>\n<span class=\"w\">    </span><span class=\"nv\">xlmt</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nf\">+</span><span class=\"w\"> </span><span class=\"nv\">mrgsz</span>\n<span class=\"w\">    </span><span class=\"nv\">ylmt</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"kt\">Num</span><span class=\"nf\">.</span><span class=\"nv\">min</span><span class=\"w\"> </span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">xlmt</span><span class=\"w\"> </span><span class=\"nf\">+</span><span class=\"w\"> </span><span class=\"nv\">mrgsz</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"nv\">loopi</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">merge</span><span class=\"w\"> </span><span class=\"nv\">srclst</span><span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nv\">xlmt</span><span class=\"w\"> </span><span class=\"nv\">xlmt</span><span class=\"w\"> </span><span class=\"nv\">ylmt</span><span class=\"w\"> </span><span class=\"nv\">dlst</span><span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">ylmt</span>\n<span class=\"w\">  </span><span class=\"nv\">loopi</span><span class=\"w\"> </span><span class=\"nv\">dstlst</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n\n<span class=\"nv\">loop</span><span class=\"w\"> </span><span class=\"nf\">:</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"kt\">I32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"kt\">I32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">U64</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"kt\">I32</span>\n<span class=\"nv\">loop</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"w\"> </span><span class=\"nv\">srclst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">dstlst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">lstsz</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">  </span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"nv\">srclst</span>\n<span class=\"w\">  </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"nv\">lstsz</span><span class=\"w\"> </span><span class=\"nf\">&gt;=</span><span class=\"w\"> </span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"kr\">then</span><span class=\"w\"> </span><span class=\"nv\">srclst</span>\n<span class=\"w\">  </span><span class=\"kr\">else</span><span class=\"w\"> </span><span class=\"nv\">loop</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">pairs</span><span class=\"w\"> </span><span class=\"nv\">srclst</span><span class=\"w\"> </span><span class=\"nv\">dstlst</span><span class=\"w\"> </span><span class=\"nv\">lstsz</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">srclst</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">lstsz</span><span class=\"w\"> </span><span class=\"nf\">*</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">)</span>\n\n<span class=\"nv\">mergeSort</span><span class=\"w\"> </span><span class=\"nf\">:</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"kt\">I32</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"kt\">I32</span>\n<span class=\"nv\">mergeSort</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"w\"> </span><span class=\"nv\">lst</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">  </span><span class=\"nv\">altlst</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">repeat</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"nv\">lst</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"nv\">lst</span><span class=\"w\"> </span><span class=\"nf\">|&gt;</span><span class=\"w\"> </span><span class=\"nv\">sortByTwos</span><span class=\"w\"> </span><span class=\"nf\">|&gt;</span><span class=\"w\"> </span><span class=\"nv\">loop</span><span class=\"w\"> </span><span class=\"nv\">altlst</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n\n<span class=\"nv\">testSort</span><span class=\"w\"> </span><span class=\"nf\">:</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"w\"> </span><span class=\"kt\">I32</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">Str</span>\n<span class=\"nv\">testSort</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"w\"> </span><span class=\"nv\">lst</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">  </span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"nv\">lst</span>\n<span class=\"w\">  </span><span class=\"nv\">loopi</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nf\">&gt;=</span><span class=\"w\"> </span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"kr\">then</span><span class=\"w\"> </span><span class=\"s\">\"List sorted correctly!\"</span><span class=\"w\"> </span><span class=\"kr\">else</span>\n<span class=\"w\">    </span><span class=\"nv\">f</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">get</span><span class=\"w\"> </span><span class=\"nv\">lst</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nf\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nf\">|&gt;</span><span class=\"w\"> </span><span class=\"kt\">Result</span><span class=\"nf\">.</span><span class=\"nv\">withDefault</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"nv\">s</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">get</span><span class=\"w\"> </span><span class=\"nv\">lst</span><span class=\"w\"> </span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nf\">|&gt;</span><span class=\"w\"> </span><span class=\"kt\">Result</span><span class=\"nf\">.</span><span class=\"nv\">withDefault</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">    </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"nv\">s</span><span class=\"w\"> </span><span class=\"nf\">&lt;</span><span class=\"w\"> </span><span class=\"nv\">f</span><span class=\"w\"> </span><span class=\"kr\">then</span><span class=\"w\"> </span><span class=\"s\">\"Error in List sorting!!!!!\"</span>\n<span class=\"w\">    </span><span class=\"kr\">else</span><span class=\"w\"> </span><span class=\"nv\">loopi</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">i</span><span class=\"w\"> </span><span class=\"nf\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"nv\">loopi</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>This segfaults for some reason for a million entries but can sort a list of half a million integers in about 0.6 seconds meaning that a million entries would take something like 1.3 seconds (O(n log n)) and this is quite a bit slower than the Linked List merge sort above, which also doesn't segfault.  If the optimization for in-place mutation of List's (and what causes the segfault) were fixed, of course an indexed List sort would be faster...</p>\n<p>It is also quite trivial to add recognition of pre-existing runs to the initialization for a Linked List based merge sort, unlike for indexed List sorts.</p>\n<p>I don't say that Roc should use Linked List sorts, just that the current state of Roc doesn't really support anything better...</p>",
        "id": 445477674,
        "sender_full_name": "GordonBGood",
        "timestamp": 1718752642
    },
    {
        "content": "<p>In my testing (might be an m1 mac memory thing), the merge sort I wrote above is approximately the same speed as your linked list merge sort (which is pretty sad cause it should be faster, though this merge sort version does allocate for all intermediate lists). Naive merge sort is actually a pretty bad algorithm for sorting contiguous arrays, even the inplace version.</p>\n<p>That said, I would still recommend it over using a linked list sort. Cause the linked list will hurt with everything else you do even if it does sort faster.</p>\n<p>We probably should pull our sorting algorithm out of zig for now in order to get reasonable performance. That or if someone has time and is willing to contribute, we need to generate element swapping functions and pass them into zig. That hopefully would inline and optimize happily. It would at a minimum be much better than memcpy for swapping elements.</p>",
        "id": 445485818,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1718758190
    },
    {
        "content": "<p>But yeah, overall, the horrible performance here is definitely a major roc bug.</p>",
        "id": 445486046,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1718758342
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/445486046\">said</a>:</p>\n<blockquote>\n<p>the horrible performance here is definitely a major roc bug.</p>\n</blockquote>\n<p>That's exactly the point I was trying to make; but also that the current implementation of sorting in Zig isn't very good either as you say...</p>\n<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/445486046\">said</a>:</p>\n<blockquote>\n<p>Naive merge sort is actually a pretty bad algorithm for sorting contiguous arrays, even the in-place version.</p>\n</blockquote>\n<p><strong>Ah, I think that by \"naive\", you mean top-down and intermediate allocating as per your implemented - yes, that kind of \"naive\" is pretty bad although simpler; you notice that I prefer bottom-up for partly in-place sorting for my implementation although it does still need to alternate between two arrays with the final destination the resulting one.  I think your poorer results for the Linked List version are indeed due to slower memory allocation on macOS where I was running on Linux, as I often see this difference</strong></p>\n<p>It's funny you should say that considering that most common sorting implementations in most languages are just variations of array merge sorting, which includes Timsort, the new Powersort that Python currently uses, etc.; if one wants a reasonable performance general-purpose stable sort with good general performance where worst case is about the same as average performance for random data, these seem to be state-of-the-art; if one is willing to give up stable sorting or having extreme worst case performance, there are some exotic sorting algorithms that can deliver for some special cases...</p>",
        "id": 445492381,
        "sender_full_name": "GordonBGood",
        "timestamp": 1718762007
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"686843\">GordonBGood</span> <a href=\"#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/445492381\">said</a>:</p>\n<blockquote>\n<p><strong>you notice that I prefer bottom-up for partly in-place sorting for my implementation although it does still need to alternate between two arrays with the final destination the resulting one</strong></p>\n</blockquote>\n<p>Just to finish this up, now that there is a <strong>TESTING</strong> branch of nightlies that has fixed the in-place mutation so it is now very fast, indexed List/array merge sorting works about as fast as in any of the fastest languages, as per the following code, which does a bottom-up merge sort:</p>\n<div class=\"codehilite\" data-code-language=\"roc\"><pre><span></span><code>app [main] { pf: platform \"https://github.com/roc-lang/basic-cli/releases/download/0.10.0/vNe6s9hWzoTZtFmNkvEICPErI9ptji_ySjicO6CkucY.tar.br\" }\n\nimport pf.Stdout\nimport pf.Task\nimport pf.Utc exposing [ now, deltaAsMillis ]\n\ncLIMIT : U64\ncLIMIT = 1_000_000\n\nRandSeed : (U64, U64)\n\ninitRandSeed : RandSeed\ninitRandSeed = (0x69B4C98CB8530805u64, 0xFED1DD3004688D68u64)\n\nnextRandI64 : RandSeed -&gt; (RandSeed, I64)\nnextRandI64 = \\ r -&gt;\n  s0 = r.0\n  s1 = r.1\n  ns1 = Num.bitwiseXor s0 s1\n  nr0 = Num.shiftLeftBy s0 55 |&gt; Num.bitwiseOr (Num.shiftRightZfBy s0 9)\n          |&gt; Num.bitwiseXor ns1 |&gt; Num.bitwiseXor (Num.shiftLeftBy ns1 14) # a, b\n  nr1 = Num.shiftLeftBy ns1 36 |&gt; Num.bitwiseOr (Num.shiftRightZfBy ns1 28) # c\n  ((nr0, nr1), Num.intCast (Num.addWrap s0 s1))\n\nbuildList : U64 -&gt; List I64\nbuildList = \\ size -&gt;\n  loopi = \\ lst, r, i -&gt;\n    if i &gt;= size then lst else\n    (nr, rv) = nextRandI64 r\n    loopi (List.set lst i rv) nr (i + 1)\n  List.repeat 0 size |&gt; loopi initRandSeed 0\n\nmergeSort : List I64 -&gt; List I64\nmergeSort = \\ ilist -&gt;\n  sortByTwos = \\ list -&gt;\n    len = List.len list\n    loopi = \\ lst, i -&gt;\n      if i &gt;= len then lst else\n      lft = List.get lst (i - 1)|&gt; Result.withDefault 0\n      rgt = List.get lst i |&gt; Result.withDefault 0\n      if lft &gt; rgt then loopi (List.swap lst (i - 1) i) (i + 2)\n      else loopi lst (i + 2)\n    loopi list 1\n  copylst = \\ srclst, si, dstlst, di, num -&gt;\n    if num &lt;= 0 then dstlst else\n    sv = List.get srclst si |&gt; Result.withDefault 0\n    copylst srclst (si + 1)\n            (List.set dstlst di sv) (di + 1)\n            (num - 1)\n  merge = \\ ilst, xi, xlmt, yi, ylmt, olst, oi -&gt;\n    if xi &gt;= xlmt then copylst ilst yi olst oi (ylmt - yi)\n    else if yi &gt;= ylmt then copylst ilst xi olst oi (xlmt - xi)\n    else\n      x = List.get ilst xi |&gt; Result.withDefault 0\n      y = List.get ilst yi |&gt; Result.withDefault 0\n      if x &lt;= y then merge ilst (xi + 1) xlmt yi ylmt (List.set olst oi x) (oi + 1)\n      else merge ilst xi xlmt (yi + 1) ylmt (List.set olst oi y) (oi + 1)\n  pairs = \\ srclst, dstlst, mrgsz -&gt;\n    len = List.len srclst\n    loopi = \\ dlst, i -&gt;\n      if i &gt;= len then dlst else\n      if i + mrgsz &gt;= len then copylst srclst i dlst i (len - i) else\n      xlmt = i + mrgsz\n      ylmt = Num.min len (xlmt + mrgsz)\n      loopi (merge srclst i xlmt xlmt ylmt dlst i) ylmt\n    loopi dstlst 0\n  loop = \\ srclst, dstlst, lstsz -&gt;\n    len = List.len srclst\n    if lstsz &gt;= len then srclst\n    else loop (pairs srclst dstlst lstsz) srclst (lstsz * 2)\n  altlst = List.repeat 0 (List.len ilist)\n  ilist |&gt; sortByTwos |&gt; loop altlst 2\n\ntestSort : List I64 -&gt; Bool\ntestSort = \\ lst -&gt;\n  len = List.len lst\n  loopi = \\ i -&gt;\n    if i &gt;= len then Bool.true else\n    f = List.get lst (i - 1) |&gt; Result.withDefault 0\n    s = List.get lst i |&gt; Result.withDefault 0\n    if s &lt; f then Bool.false else loopi (i + 1)\n  loopi 1\n\nmain =\n    tstlst = buildList cLIMIT\n    start = now!\n    answrlst = tstlst |&gt; mergeSort\n    stop = now!\n    elpsdStr = deltaAsMillis start stop |&gt; Num.toStr\n    shwlst = answrlst |&gt; List.takeFirst 100\n    Stdout.line! \"$(Inspect.toStr shwlst)\"\n    Stdout.line! ( if testSort answrlst then \"List sorted correctly!\"\n                   else \"Failure in sorting list!!!\" )\n    Stdout.line! \"Sorted $(cLIMIT |&gt; Num.toStr) integers in $(elpsdStr) milliseconds.\"\n</code></pre></div>\n<p>The above code sorts a million pseudo random 64-bit integers in about 89 milliseconds with my AMD 7840HS CPU running at 5.1 GHz when single-threaded as here, and that is fast!!!  As mentioned in the thread, bottom-up sorting avoids the many allocations for doing partitioning that many top-down versions do and this version just alternates sorting between the original and the alternate allocated array and just returns the last destination one.</p>\n<p>Most languages standard library sorting functions prefer a merge sort because it is a stable sort where equal values maintain their order in the List, and because worst case sorting time is still O(n log n) unlike quicksort which is not a stable sort and can be very slow when given a pre-sorted or partially sorted List and the \"pivot\" point(s) chosen incorrectly.  For production, one would probably translate Python's new \"power sort\" which accounts for pre-sorted runs in the List/array although it does an increase in memory from a factor of twice the size of the List/array as here to up to half again as much for a \"stack\" of the lengths of the found runs...</p>",
        "id": 453253056,
        "sender_full_name": "GordonBGood",
        "timestamp": 1721674295
    },
    {
        "content": "<p>Awesome to see this panning out in practice as real perf gains!</p>\n<hr>\n<p>I need to look into power sort more. To my understanding glidesort actually uses it as a primitive for example. Cause generally speaking if you are will to allocate a little (sqrt of N) you can sort faster than what you get out of a merge sort.</p>\n<p>But you always need the merge sort as the backup for bad cases where quicksort would recurse too far or require too much memory.</p>",
        "id": 453255128,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721674996
    },
    {
        "content": "<p>looks like power sort also uses extra memory: <code>but they use a linear-size buer for ecient merging.</code></p>",
        "id": 453255802,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721675163
    },
    {
        "content": "<p>very cool!</p>",
        "id": 453256501,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721675383
    },
    {
        "content": "<p>btw I don't think stable sorting matters in our case because Roc as a language never exposes reference equality</p>",
        "id": 453256551,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721675400
    },
    {
        "content": "<p>so I don't think the stability of a sort is observable in Roc code, just in the host</p>",
        "id": 453256680,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721675418
    },
    {
        "content": "<p>It is noticable in roc cause the users can set the compare function.</p>\n<div class=\"codehilite\"><pre><span></span><code>main =\n    x = [2.4, 1.2, 2.3, 2.2, 2.1]\n    List.sortWith x \\a, b -&gt;\n        Num.compare (Num.round a) (Num.round b)\n    |&gt; Inspect.toStr\n    |&gt; Stdout.line!\n</code></pre></div>\n<p><code>[1.2, 2.1, 2.4, 2.3, 2.2]</code></p>\n<p>Our sort is currently unstable. Stable would produce:<br>\n<code>[1.2, 2.4, 2.3, 2.2, 2.1]</code></p>",
        "id": 453257428,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721675654
    },
    {
        "content": "<p>ah fair point <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 453257652,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721675718
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/453255128\">said</a>:</p>\n<blockquote>\n<p>I need to look into power sort more. To my understanding glidesort actually uses it as a primitive for example. Cause generally speaking if you are will to allocate a little (sqrt of N) you can sort faster than what you get out of a merge sort.</p>\n</blockquote>\n<p>All of these \"in-place\" List/array indexing sorts that respect pre-existing \"runs\" of data are going to need to allocate a little extra space to keep track of the length of the \"runs\" yet to be sorted, which is their cost in order to be able to take advantage of those pre-existing runs yet enjoy the advantages of an indexing in-place stable sort; then, managing that extra allocated memory will add to their execution time cost that will detract from the advantage of using the pre-existing \"runs\".</p>\n<p>I think that the choices between powersort, glidesort, and any other variations gets into nit-picky type of territory:  All try to balance out the number of merges so that the sorting algorithm more often is merging runs of about equal length for efficiency (less copy moves on average) even though the pre-existing runs may differ greatly in length.  Some of the more exotic variations try to do intelligent decisions between different sorting methods based on the \"shape\" of the data, but it seems to me there will always be cases where the decisions will fail.  The very competent Python contributor, Tim Peters, went through all the research and comparisons and chose powersort, but says that there may be (obscure - GBG) cases where other algorithms give better performance.  I think its a situation where other slightly different algorithms may give somewhat better performance for certain run combinations but then worse for some situations where power sort is better.</p>\n<p>It seems to me that we could save time by respecting Tim Peter's research and just implementing a Roc version of the C code he uses for the new Python standard library sort...</p>",
        "id": 453315021,
        "sender_full_name": "GordonBGood",
        "timestamp": 1721705055
    },
    {
        "content": "<p>I agree with the general sentiment here, and I think that powersort would be a reasonable algorithm for roc. Like it obviously won't be bad. Clearly will be better than what we currently have by a lot. From real world measurements, it is essentially strictly better than timsort. That said, timsort has had a well known really bad case for a long time where it ends up merging length ~1 arrays with giant arrays.</p>\n<p>That said, I think there is definitely more to consider here:</p>\n<ol>\n<li>python is always dealing with python objects. That significantly changes the sorting tradeoff due to extra pointer indirection and the actually thing being sorted always being relatively small in size.</li>\n<li>Algorithms like glidesort, fluxsort, powersort, quadsort, etc are consistently able to beat timsort (by a large margin). So it isn't a good benchmark.</li>\n<li>Powersort does not require a little bit of extra memory, it requires a lot of extra memory. In the worst case, it requires an element buffer of size <code>n/2</code>. For any given merge of arrays <code>A</code> and <code>B</code> it requires <code>min(len(A), len(B))</code> extra memory.</li>\n<li>Quadsort, which is roughly equivalent to powersort can be significantly slower than fluxsort (a quicksort-like wrapper to quadsort) for certain cases where data is more organized.</li>\n<li>blitsort with sqrt of n memory has approximately equivalent perf to fluxsort.</li>\n</ol>",
        "id": 453319958,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721708151
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/453319958\">said</a>:</p>\n<blockquote>\n<p>That said, timsort has had a well known really bad case for a long time where it ends up merging length ~1 arrays with giant arrays.</p>\n</blockquote>\n<p>Yes, that has been known about timsort for quite some time, which is why most implementations are a modified timsort to avoid the corner case, and probably is part of the drive to change - to powersort, which can be proved to not have that case...</p>\n<blockquote>\n<p>That said, I think there is definitely more to consider here:</p>\n<ol>\n<li>python is always dealing with python objects. That significantly changes the sorting tradeoff due to extra pointer indirection and the actually thing being sorted always being relatively small in size.</li>\n</ol>\n</blockquote>\n<p>True, but that is a trade for any sorting algorithm as to digging down to the actual \"key\" comparison value and the comparisons should still be valid, just that non some cases of unboxed values will be faster and some that don't box such as tuples and records may be slower...</p>\n<blockquote>\n<ol start=\"2\">\n<li>Algorithms like glidesort, fluxsort, powersort, quadsort, etc are consistently able to beat timsort (by a large margin). So it isn't a good benchmark.</li>\n</ol>\n</blockquote>\n<p>Skipping timsort, we are only concerned with comparisons between powersort and the others...</p>\n<blockquote>\n<ol start=\"3\">\n<li>Powersort does not require a little bit of extra memory, it requires a lot of extra memory. In the worst case, it requires an element buffer of size <code>n/2</code>. For any given merge of arrays <code>A</code> and <code>B</code> it requires <code>min(len(A), len(B))</code> extra memory.</li>\n</ol>\n</blockquote>\n<p>Well, efficient in-place mergesort requires as much extra memory as the array to be sorted, so adding an extra half again extra doesn't seem all that bad - if memory use is a problem, one can switch to one of the others that use a little less, but as far as I can see, all of them use some extra if they are to be stable sorts...</p>\n<blockquote>\n<ol start=\"4\">\n<li>Quadsort, which is roughly equivalent to powersort can be significantly slower than fluxsort (a quicksort-like wrapper to quadsort) for certain cases where data is more organized.</li>\n</ol>\n</blockquote>\n<p>There are always cases...</p>\n<blockquote>\n<ol start=\"5\">\n<li>blitsort with sqrt of n memory has approximately equivalent perf to fluxsort.</li>\n</ol>\n</blockquote>\n<p>If low memory use is an essential criteria, then that looks like it might be a good alternative, but what are the other trade offs?</p>",
        "id": 453326163,
        "sender_full_name": "GordonBGood",
        "timestamp": 1721710359
    },
    {
        "content": "<blockquote>\n<p>If low memory use is an essential criteria</p>\n</blockquote>\n<p>This is probably a very good question that we should be asking ourselves. How much memory are we ok with roc's default sort using? <span class=\"user-mention\" data-user-id=\"281383\">@Richard Feldman</span> any thoughts?</p>\n<p>I had always assumed the goal was essentially constant memory, but that was definitely a naive assumption. I guess in essentially all commonly used language sorting algorithms, the answer is roughly <code>n/2</code> to <code>n</code> extra memory. I think the main gain of glidesort and blitsort is that they use essentially constant memory (can be restricted to truly constant, but sqrt of n required for full perf) while being competitive with powersort/quadsort. Also due to taking advantage of a few patterns and a top level quicksort in general have slightly better perf.</p>",
        "id": 453327281,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721710928
    },
    {
        "content": "<blockquote>\n<p>but what are the other trade offs?</p>\n</blockquote>\n<p>Main tradeoff is in very large merges. They will require more cycles of the buffer which is slower than just having a single large buffer. In practice, this is not much of a cost as long as you have the sqrt of n memory.</p>",
        "id": 453327590,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721711127
    },
    {
        "content": "<p>it's a good question; by default I'd say top priority is fastest overall sorting performance, but it's not the only consideration</p>",
        "id": 453332142,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721713302
    },
    {
        "content": "<p>for example, if the absolute fastest thing is 5x the memory usage of the next one but only 1% faster, that doesn't sound worth it to me</p>",
        "id": 453332284,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721713342
    },
    {
        "content": "<p>Yeah, I think the two main choices are <code>n</code> or basically constant.</p>",
        "id": 453332417,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721713381
    },
    {
        "content": "<p>so I'd say constant memory usage is not a requirement, but less memory usage is separately valuable from faster overall perf, although faster overall perf is the most valuable</p>",
        "id": 453332517,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721713416
    },
    {
        "content": "<p>also I think the default sorting algorithm will most often be used to sort things of under a thousand elements</p>",
        "id": 453332756,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721713495
    },
    {
        "content": "<p>Using <code>n</code> is definitely faster. Though most cases will be similar in performance, in the bad cases for using basically constant memory, it can be 25% slower (though this is also 25% slower of significantly faster than timsort which most languages still use).</p>",
        "id": 453332758,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721713496
    },
    {
        "content": "<p>what's the coefficient here? like n times how many bytes?</p>",
        "id": 453332882,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721713546
    },
    {
        "content": "<p>Sorry, <code>n</code> elements. So 2 whole copies of the array.</p>",
        "id": 453332941,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721713566
    },
    {
        "content": "<p>As a note, no matter which algorithm we use (within the bounds of modern fast algorithms), my gut feeling is that the cost of the cmp function, copy function (ie not giving zig element size and alignment at compile time), and and dealing with refcounts will be the biggest slowdowns. Those are all things we may need to specialize over to get perf.</p>",
        "id": 453333058,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721713663
    },
    {
        "content": "<p>when we say the one that doubles the elements is faster, is that in a microbenchmark?</p>",
        "id": 453333208,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721713786
    },
    {
        "content": "<p>or in real programs where the cost of cache misses due to evictions from that much memory usage is factored in</p>",
        "id": 453333313,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721713838
    },
    {
        "content": "<p>I would guess in practice given most languages use sorting algorithms that duplicate the array or at least require a buffer of approximately half the length of the array.</p>",
        "id": 453333579,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721714033
    },
    {
        "content": "<p>That said, it may be a case that most arrays that get sorted easily fit at least L3 cache.</p>",
        "id": 453333874,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721714205
    },
    {
        "content": "<p>So the buffer as little cost.</p>",
        "id": 453333881,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721714220
    },
    {
        "content": "<p>Also, the buffers are used linearly, so cache locality is still good even with the large buffer.</p>",
        "id": 453333898,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721714236
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/453333313\">said</a>:</p>\n<blockquote>\n<p>or in real programs where the cost of cache misses due to evictions from that much memory usage is factored in</p>\n</blockquote>\n<p>I think that's as in \"real\" programs, as most algorithms are using some sort of merge under the covers which is feeding from two sources and writing the merged result to another location; since associative caches use multi-way association, this is well within their capability and there will just be jumps when jumping between different merge streams, which will quickly get the cache up to speed.  In the above merge sort benchmark, the main cost is the cost of comparisons at about 24 CPU clock cycles per, and this slow because the sorting data is seen as random and therefore unpredictable...</p>",
        "id": 453334018,
        "sender_full_name": "GordonBGood",
        "timestamp": 1721714329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/453333898\">said</a>:</p>\n<blockquote>\n<p>Also, the buffers are used linearly, so cache locality is still good even with the large buffer.</p>\n</blockquote>\n<p>As <span class=\"user-mention\" data-user-id=\"343810\">@Brendan Hansknecht</span>  says...</p>",
        "id": 453334069,
        "sender_full_name": "GordonBGood",
        "timestamp": 1721714377
    },
    {
        "content": "<p>yeah, given all that, it sounds like the fastest one is worth the extra memory usage!</p>",
        "id": 453334228,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721714443
    },
    {
        "content": "<p>So in that case that leaves 3 main options:</p>\n<ol>\n<li>fluxsort</li>\n<li>glidesort (with full n element memory)</li>\n<li>powersort</li>\n</ol>\n<hr>\n<p>Here are the rough pluses and minuses in my opinion:</p>\n<p>fluxsort:</p>\n<div class=\"codehilite\"><pre><span></span><code>+ To my understanding should be the fastest in the most cases on most hardware\n+ Can take advantage of patterns for more perf\n+ Tuned specifically with the idea of passing in a comparison function\n- Does more low level optimizations that while simple to understand may not port properly\n</code></pre></div>\n<p>glidesort:</p>\n<div class=\"codehilite\"><pre><span></span><code>~ might be the fastest in the future (depends very heavily on hardware, has optimizations for very new hardware)\n+ can take advantage of patterns for more perf\n- definitely the most complex to port (sorry rust)\n- has some extra tradeoffs made due to panic safety (but we technically don&#39;t need to port those)\n</code></pre></div>\n<p>powersort:</p>\n<div class=\"codehilite\"><pre><span></span><code>+ Definitely the simplest\n+ Vetted by python adopting it\n- Likely the slowest here, but still very fast overall. Worst cases:\n    1. Lots of equivalent elements (like `rand %100` or enums).\n    2. Patterns that are more complex than many repeated runs.\n- More comparisons on average\n</code></pre></div>",
        "id": 453336611,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721715888
    },
    {
        "content": "<p>Note, when I talk about powersort being the slowest in many cases, I would expect it to be within a lets say 3%. In the specific edge cases like lots of equality, it can be a huge diff potentially 2x.</p>",
        "id": 453337704,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721716326
    },
    {
        "content": "<p>And definitely take all of this with a solid grain of salt. This is from some local benchmarks of existing code, but mostly from trusting existing benchmarks, reading papers on algorithm implementations and tradeoffs, and intuition.</p>\n<p>The only way to truly know these tradeoffs would be to implement them all with the constraints of roc.</p>",
        "id": 453337902,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721716444
    },
    {
        "content": "<p>I'm guessing it's a fair bit of work to implement these. Like you wouldn't just implement a couple and have a flag?</p>",
        "id": 453338276,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1721716640
    },
    {
        "content": "<p>What about implementing the simple one first, and then potentially exploring the more experimental glidesort?</p>",
        "id": 453338318,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1721716674
    },
    {
        "content": "<blockquote>\n<p>a fair bit of work</p>\n</blockquote>\n<p>100% in fact the simple one is still pretty complex (if you want it fast and not just a naive port of the algorithm as a whole).</p>",
        "id": 453338741,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721716879
    },
    {
        "content": "<p>A note on the glidesort gains, I think they are a double edge sword. To my understanding they are likely what make it slower on middle end, low end, and embedded hardware. Though in 5 years probably will be fine on middle end. It merges in an interleaved manner to take advantage of out of order execution. And multiple memory streams. This is just larger overhead and potential cache conflicts on older/lower resource hardware.</p>\n<p>That said, all algorithms use at least 2 way merging to help some with out of order and multiple memory streams.</p>\n<p>In fact, the newest paper on power sort, it uses four way merging, but it has too much overhead to gain perf unless you have sentinel values (values that always sort greater than all other values). It uses them to avoid slice/subarray bounds checks. Just puts them at the end of chunks being merged.</p>\n<p>Glidesort looks to have managed multi way merging wins, but they are the main reason the perf varies so much by hardware.</p>",
        "id": 453341091,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721718002
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/453337902\">said</a>:</p>\n<blockquote>\n<p>and intuition...</p>\n</blockquote>\n<p>My intuition says try powersort or some slight derivation thereof, and maybe compare it with fluxsort if it isn't too much more complex.  At this stage, nothing is cast in stone and you can always revisit it later, and either of these or even my simple merge sort as per the above is better than the Zig code you have now...</p>",
        "id": 453409916,
        "sender_full_name": "GordonBGood",
        "timestamp": 1721739582
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/453341091\">said</a>:</p>\n<blockquote>\n<p>A note on the glidesort gains, I think they are a double edge sword. To my understanding they are likely what make it slower on middle end, low end, and embedded hardware. Though in 5 years probably will be fine on middle end. It merges in an interleaved manner to take advantage of out of order execution. And multiple memory streams. This is just larger overhead and potential cache conflicts on older/lower resource hardware.</p>\n</blockquote>\n<p>I don't think that's a big downside</p>",
        "id": 453414419,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721740716
    },
    {
        "content": "<p>it's hard to imagine a few percentage points of sorting perf being a major issue for embedded use cases; I wouldn't expect sorting to be a significant percentage of what they spend their time on regardless</p>",
        "id": 453414826,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721740839
    },
    {
        "content": "<p>and definitely optimizing for where hardware is going seems like a better idea than optimizing for where it is today, when there aren't yet any big Roc deployments that could actually take advantage of that on today's hardware anyway <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 453415080,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721740926
    },
    {
        "content": "<p>I do like that fluxsort is tuned for accepting a comparison function though; I definitely expect that to come up a lot!</p>",
        "id": 453415477,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721741054
    },
    {
        "content": "<p>based on that, fluxsort seems like the frontrunner to me unless there's some really significant implementation advantage to powersort being simpler, but it sounds like the simplicity of the algorithm itself is a relatively minor percentage of the overall project regardless, yeah?</p>",
        "id": 453415793,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1721741162
    },
    {
        "content": "<p>Yeah, it will be curious to see once we have one of these in zig, what the real overhead ends up being.</p>",
        "id": 453433789,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721746290
    },
    {
        "content": "<p>I don't think we could write raw roc as optimally, but the overhead of closures in zig and lack of mono could hit hard.</p>",
        "id": 453434471,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721746437
    },
    {
        "content": "<p>Long term will certainly try multiple configs.</p>",
        "id": 453434926,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721746527
    },
    {
        "content": "<p>That said, at least currently, we don't have anything interesting in roc to benchmark it against. So we'll have to think about what benchmarks we actually care about when it comes to perf here. What are our \"realworld\" enough sorting benchmarks.</p>",
        "id": 453445777,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721748490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/453445777\">said</a>:</p>\n<blockquote>\n<p>What are our \"realworld\" enough sorting benchmarks.</p>\n</blockquote>\n<p>Also as in Zig versus in \"native\" Roc...</p>\n<p>There is also that it would be really nice to have the <code>Sort</code> Ability in place rather than having to depend on whatever comparable behavior defaults there are for whatever Type one wants to use as a sorting key...</p>",
        "id": 453574960,
        "sender_full_name": "GordonBGood",
        "timestamp": 1721788273
    },
    {
        "content": "<p>I don't quite follow that statement, can you elaborate?</p>\n<p>The current plan for <code>Sort</code> is that it is a mapping from 2 inputs of the same type to <code>[EQ, LT, GT]</code>.</p>",
        "id": 453576899,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721789478
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/453576899\">said</a>:</p>\n<blockquote>\n<p>I don't quite follow that statement, can you elaborate?</p>\n</blockquote>\n<p>I mean that in order to implement a sort function, the contents need to be known to be comparable unless everything is automatically comparable (unless it contains a function), so tuples, records, Str's (???), Char's, and custom tagged union types are all comparable by these criteria (tuples, record's, and union's not containing a function); if they aren't comparable, then one could use the <code>sortWith</code> or <code>sortBy</code> variation, but the usual protocol is to apply the constraint to the type variable as in Elm (<code>sort : List comparable -&gt; List comparable</code>) or with an Ability (<code>sort : List a -&gt; List a where a implements Sort</code>)...</p>",
        "id": 453582831,
        "sender_full_name": "GordonBGood",
        "timestamp": 1721791560
    },
    {
        "content": "<p>Ah yeah, sort will be auto derive, but not for strings, functions, opaques. So most types will just have sort.</p>\n<p>We will expose <code>sort : List a -&gt; List a where a implements Sort</code>, but it will just wrap <code>List.sortWith</code>. <code>Sort</code> ability will be used to generate the comparison functions.</p>\n<p>We eventually may also want to add raw primitive sorts that automatically get dispatched to by <code>List.sort</code>, but that will depend on the gains it sees. If we are lucky, llvm might be smart enough to optimize sortWith on primitives and inline the indirect call to the constant compare function.</p>",
        "id": 453584345,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1721792030
    }
]