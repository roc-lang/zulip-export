[
    {
        "content": "<p>Hello, new enthusiastic rocer here :)<br>\nI have ported most of my task manager application into roc, its based on the webserver platform. I am fighting (hopefully <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>  ) one of the last issues, and that is having something to poke the local-host address every X minutes, to trigger notification logic.</p>\n<p>I think currently there is not way to create a thread in Roc, right?<br>\nI hoped I can bypass this via Command, using something like \"bash -c CMD &amp;\" or nohup, or some combination, but I have sunk several hours into it and nothing worked so far, usually I get error 127 and no such file or directory errs.</p>\n<div class=\"codehilite\"><pre><span></span><code>module [execute]\n\nimport pf.Command\nimport pf.Stdout\nimport KaskMonitor\n\nexecute =\n    res = Command.output! (Command.new &quot;nohup&quot; |&gt; Command.arg &quot;$(bashScript)&quot;)\n    Stdout.line! (Inspect.toStr res.status)\n    Stdout.line! (Str.fromUtf8 res.stdout |&gt; Result.withDefault &quot;broken stdout&quot;)\n    Stdout.line! (Str.fromUtf8 res.stderr |&gt; Result.withDefault &quot;broken stderr&quot;)\n    Task.ok {}\n\nbashScript =\n    f = &quot;/tmp/kodos&quot;\n    sleepDur = 1\n    address = &quot;localhost:8000/notify&quot;\n    &quot;echo MonitorScript &amp;&amp; sleep 3 &amp;&amp; [[ -f $(f) ]] &amp;&amp; exit; echo $$ &gt; $(f); while true; do [ \\&quot;\\$(curl -s -o /dev/null -w \\&quot;%{http_code}\\&quot; $(address))\\&quot; != \\&quot;200\\&quot; ] &amp;&amp; rm -f $(f) &amp;&amp; exit;sleep $(sleepDur);done&quot;\n</code></pre></div>\n<p>Hmm, now I am thinking I can also just create a never returning get request and use DB to ensure I cannot spawn several of them.. I considered it initially, but I am afraid there could be some internal timeout in the web-server platform, or maybe introduced later?</p>",
        "id": 474964570,
        "sender_full_name": "Pavel Mikuš",
        "timestamp": 1728121030
    },
    {
        "content": "<blockquote>\n<p>I think currently there is not way to create a thread in Roc, right?</p>\n</blockquote>\n<p>Not yet</p>\n<blockquote>\n<p><code>\"echo MonitorScript &amp;&amp; sleep 3 &amp;&amp; [[ -f $(f) ]] &amp;&amp; exit; echo $$ &gt; $(f); while true; do [ \\\"\\$(curl -s -o /dev/null -w \\\"%{http_code}\\\" $(address))\\\" != \\\"200\\\" ] &amp;&amp; rm -f $(f) &amp;&amp; exit;sleep $(sleepDur);done\"</code></p>\n</blockquote>\n<p>We use rust's std::process::Command under the hood, and I don't think you can pass arguments to commands that use <code>&amp;&amp;</code> or <code>;</code> to rust's <code>Command</code>. <br>\nOne solution that comes to mind is to clone basic-webserver locally and add another function like <a href=\"https://github.com/roc-lang/basic-webserver/blob/a50a0882b64494437de64cbff5f364b4a25809e7/crates/roc_host/src/roc.rs#L360\">this one</a> that uses rust's <a href=\"https://doc.rust-lang.org/std/process/struct.Command.html#method.spawn\"><code>spawn</code></a>. I would also put your series of commands in a single bash script.</p>\n<p>A never ending request that calls <a href=\"https://www.roc-lang.org/examples/TaskLoop/README.html\"><code>Task.loop</code></a> and <a href=\"https://roc-lang.github.io/basic-webserver/Sleep/#millis\"><code>Sleep.millis</code></a> may also work.</p>\n<p>I expect <span class=\"user-mention\" data-user-id=\"343810\">@Brendan Hansknecht</span> will know the best solution.<br>\nMaking things happen repeatedly or at a specific time, is quite common in webservers. So perhaps we should consider providing a nice way to do this in basic-webserver.</p>",
        "id": 474968442,
        "sender_full_name": "Anton",
        "timestamp": 1728124689
    },
    {
        "content": "<p>Ok,  I see, thanks. I'll do it via the never ending request then, I am sure there will be future refactorings anyway :) I don't want to maintain local copy of the platform, and the bash script is ugly as duck :)</p>",
        "id": 474975044,
        "sender_full_name": "Pavel Mikuš",
        "timestamp": 1728129154
    }
]