[
    {
        "content": "<p>I am trying to use a Num.pow inside a repl in roc playground, but I have several issues.</p>\n<p>When I am trying to do <code>Num.pow(1, 2)</code>, the repl straight up crashes.<br>\nWhen I try to do <code>import Num</code>, i get <code>LayoutError</code>. Is importing for interpretor not implemented yet?</p>",
        "id": 535817951,
        "sender_full_name": "EnDeRBeaT",
        "timestamp": 1755968976
    },
    {
        "content": "<blockquote>\n<p>When I try to do <code>import Num</code>, i get <code>LayoutError</code>. Is importing for interpretor not implemented yet?</p>\n</blockquote>\n<p>Builtins like <code>Num</code> are imported by default and never need to be imported explicitly.</p>\n<blockquote>\n<p>When I am trying to do <code>Num.pow(1, 2)</code>, the repl straight up crashes.</p>\n</blockquote>\n<p>I think the new compiler can not yet evaluate all the code in Num.roc yet, so that's probably why it's not available.</p>",
        "id": 535818718,
        "sender_full_name": "Anton",
        "timestamp": 1755969923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"361169\">Anton</span> <a href=\"#narrow/channel/231634-beginners/topic/how.20to.20import.20a.20module.20inside.20a.20repl/near/535818718\">said</a>:</p>\n<blockquote>\n<p>imported by default</p>\n</blockquote>\n<p>cir says <code>ident_not_in_scope</code> (<a href=\"https://roc-lang.github.io/roc-playground/#content=bW9kdWxlIFt4XQp4ID0gTnVtLmFkZCgxLCAyKQ==\">https://roc-lang.github.io/roc-playground/#content=bW9kdWxlIFt4XQp4ID0gTnVtLmFkZCgxLCAyKQ==</a>). It is either a misleading tag, or there is no prelude or something third.</p>",
        "id": 535819126,
        "sender_full_name": "EnDeRBeaT",
        "timestamp": 1755970384
    },
    {
        "content": "<p>I checked; Num.roc is not yet included in <code>src/builtins/roc/</code></p>",
        "id": 535819306,
        "sender_full_name": "Anton",
        "timestamp": 1755970636
    },
    {
        "content": "<p>Result.roc is included in there but e.g. <code>is_ok</code> also triggers <code>undefined variable</code>, I think no builtin functions are hooked up yet.</p>",
        "id": 535819542,
        "sender_full_name": "Anton",
        "timestamp": 1755970955
    },
    {
        "content": "<p>oh, that is where they are stored, i should check the structure of the project.</p>\n<p>How does that actually work? I see <code>num.zig</code> in <code>src/builtins/</code>, as well as many other standard modules. What does it take to include them into prelude? Why are they not in the prelude? Are they any tracking issues for those?</p>",
        "id": 535819557,
        "sender_full_name": "EnDeRBeaT",
        "timestamp": 1755970971
    },
    {
        "content": "<p>Also, since we are talking about this, I was wondering on what will be the story for interop between system languages and roc. Considering that the std is implemented in zig via extern functions, will regular folks be able to do the same thing for their own libraries?</p>",
        "id": 535854820,
        "sender_full_name": "EnDeRBeaT",
        "timestamp": 1755971219
    },
    {
        "content": "<blockquote>\n<p>I see <code>num.zig</code> in <code>src/builtins/</code>, as well as many other standard modules. What does it take to include them into prelude?</p>\n</blockquote>\n<p>These are mostly copied from the old compiler (crates/compiler/builtins/bitcode/src/num.zig) and slightly altered. The compiler can not compiler the roc part of Num.roc yet (like in crates/compiler/builtins/roc/Num.roc) so they can't be included yet.</p>",
        "id": 535854984,
        "sender_full_name": "Anton",
        "timestamp": 1755971377
    },
    {
        "content": "<blockquote>\n<p>Are they any tracking issues for those?</p>\n</blockquote>\n<p>No tracking issue yet, we could make hundreds of issues for all planned functionality. We generally communicate here to discuss the next steps that are available for implementation.</p>",
        "id": 535855038,
        "sender_full_name": "Anton",
        "timestamp": 1755971473
    },
    {
        "content": "<blockquote>\n<p>Considering that the std is implemented in zig via extern functions, will regular folks be able to do the same thing for their own libraries?</p>\n</blockquote>\n<p>We don't plan to support other language implementations for std functions. People can write their own variants with other names if they wish, using e.g a <a href=\"https://roc-lang.org/platforms\">platform</a> in their language.</p>",
        "id": 535855172,
        "sender_full_name": "Anton",
        "timestamp": 1755971670
    },
    {
        "content": "<blockquote>\n<p>interop between system languages and roc</p>\n</blockquote>\n<p>Next to platforms, I think we still plan to support compiling roc functions to a library, so you can call them from any language, I think using the C ABI but I'm not 100%.</p>",
        "id": 535855262,
        "sender_full_name": "Anton",
        "timestamp": 1755971797
    },
    {
        "content": "<p>Like <code>roc build --lib</code> in the old compiler</p>",
        "id": 535855328,
        "sender_full_name": "Anton",
        "timestamp": 1755971866
    },
    {
        "content": "<p>That is not really what I meant. Suppose I want to create a linalg library for Roc. I want it to be quite fast, so instead of using roc, I build it with C/Zig/Fortran, and expose API via C FFI. Will I be able to that in roc at some point?</p>",
        "id": 535855439,
        "sender_full_name": "EnDeRBeaT",
        "timestamp": 1755972008
    },
    {
        "content": "<p>It can be part of a platform and exposed to roc as such, but it can not be a standalone library</p>",
        "id": 535911423,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1756052146
    },
    {
        "content": "<p>If we allowed standalone libraries with arbitrary ffi, that would break rocs guarantees around platforms, effects, and io.</p>",
        "id": 535911453,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1756052183
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/channel/231634-beginners/topic/how.20to.20import.20a.20module.20inside.20a.20repl/near/535911423\">said</a>:</p>\n<blockquote>\n<p>It can be part of a platform</p>\n</blockquote>\n<p>Considering that you can only have one platform, don't you think that it might be too restrictive? You would need to have a separate ecosystem for platforms, and interop between platforms written in two different languages will become very cumbersome</p>",
        "id": 535914027,
        "sender_full_name": "EnDeRBeaT",
        "timestamp": 1756055226
    },
    {
        "content": "<p>Quite possibly, but breaking the fundamentals safety guarantees of roc sounds significantly worse.</p>\n<p>Also, a platform could offer generic ffi primitives if they wanted and a shared wrapper could be written in roc. That at least works for shared libraries.</p>\n<p>Oh, and given most nice platform ecosystem have a packaging solution, it does not sound hard to make a library meant to be shared between multiple platforms. A library just to fill in the primitives for roc.</p>",
        "id": 535922997,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1756065513
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/channel/231634-beginners/topic/how.20to.20import.20a.20module.20inside.20a.20repl/near/535922997\">said</a>:</p>\n<blockquote>\n<p>most nice platform ecosystem have a packaging solution</p>\n</blockquote>\n<p>the problem is that roc allows a platform to be written in any language (it's even one of the selling points). But interop between two system languages is <em>not pleasant</em> at best..</p>\n<p>I am not fully sold on \"platform can be used for shared libraries\", since that means all of them will be effectful. </p>\n<p>I don't really understand how libraries with C FFI (akin to how std lib is implemented) break rocs guarantees? Because the library can do syscalls outside of the platform code? Or there is something else I am missing</p>",
        "id": 535924647,
        "sender_full_name": "EnDeRBeaT",
        "timestamp": 1756067184
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"950624\">EnDeRBeaT</span> <a href=\"#narrow/channel/231634-beginners/topic/how.20to.20import.20a.20module.20inside.20a.20repl/near/535924647\">said</a>:</p>\n<blockquote>\n<p>the problem is that roc allows a platform to be written in any language (it's even one of the selling points). But interop between two system languages is <em>not pleasant</em> at best..</p>\n</blockquote>\n<p>Sure, but most major library tends to have cffi and be integrated in many languages. Blas, lapack, sqlite, etc. it does leave some split in the ecosystem, but nothing abnormal.</p>\n<blockquote>\n<p>I am not fully sold on \"platform can be used for shared libraries\", since that means all of them will be effectful. </p>\n</blockquote>\n<p>Yes, they have to be effects. Roc can make zero guarantees around the purity of c/zig/rust/etc code.</p>\n<blockquote>\n<p>I don't really understand how libraries with C FFI (akin to how std lib is implemented) break rocs guarantees? Because the library can do syscalls outside of the platform code? Or there is something else I am missing</p>\n</blockquote>\n<p>They aren't akin to the std lib implementation. The std lib is audited by us to respect the rules of roc. It guarantees purity from roc's perspective, uses the correct allocators, and never perform io/effects.</p>\n<p>An arbitrary escape hatch in library code would mean:</p>\n<ol>\n<li>You can no longer trust libraries to only do the effects you explicitly pass to them. They could run any effect at all via cffi.</li>\n<li>You can no longer guarantee immutability is respected. The library could mutate something in place.</li>\n<li>You can no longer guarantee the platform allocator is used. The ffi could use malloc or anything else.</li>\n</ol>\n<p>Roc has strong safety and correctness guarantees. By allowing arbitrary cffi, you lose all those guarantees. Every roc library would need to be much much more carefully audited. They are no longer sandboxed and trustable by default. The worst a roc library can do if written in pure roc is hang, crash, or oom. No other side effects.</p>",
        "id": 535931051,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1756075394
    },
    {
        "content": "<p>in that case, i wonder what would be the scope of roc standard library? Considering that you are the only people who are allowed to write pure code in performant languages, you'd naturally have to implement a lot of things so that not every function in the world is effectful.</p>",
        "id": 535953172,
        "sender_full_name": "EnDeRBeaT",
        "timestamp": 1756097699
    },
    {
        "content": "<p>Roc's standard library plans to be pretty minimal and mostly datastructures.</p>",
        "id": 535959184,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1756102418
    },
    {
        "content": "<p>I would guess that classes of roc applications will be exceptional effectful.</p>",
        "id": 535959298,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1756102498
    },
    {
        "content": "<p>For example, a script for a game engine might be nearly all effectful functions just with some pure kernels for algorithm. But most of it would be running effects in the game engine</p>",
        "id": 535959386,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1756102541
    },
    {
        "content": "<p>A high performance application that needs advanced linear algebra and potentially GPU support likely would also be very effect heavy. That or just wouldn't be the most suited app to write in roc.</p>",
        "id": 535959490,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1756102593
    },
    {
        "content": "<p>Effects are very streamlined in roc, so it isn't a big deal to have a ton of them</p>",
        "id": 535959517,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1756102609
    },
    {
        "content": "<p>I would say calling effects in the application is basically is zero cost. Calling effects in libraries that expect to be shared is higher costs, but not a huge deal, just kinda explicit.</p>",
        "id": 535959604,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1756102660
    },
    {
        "content": "<p>I do think this tradeoff will shape the more common applications seen in roc.</p>",
        "id": 535959791,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1756102764
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/channel/231634-beginners/topic/how.20to.20import.20a.20module.20inside.20a.20repl/near/535959791\">said</a>:</p>\n<blockquote>\n<p>I do think this tradeoff will shape the more common applications seen in roc.</p>\n</blockquote>\n<p>What kind of applications do you think Roc will be suited for? I heard some comments that Roc looks like \"DSL over platform\" which seems like a good summary.</p>",
        "id": 535961124,
        "sender_full_name": "EnDeRBeaT",
        "timestamp": 1756103442
    },
    {
        "content": "<blockquote>\n<p>What kind of applications do you think Roc will be suited for?</p>\n</blockquote>\n<p>Some things that come to mind: web, enterprise applications, games, scripts</p>",
        "id": 535976707,
        "sender_full_name": "Anton",
        "timestamp": 1756110077
    },
    {
        "content": "<p>\"DSL over platform\" will be one area of applications but that feels a bit narrow as a general description.</p>",
        "id": 535976833,
        "sender_full_name": "Anton",
        "timestamp": 1756110115
    },
    {
        "content": "<p>I think fundamentally it will be suited for a lot of general purpose compute. It may not always have access to the highest performance libraries, but platforms hopeful will package the core of what users might need. On top of that many forms of io can be boiled down to primitives that can be easily shared. For example, a basic socket primitive could be used to build up to tcp, http, and sql queries all in pure roc. So platforms could opt just to give basic primitives like that and allow roc to deal with all layers above that.</p>",
        "id": 536129727,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1756167203
    },
    {
        "content": "<p>Fundamentally, most developers are just dealing with getting correctness with good enough perf. They are not working on hyper optimized solutions. Most logic in this category could be written in pure roc.</p>",
        "id": 536129909,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1756167326
    },
    {
        "content": "<p>I do think roc has rather large disadvantages for perf heavy number crunching and similar problem spaces that would require relying on complex cffi library.</p>",
        "id": 536129999,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1756167384
    },
    {
        "content": "<p>But at any point, a platform could wrap libffi and allow roc do load shared libraries and do generic ffi. That would make it at least as capable as ruby or python in terms of ffi capabilities. Not a great solution, but functional (note: might require some additional compiler support for better experience).</p>",
        "id": 536130097,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1756167439
    },
    {
        "content": "<p>I also see this as a major selling point of roc. You still have access to the highest performance possible, but it's wrapped in a very ergonomic  API. </p>\n<p>Good platforms will bundle everything needed for a particular domain, and it will be worth the effort to optimise the experience using that platform. So not only will performance be better, but I also think various other cross cutting things will be advantaged, like security, portability, reliability, etc ...</p>",
        "id": 536133095,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1756169558
    }
]