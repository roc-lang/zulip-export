[
    {
        "content": "<p>When it comes to a host calling a closure, they get 3 parameters:<br>\nflags, closure data, and output.</p>\n<p>Is my understanding accurate that:<br>\nflags is inputs,<br>\nclosure data is captured variables,<br>\nand of course output is output.</p>",
        "id": 289000817,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1657319492
    },
    {
        "content": "<p>the flags bit is arbitrary</p>",
        "id": 289000909,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1657319548
    },
    {
        "content": "<p>in elm, your main function, in the most general case, takes some flags to get started</p>",
        "id": 289000937,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1657319565
    },
    {
        "content": "<p>but if on your platform you want to have two initial arguments, you can (or should be able to, I guess this is untested)</p>",
        "id": 289000977,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1657319594
    },
    {
        "content": "<p>So flags can be used as a input from the platform if wanted, but also can be used for other things?</p>",
        "id": 289001452,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1657319909
    },
    {
        "content": "<p>I guess? the idea here is that the platform can inject some data</p>",
        "id": 289001700,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1657320109
    },
    {
        "content": "<p>that data can come form the platform itself, or might be produced by other roc functions</p>",
        "id": 289001750,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1657320138
    },
    {
        "content": "<p>ok. makes sense</p>",
        "id": 289002064,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1657320461
    }
]