[
    {
        "content": "<p>I'm an absolute beginner at roc, so I thought I'd try a CS 101 exercise: naive functional mergesort. It is Slow. How should I go about figuring out why?</p>\n<div class=\"codehilite\"><pre><span></span><code>mergesort = \\list -&gt;\n    n = (List.len list) // 2\n    r = List.split list n\n    when n is\n        0 -&gt; list\n        _ -&gt; mergeSorted (mergesort r.before) (mergesort r.others)\n\nmergeSorted = \\left, right -&gt;\n    when left is\n        [] -&gt; right\n        [leftFirst, .. as leftRest] -&gt;\n            when right is\n                [] -&gt; left\n                [rightFirst, .. as rightRest] -&gt;\n                    if leftFirst &lt;= rightFirst then\n                        mergeSorted leftRest right |&gt; List.prepend leftFirst\n                    else\n                        mergeSorted left rightRest |&gt; List.prepend rightFirst\n</code></pre></div>\n<p>I know roc lists are actually contiguous arrays, so prepend, split, dropFirst, and maybe even destructuring may be expensive. But this is the obvious way to write the algorithm, so how should I find my way from here to something efficient?</p>\n<p>(Yes, I know there's a sort function, and I know that it's slow for a reason that may have to do with list operation problems, and I know there's a problem with lists where I can't even make one that's 100k elements long without a segfault. And maybe this algorithm will be efficient when the list problems are fixed. But how can I find out? Does my code permit tail-call elimination, opportunistic mutation, copy-free slicing?) </p>\n<p>Full code attached; I'm sure the style is appalling.<br>\n<a href=\"/user_uploads/22008/LsI_Uycxfv4YtKWxQCzDBHBq/main.roc\">main.roc</a></p>",
        "id": 418509885,
        "sender_full_name": "Anne Archibald",
        "timestamp": 1706454548
    },
    {
        "content": "<p>So generally speaking for measuring the performance of roc, you want to use <code>--optimize</code> and <code>--profiling</code>. Then use some sort of sampling profiler that can read the stack (perf, instruments, dtrace). I tend to find <code>perf</code> with <code>--call-graph dwarf</code> works the best, but the others are functional. I gave <a href=\"https://drive.google.com/file/d/11gKHrsUH3HwCPrqlXudCJRqkYyjWrfY_/view?usp=drive_link\">a talk about this in the last meetup</a>. Was the first talk.</p>",
        "id": 418517923,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1706461013
    },
    {
        "content": "<p>Looking at the profile, about 90% of the time is spent in <code>memmove</code></p>",
        "id": 418517942,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1706461031
    },
    {
        "content": "<p>This is do to prepending instead of appending to the arrays in mergeSorted.</p>",
        "id": 418517959,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1706461047
    },
    {
        "content": "<p>That is easy to fix with swapping to the last instead of the first:</p>\n<div class=\"codehilite\" data-code-language=\"Elm\"><pre><span></span><code><span class=\"nv\">mergeSorted</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"nv\">left</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">right</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"nv\">when</span><span class=\"w\"> </span><span class=\"nv\">left</span><span class=\"w\"> </span><span class=\"nv\">is</span>\n<span class=\"w\">        </span><span class=\"p\">[]</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nv\">right</span>\n<span class=\"w\">        </span><span class=\"p\">[</span><span class=\"nf\">..</span><span class=\"w\"> </span><span class=\"kr\">as</span><span class=\"w\"> </span><span class=\"nv\">leftRest</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">leftLast</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">            </span><span class=\"nv\">when</span><span class=\"w\"> </span><span class=\"nv\">right</span><span class=\"w\"> </span><span class=\"nv\">is</span>\n<span class=\"w\">                </span><span class=\"p\">[]</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nv\">left</span>\n<span class=\"w\">                </span><span class=\"p\">[</span><span class=\"nf\">..</span><span class=\"w\"> </span><span class=\"kr\">as</span><span class=\"w\"> </span><span class=\"nv\">rightRest</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">rightLast</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">                    </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"nv\">leftLast</span><span class=\"w\"> </span><span class=\"nf\">&gt;=</span><span class=\"w\"> </span><span class=\"nv\">rightLast</span><span class=\"w\"> </span><span class=\"kr\">then</span>\n<span class=\"w\">                        </span><span class=\"nv\">mergeSorted</span><span class=\"w\"> </span><span class=\"nv\">leftRest</span><span class=\"w\"> </span><span class=\"nv\">right</span><span class=\"w\"> </span><span class=\"nf\">|&gt;</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">append</span><span class=\"w\"> </span><span class=\"nv\">leftLast</span>\n<span class=\"w\">                    </span><span class=\"kr\">else</span>\n<span class=\"w\">                        </span><span class=\"nv\">mergeSorted</span><span class=\"w\"> </span><span class=\"nv\">left</span><span class=\"w\"> </span><span class=\"nv\">rightRest</span><span class=\"w\"> </span><span class=\"nf\">|&gt;</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">append</span><span class=\"w\"> </span><span class=\"nv\">rightLast</span>\n</code></pre></div>",
        "id": 418518035,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1706461103
    },
    {
        "content": "<p>After that, the function isn't tail recursive. which actually makes tracking down the real issue and getting a perf graph quite hard. Luckily, that is easy to fix as well:</p>\n<div class=\"codehilite\" data-code-language=\"Elm\"><pre><span></span><code><span class=\"nv\">mergeSorted</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"nv\">accum</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">left</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">right</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"nv\">when</span><span class=\"w\"> </span><span class=\"nv\">left</span><span class=\"w\"> </span><span class=\"nv\">is</span>\n<span class=\"w\">        </span><span class=\"p\">[]</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">concat</span><span class=\"w\"> </span><span class=\"nv\">accum</span><span class=\"w\"> </span><span class=\"nv\">right</span>\n<span class=\"w\">        </span><span class=\"p\">[</span><span class=\"nf\">..</span><span class=\"w\"> </span><span class=\"kr\">as</span><span class=\"w\"> </span><span class=\"nv\">leftRest</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">leftLast</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">            </span><span class=\"nv\">when</span><span class=\"w\"> </span><span class=\"nv\">right</span><span class=\"w\"> </span><span class=\"nv\">is</span>\n<span class=\"w\">                </span><span class=\"p\">[]</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">concat</span><span class=\"w\"> </span><span class=\"nv\">accum</span><span class=\"w\"> </span><span class=\"nv\">left</span>\n<span class=\"w\">                </span><span class=\"p\">[</span><span class=\"nf\">..</span><span class=\"w\"> </span><span class=\"kr\">as</span><span class=\"w\"> </span><span class=\"nv\">rightRest</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">rightLast</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">                    </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"nv\">leftLast</span><span class=\"w\"> </span><span class=\"nf\">&gt;=</span><span class=\"w\"> </span><span class=\"nv\">rightLast</span><span class=\"w\"> </span><span class=\"kr\">then</span>\n<span class=\"w\">                        </span><span class=\"nv\">mergeSorted</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">append</span><span class=\"w\"> </span><span class=\"nv\">accum</span><span class=\"w\"> </span><span class=\"nv\">leftLast</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">leftRest</span><span class=\"w\"> </span><span class=\"nv\">right</span>\n<span class=\"w\">                    </span><span class=\"kr\">else</span>\n<span class=\"w\">                        </span><span class=\"nv\">mergeSorted</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">append</span><span class=\"w\"> </span><span class=\"nv\">accum</span><span class=\"w\"> </span><span class=\"nv\">rightLast</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">left</span><span class=\"w\"> </span><span class=\"nv\">rightRest</span>\n</code></pre></div>",
        "id": 418518926,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1706461814
    },
    {
        "content": "<p>With this version, there is a solid chunk of time spent in <code>realloc</code> still. We can just add a <code>List.withCapacity</code> at the beginning to help alleviate that:</p>\n<div class=\"codehilite\" data-code-language=\"Elm\"><pre><span></span><code><span class=\"nv\">mergesort</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"nv\">list</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"nv\">list</span>\n<span class=\"w\">    </span><span class=\"nv\">n</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nv\">len</span><span class=\"w\"> </span><span class=\"nf\">//</span><span class=\"w\"> </span><span class=\"mi\">2</span>\n<span class=\"w\">    </span><span class=\"nv\">r</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">split</span><span class=\"w\"> </span><span class=\"nv\">list</span><span class=\"w\"> </span><span class=\"nv\">n</span>\n<span class=\"w\">    </span><span class=\"nv\">when</span><span class=\"w\"> </span><span class=\"nv\">n</span><span class=\"w\"> </span><span class=\"nv\">is</span>\n<span class=\"w\">        </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nv\">list</span>\n<span class=\"w\">        </span><span class=\"nv\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nv\">mergeSorted</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">withCapacity</span><span class=\"w\"> </span><span class=\"nv\">len</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">mergesort</span><span class=\"w\"> </span><span class=\"nv\">r</span><span class=\"nf\">.</span><span class=\"nv\">before</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nv\">mergesort</span><span class=\"w\"> </span><span class=\"nv\">r</span><span class=\"nf\">.</span><span class=\"nv\">others</span><span class=\"p\">)</span>\n</code></pre></div>",
        "id": 418519173,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1706462034
    },
    {
        "content": "<p>At this point, the next biggest obvious thing to fix is some refcounting stuff, but that is compiler work and not something to be done in userland.</p>",
        "id": 418519580,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1706462370
    },
    {
        "content": "<p>Of course even better than any of this would be to do all of the work inplace with indices, but that is essentially a full rewrite of the algorithm</p>",
        "id": 418519657,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1706462417
    },
    {
        "content": "<p>Thanks! I ended up with:</p>\n<div class=\"codehilite\"><pre><span></span><code>mergesort = \\list -&gt;\n    n = List.len list\n    r = List.split list (n//2)\n    when n is\n        0 -&gt; list\n        1 -&gt; list\n        _ -&gt; mergeSorted (List.withCapacity n) (mergesort r.before) (mergesort r.others)\n\nmergeSorted = \\accum, left, right -&gt;\n    when left is\n        [] -&gt; List.concat right (List.reverse accum)\n        [.. as leftRest, leftLast] -&gt;\n            when right is\n                [] -&gt; List.concat left (List.reverse accum)\n                [.. as rightRest, rightLast] -&gt;\n                    if leftLast &gt; rightLast then\n                        mergeSorted (List.append accum leftLast) leftRest right\n                    else\n                        mergeSorted (List.append accum rightLast) left rightRest\n</code></pre></div>\n<p>Is tail recursion easy enough to detect that the language server could highlight tail calls differently? (Particularly if it's modulo cons...) </p>\n<p>Appending versus prepending I guess is just something you have to know, and I suppose one should just trust the compiler to manage opportunistic mutation?</p>\n<p>Are there differences in efficiency for different destructuring patterns (a \"rest\" that's the beginning versus the end of the list, for example)?</p>\n<p>I guess one can always profile, but I'm hoping to develop some mental rules/idioms for efficient style.</p>",
        "id": 418722301,
        "sender_full_name": "Anne Archibald",
        "timestamp": 1706563138
    },
    {
        "content": "<blockquote>\n<p>(Particularly if it's modulo cons...) </p>\n</blockquote>\n<p>IIUC, which I very well may not, modulo cons only applies to tags in roc, so it wouldn't apply to this case. Roc's lists are flat.</p>\n<blockquote>\n<p>and I suppose one should just trust the compiler to manage opportunistic mutation?</p>\n</blockquote>\n<p>Trust but verify is my general opinion.</p>\n<blockquote>\n<p>Are there differences in efficiency for different destructuring patterns (a \"rest\" that's the beginning versus the end of the list, for example)?</p>\n</blockquote>\n<p>There shouldn't be for the most part. Though rest at the beginning in some certain mutating cases may be faster. Like if you took rest and then appended to it.</p>\n<blockquote>\n<p>List.reverse accum</p>\n</blockquote>\n<p>That will hurt perf. Probably should look into how this can be avoided.</p>",
        "id": 418724409,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1706563846
    },
    {
        "content": "<p>So probably actually want this:</p>\n<div class=\"codehilite\" data-code-language=\"Elm\"><pre><span></span><code><span class=\"nv\">mergeSorted</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nf\">\\</span><span class=\"nv\">accum</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">left</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">right</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"nv\">when</span><span class=\"w\"> </span><span class=\"nv\">left</span><span class=\"w\"> </span><span class=\"nv\">is</span>\n<span class=\"w\">        </span><span class=\"p\">[]</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">concat</span><span class=\"w\"> </span><span class=\"nv\">accum</span><span class=\"w\"> </span><span class=\"nv\">right</span>\n<span class=\"w\">        </span><span class=\"p\">[</span><span class=\"nv\">leftFirst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nf\">..</span><span class=\"w\"> </span><span class=\"kr\">as</span><span class=\"w\"> </span><span class=\"nv\">leftRest</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">            </span><span class=\"nv\">when</span><span class=\"w\"> </span><span class=\"nv\">right</span><span class=\"w\"> </span><span class=\"nv\">is</span>\n<span class=\"w\">                </span><span class=\"p\">[]</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">concat</span><span class=\"w\"> </span><span class=\"nv\">accum</span><span class=\"w\"> </span><span class=\"nv\">left</span>\n<span class=\"w\">                </span><span class=\"p\">[</span><span class=\"nv\">rightFirst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nf\">..</span><span class=\"w\"> </span><span class=\"kr\">as</span><span class=\"w\"> </span><span class=\"nv\">rightRest</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">                    </span><span class=\"kr\">if</span><span class=\"w\"> </span><span class=\"nv\">leftFirst</span><span class=\"w\"> </span><span class=\"nf\">&lt;=</span><span class=\"w\"> </span><span class=\"nv\">rightFirst</span><span class=\"w\"> </span><span class=\"kr\">then</span>\n<span class=\"w\">                        </span><span class=\"nv\">mergeSorted</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">append</span><span class=\"w\"> </span><span class=\"nv\">accum</span><span class=\"w\"> </span><span class=\"nv\">leftFirst</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">leftRest</span><span class=\"w\"> </span><span class=\"nv\">right</span>\n<span class=\"w\">                    </span><span class=\"kr\">else</span>\n<span class=\"w\">                        </span><span class=\"nv\">mergeSorted</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">List</span><span class=\"nf\">.</span><span class=\"nv\">append</span><span class=\"w\"> </span><span class=\"nv\">accum</span><span class=\"w\"> </span><span class=\"nv\">rightFirst</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nv\">left</span><span class=\"w\"> </span><span class=\"nv\">rightRest</span>\n</code></pre></div>",
        "id": 418726765,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1706564818
    },
    {
        "content": "<p>Now that we have an accumulator that we are appending to, that should be fast and always do inplace mutation.</p>",
        "id": 418726981,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1706564913
    },
    {
        "content": "<p>Btw, regarding <code>List.reverse</code>. Recently I had to use it only for backward walk. I haven’t checked, but the gut feeling suggests that it should be possible to optimize the iteration based on the ref counter (like, opportunistic zero-mutation). Isn’t it?</p>\n<p>Yes, there are walkBackwards flavours, but the list doesn't seem to be complete:</p>\n<div class=\"codehilite\"><pre><span></span><code>walk - walkBackwards\nwalkUntil - walkBackwardsUntil\n\nwalkWithIndex\nwalkWithIndexUntil\n\nwalkFrom\nwalkFromUntil\n</code></pre></div>",
        "id": 418734277,
        "sender_full_name": "Kiryl Dziamura",
        "timestamp": 1706568348
    },
    {
        "content": "<p>Yeah, we should probably add the backwards version of all of those functions. In the future, loop fusion on list functions may be able to make them equivalent, but that is thinking very long term. Filling out these functions is a better solution today. Contributions welcome to add any/all of theses.</p>",
        "id": 418737180,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1706569604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"685556\">Anne Archibald</span> <a href=\"#narrow/stream/231634-beginners/topic/Understanding.20performance/near/418722301\">said</a>:</p>\n<blockquote>\n<p>Is tail recursion easy enough to detect that the language server could highlight tail calls differently? (Particularly if it's modulo cons...) </p>\n</blockquote>\n<p>I actually really like this idea, I just tried to implement it and hit some issues, but got it kind of working<br>\n<a href=\"/user_uploads/22008/qTSINzV-P9xhJQJF7iFYwC0J/image.png\">image.png</a><br>\n<a href=\"/user_uploads/22008/6K1bHMYJlCVOvPmyjnxLqEgJ/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/22008/qTSINzV-P9xhJQJF7iFYwC0J/image.png\" title=\"image.png\"><img src=\"/user_uploads/22008/qTSINzV-P9xhJQJF7iFYwC0J/image.png\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/22008/6K1bHMYJlCVOvPmyjnxLqEgJ/image.png\" title=\"image.png\"><img src=\"/user_uploads/22008/6K1bHMYJlCVOvPmyjnxLqEgJ/image.png\"></a></div>",
        "id": 418746443,
        "sender_full_name": "Eli Dowling",
        "timestamp": 1706574717
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"685556\">@Anne Archibald</span> I've made a new topic for this editor integration and have it working in a branch if you'd like to try it :)<br>\n<a href=\"#narrow/stream/304641-ideas/topic/Editor.20indicate.20if.20a.20function.20is.20tail.20recursive\">https://roc.zulipchat.com/#narrow/stream/304641-ideas/topic/Editor.20indicate.20if.20a.20function.20is.20tail.20recursive</a></p>",
        "id": 418763649,
        "sender_full_name": "Eli Dowling",
        "timestamp": 1706587264
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/231634-beginners/topic/Understanding.20performance/near/418726981\">said</a>:</p>\n<blockquote>\n<p>Now that we have an accumulator that we are appending to, that should be fast and always do inplace mutation.</p>\n</blockquote>\n<p>I can't speak for the mutation, but it seems to me that the list destructuring [a, .. as rest] has to effectively do a dropFirst to construct rest. That would seem to require copying all but one of the elements to a new list. Or is there an efficient way to do this list destructuring operation?</p>",
        "id": 419514523,
        "sender_full_name": "Anne Archibald",
        "timestamp": 1706899664
    },
    {
        "content": "<p>We have seamless slice. So you will just get a slice referencing the original list except the first element.</p>",
        "id": 419520655,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1706902045
    }
]