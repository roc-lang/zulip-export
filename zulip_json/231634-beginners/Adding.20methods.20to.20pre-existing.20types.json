[
    {
        "content": "<p>As I understand it, under the new version a “method” is simply a function defined in the same module as the type of its first argument. These can be called via dot chaining. In contrast, a function defined outside of the module cannot, although it can be chained via a similar syntax (last I heard, using an arrow -&gt;). Thus, Roc distinguishes between functions defined together with a type and those defined later, unlike several other languages that support dot chaining (Swift, Nim, Lean). I’m sure this has advantages and disadvantages. </p>\n<p>I’m curious though about how it affects generic functions with type constraints. It seems like you can constrain a type based on its methods, but not based on functions defined outside its module. Is that right? Does that mean there’s no clean way to add methods to a pre-existing type so that a generic function requiring those methods can be called on it?</p>\n<p>Thanks.</p>",
        "id": 572632488,
        "sender_full_name": "misterdrgn",
        "timestamp": 1770567943
    },
    {
        "content": "<p>I think you would need a wrapper type that works to create the interface you want</p>",
        "id": 572640164,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1770574281
    },
    {
        "content": "<p>So an explicit level of translation</p>",
        "id": 572640173,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1770574292
    },
    {
        "content": "<p>Thanks, that’s what I thought. I wonder how often in practice people will be tempted to create wrapper types, or even create their own versions of existing modules so that they can add functionality. I don’t know how difficult (or non-idiomatic) it would be to shadow an existing module with your own version, like you can in a language like Ocaml.</p>",
        "id": 572645491,
        "sender_full_name": "misterdrgn",
        "timestamp": 1770580132
    },
    {
        "content": "<p>I think you hit the exact same in go with their interfaces and that ecosystem is fine.</p>",
        "id": 572666058,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1770600712
    },
    {
        "content": "<p>So I'm not too worried</p>",
        "id": 572666060,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1770600716
    },
    {
        "content": "<p>Got it, thanks. Yeah, does look similar in Go. They have struct embedding to help with that, but I dunno how much people use it.</p>",
        "id": 572670582,
        "sender_full_name": "misterdrgn",
        "timestamp": 1770604698
    }
]