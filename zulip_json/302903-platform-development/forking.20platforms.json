[
    {
        "content": "<p>I'm curious what the platform paradigm will be as Roc gets more mature. Since you can only include a single platform per app it seems like the main dev strategy will be to fork the platform that seems closest to your domain and extend it. e.g. I wanted to add GNU MPFR to a Math lib in basic-cli platform but it doesn't have that so I forked basic-cli and added it. Is this congruent with what yall see?</p>",
        "id": 564919079,
        "sender_full_name": "nandi",
        "timestamp": 1766356882
    },
    {
        "content": "<p>Yes, I think for niche use cases that will be commona and encouraged. Common features for a particular domain will probably be included in a platform the targets that use case. </p>\n<p>Also as the package ecosystem matures there will be more demand for writing things in pure Roc.</p>",
        "id": 564920365,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1766358715
    },
    {
        "content": "<p>also, I think math is a specific case where doing it at the platform level won't have good long-term ergonomics because platforms can only provide effectful functions implemented in lower-level languages, not pure functions - so all the math operations would need to be effectful functions</p>",
        "id": 564922411,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1766361747
    },
    {
        "content": "<p>so when it comes to math operations specifically, I'd be curious whether MPFR semantics could be implemented in pure Roc code with sufficient performance!</p>",
        "id": 564922503,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1766361803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/channel/302903-platform-development/topic/forking.20platforms/near/564922503\">said</a>:</p>\n<blockquote>\n<p>so when it comes to math operations specifically, I'd be curious whether MPFR semantics could be implemented in pure Roc code with sufficient performance!</p>\n</blockquote>\n<p>I asked myself this question because for that library in particular it seems like languages do ffi for the most part because it's a very specific implementation like both julia and rust use the c lib. in julia it's compiled into runtime, in rust they use rug crate which is ffi</p>",
        "id": 564922725,
        "sender_full_name": "nandi",
        "timestamp": 1766362127
    },
    {
        "content": "<p>yeah, same with BLAS and LAPACK</p>",
        "id": 564927129,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1766368550
    },
    {
        "content": "<p>so far it seems like the main reason not to have these in pure Roc is expediency; I haven't heard a case made that they'd be relevantly faster if Roc had C FFI, and allowing FFI of pure functions has a lot of downsides</p>",
        "id": 564927397,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1766368942
    },
    {
        "content": "<p>I'm curious what you use MPFR for!</p>",
        "id": 564928923,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1766371139
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/channel/302903-platform-development/topic/forking.20platforms/near/564928923\">said</a>:</p>\n<blockquote>\n<p>I'm curious what you use MPFR for!</p>\n</blockquote>\n<p>I'm a math nerd so I use it for things like pi calculation formulas etc. Not really super pressing since I use julia for most math stuff, but my attempts to work in that world in Roc made me start thinking about such things. </p>\n<p>Ostensibly the Roc stdlib could just wrap the lib, or is Roc stdlib purely Roc code?</p>",
        "id": 564930317,
        "sender_full_name": "nandi",
        "timestamp": 1766372899
    },
    {
        "content": "<p>it could, but we already have <a href=\"https://roc-lang.org/builtins/alpha4/Num/#Dec\"><code>Dec</code></a> - is that insufficient for pi calculation formulas?</p>",
        "id": 564930682,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1766373433
    },
    {
        "content": "<p>Didn't know that type existed. Thanks</p>",
        "id": 564931434,
        "sender_full_name": "nandi",
        "timestamp": 1766374494
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/channel/302903-platform-development/topic/forking.20platforms/near/564927397\">said</a>:</p>\n<blockquote>\n<p>so far it seems like the main reason not to have these in pure Roc is expediency; I haven't heard a case made that they'd be relevantly faster if Roc had C FFI, and allowing FFI of pure functions has a lot of downsides</p>\n</blockquote>\n<p>For some of those math libraries, raw assembly is needed for the speed. Next level down is just really good control of simd. Currently roc has neither. So you would definitely hit a limit in pure roc.</p>\n<p>So I'm sure the limit will be found, the question is when and if it will matter for many.</p>",
        "id": 565077255,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1766442256
    },
    {
        "content": "<p>Would be cool to see a super computer running roc apps for the core logic some day.</p>",
        "id": 565077273,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1766442272
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/channel/302903-platform-development/topic/forking.20platforms/near/565077255\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/channel/302903-platform-development/topic/forking.20platforms/near/564927397\">said</a>:</p>\n<blockquote>\n<p>so far it seems like the main reason not to have these in pure Roc is expediency; I haven't heard a case made that they'd be relevantly faster if Roc had C FFI, and allowing FFI of pure functions has a lot of downsides</p>\n</blockquote>\n<p>For some of those math libraries, raw assembly is needed for the speed. </p>\n</blockquote>\n<p>is it though?</p>",
        "id": 565081142,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1766445474
    },
    {
        "content": "<p>I mean it's true that they use it, but is that because they started with llvm optimizations and found them inadequate, or because of some combination of: </p>\n<ul>\n<li>they were written before the optimizations were as good as they are now, and there wasn't motivation to rewrite away from assembly since it already worked</li>\n<li>assembly indeed outperforms llvm but it's actually a small difference - but why not? Faster is better!</li>\n</ul>",
        "id": 565081235,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1766445607
    },
    {
        "content": "<p>basically I'm skeptical (but open to being convinced otherwise!) that there exist tons of heavy duty numeric computation projects where the combination of Python with C + asm FFI is sufficiently fast, but optimized llvm wouldn't be fast enough</p>",
        "id": 565081373,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1766445732
    },
    {
        "content": "<p>like maybe that's true, but it certainly does not seem to be <em>obviously</em> true</p>",
        "id": 565081385,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1766445747
    },
    {
        "content": "<p>and yes, Roc doesn't have simd support yet, but I want it to in the future...it's really unfortunate how fraught the API design space there is because of all the CPU arch differences <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 565081490,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1766445845
    },
    {
        "content": "<p>How much would need to change for future simd support in Roc? Is that all under the hood and not something that changes the language? I thought it was basically the Iter and fusion thing.. but I might be mis-remembering</p>",
        "id": 565086768,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1766451490
    },
    {
        "content": "<p>it's just a design question really</p>",
        "id": 565153925,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1766495215
    },
    {
        "content": "<p>we could add some kind of support for it anytime, the question is just what the code would look like</p>",
        "id": 565154036,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1766495262
    },
    {
        "content": "<p>and I don't think there's a clear answer to the question of what the code should look like <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 565154220,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1766495340
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/channel/302903-platform-development/topic/forking.20platforms/near/565081142\">said</a>:</p>\n<blockquote>\n<p>is it though?</p>\n</blockquote>\n<p>It's a solid question. As I learn more and more from folks working on kernels in mojo (which are mostly GPU nowadays, but we have some solid cpu kernels), it is more and more about giving the programming direct control rather than relying on the compiler.</p>",
        "id": 565329912,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1766624771
    },
    {
        "content": "<p>That said, it is not a bunch of raw assembly. It is directly simd or direct control of memory hierarchies or etc.</p>",
        "id": 565329957,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1766624840
    },
    {
        "content": "<p>Though mojo is weird in that it lets you directly output any mlir. Which means any llvm intrinsics. Which means almost emitting raw assembly if you need it.</p>",
        "id": 565329986,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1766624907
    },
    {
        "content": "<p>But yeah, a roc loop with a good simd abstraction should be able to optimize exceptionally well.</p>\n<p>With roc we just have to continue to fight any refcounting in tight loops that might ruin perf.</p>\n<p>And without a good simd abstraction definitely hit a wall way way sooner. Cause llvm only turns really clean loops into simd.</p>",
        "id": 565330214,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1766625312
    },
    {
        "content": "<p>Anyway, I overall agree with the general thesis....just less by compiler optimization and more by exposing control.</p>",
        "id": 565330229,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1766625343
    },
    {
        "content": "<p>yeah and I'm fine in principle with exposing control, as long as it doesn't violate our invariants (e.g. not introducing memory unsafety!) or make the language overly complicated</p>",
        "id": 565332041,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1766628108
    },
    {
        "content": "<p>of course that's the tricky API design part <span aria-label=\"smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 565332048,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1766628122
    },
    {
        "content": "<p>oh also sacrificing cross-platform is something I'd really want to avoid</p>",
        "id": 565332072,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1766628154
    },
    {
        "content": "<p>like for example if we wanted to just expose simd intrinsics for a single CPU architecture, then maybe we could do something with <code>var</code></p>",
        "id": 565332085,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1766628176
    },
    {
        "content": "<p>because <code>var</code> already has the rules you'd want for representing a register - can't cross function boundaries, doesn't affect the function's purity, etc. - but then how do you deal with the architecture-specific stuff?</p>",
        "id": 565332127,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1766628262
    },
    {
        "content": "<p>and wasm for that matter</p>",
        "id": 565332132,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1766628267
    }
]