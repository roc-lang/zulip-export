[
    {
        "content": "<p>Hi,</p>\n<p>I try to have a <code>mainForHost</code> in a platform, that returns a struct which has a field that is a function:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">Job</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"nv\">name</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">List</span><span class=\"w\"> </span><span class=\"nx\">U8</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"nv\">value</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">List</span><span class=\"w\"> </span><span class=\"nx\">U8</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"nv\">callback</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nx\">List</span><span class=\"w\"> </span><span class=\"nx\">U8</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nx\">List</span><span class=\"w\"> </span><span class=\"nx\">U8</span><span class=\"p\">),</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>But I am not able to build the corresponding data structure in zig. I was able, that roc returns a function or that roc returns a struct without a function, but I have no idea how to handle the combination.</p>\n<p>What I want to do in zig is getting the pointer to the function, so I can call <code>roc__mainForHost_0_caller</code>.</p>\n<p>Here is my current code: <a href=\"https://github.com/ostcar/roc-wasm-platform/blob/5868b4a423ea70fc0387dbad66cafc7ca765fe1f/src/host.zig#L50\">https://github.com/ostcar/roc-wasm-platform/blob/5868b4a423ea70fc0387dbad66cafc7ca765fe1f/src/host.zig#L50</a></p>\n<p>To see the platform in action, you can use this example: <a href=\"https://github.com/ostcar/roc-wasm-platform/tree/task/examples/echo\">https://github.com/ostcar/roc-wasm-platform/tree/task/examples/echo</a></p>",
        "id": 371320921,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688165530
    },
    {
        "content": "<p>Iirc, how it should work:</p>\n<p>That function just returns closure capture data for the callback. The callback would need to be exposed and called directly like <code>mainForHost</code> is called.</p>",
        "id": 371502876,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1688222712
    },
    {
        "content": "<p>Should be doable. Probably need an <code>as</code> statement in the type to get roc to expose the caller function (though not 100% sure if that still is the case)</p>",
        "id": 371503351,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1688222827
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281543\">@Folkert de Vries</span> does that sound correct with the latest glue and function related changes?</p>",
        "id": 371503692,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1688222915
    },
    {
        "content": "<p>I'm assuming glue is not used here?</p>",
        "id": 371508957,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688224145
    },
    {
        "content": "<p>if that is correct then yes you'd need to name the function type (so something like<code>callback : (a -&gt; b) as Foo</code> in the signature of <code>mainForHost</code></p>",
        "id": 371509062,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688224179
    },
    {
        "content": "<p>Yeah, glue isn't used, but I wasn't sure if the function generation strategy changed some because of glue changes.</p>\n<p>But yeah, your comment matches what I thought was needed.</p>",
        "id": 371522054,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1688227275
    },
    {
        "content": "<p>Does the job type still need to be embedded in they type of <code>mainForHost</code> or can the <code>as</code> go in the job type definition?</p>",
        "id": 371522198,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1688227310
    },
    {
        "content": "<p>must literally be in the type of <code>mainForHost</code></p>",
        "id": 371522299,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688227328
    },
    {
        "content": "<p>Glue is not used. As far as I know, glue does currently not support zig. If I am wrong, I would like to use glue.</p>\n<p>I tried it with the <code>as</code> statement, but it did not help. I am not sure if <code>as</code> is needed. If I just return a function (<code>mainForHost : List u8 -&gt; (List U8 -&gt; List U8)</code>) then it works. roc creates a function <code>roc__mainForHost_0_caller</code> that I can call with the return value from <code>roc__mainForHost_1_exposed</code> and everything works fine.</p>\n<p>I am a step farther but my zig knowledge is to low:</p>\n<p>In roc, I have the type :</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">Job</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"nv\">name</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">List</span><span class=\"w\"> </span><span class=\"nx\">U8</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"nv\">value</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">List</span><span class=\"w\"> </span><span class=\"nx\">U8</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"nv\">callback</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">List</span><span class=\"w\"> </span><span class=\"nx\">U8</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nx\">List</span><span class=\"w\"> </span><span class=\"nx\">U8</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>In zig I have the type:</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">Job</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kr\">extern</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">placeholder_I_dont_understand</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">u128</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RocList</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RocList</span><span class=\"w\"> </span><span class=\"p\">};</span>\n<span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">RocList</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kr\">extern</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">pointer</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"o\">*</span><span class=\"p\">]</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">capacity</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"w\"> </span><span class=\"p\">};</span>\n\n<span class=\"kr\">extern</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">roc__mainForHost_1_exposed</span><span class=\"p\">(</span><span class=\"n\">job</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">Job</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">argument</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">RocList</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"p\">;</span>\n<span class=\"kr\">extern</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">roc__mainForHost_0_caller</span><span class=\"p\">(</span><span class=\"n\">argument</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">RocList</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">callback_pointer</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"o\">*</span><span class=\"p\">]</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">RocList</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"p\">;</span>\n</code></pre></div>\n<p>With the following code, I get a pointer, that I can use to call <code>roc__mainForHost_0_caller</code></p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"kr\">var</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">Job</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">undefined</span><span class=\"p\">;</span>\n<span class=\"n\">roc__mainForHost_1_exposed</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">arg</span><span class=\"p\">);</span>\n<span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">@ptrCast</span><span class=\"p\">([</span><span class=\"o\">*</span><span class=\"p\">]</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"p\">);</span>\n</code></pre></div>\n<p>With the following code, I get (a pointer to) the value of the name-attribute.</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"kr\">var</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Job</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">undefined</span><span class=\"p\">;</span>\n<span class=\"n\">roc__mainForHost_1_exposed</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">result</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">arg</span><span class=\"p\">);</span>\n<span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"p\">.</span><span class=\"n\">name</span><span class=\"p\">.</span><span class=\"n\">pointer</span><span class=\"p\">;</span>\n</code></pre></div>\n<p>But I do not know how to call <code>roc__mainForHost_1_exposed</code> so I can get the callresult pointer and the name attribute.</p>\n<p>I would have guest, that it should be easy to go from <code>*Job</code> to <code>Job</code> with something like <code>&amp;result.name.pointer</code> or <code>result.*.name.pointer</code>, but nothing seems to work.</p>",
        "id": 371561410,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688240142
    },
    {
        "content": "<p>the zig syntax is <code>ptr.*</code>  to dereference the pointer</p>",
        "id": 371561879,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688240309
    },
    {
        "content": "<p>and you can use the <code>--debug</code> flag in your roc build/run command to have roc generate <code>.ll</code> files. Those contain exactly the names/types of functions that roc generates, so that you can use them from zig</p>",
        "id": 371562013,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688240393
    },
    {
        "content": "<p>Success! Thank you.</p>\n<p>But the solution was something different. As I looked at the values, zig behaved very strange. For example the pointer cast to an int was something like <code>7</code>. And the value from <code>1000 + @ptrToInt(result.name.pointer)</code> was still <code>7</code></p>\n<p>So I updated to zig 0.10.1 and everything worked.</p>\n<p>It seems, that there are some critical bugs in zig 0.9.1 with wasm that where fixed with zig 0.10.1.</p>\n<p>I hope roc will switch to zig 0.10.1 in the near future and  for the meantime removes the <code>--strip</code>argument from the wasm build. See <a href=\"#narrow/stream/231634-beginners/topic/Bundle.20a.20wasm.20platform/near/369321926\">https://roc.zulipchat.com/#narrow/stream/231634-beginners/topic/Bundle.20a.20wasm.20platform/near/369321926</a></p>",
        "id": 371564720,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688241550
    },
    {
        "content": "<p>we want to update more to zig 0.11 which should be released soon</p>",
        "id": 371565754,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688242002
    },
    {
        "content": "<p>I am sure, it will also work with zig 0.11. <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 371567005,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688242611
    },
    {
        "content": "<p>Could I ask for you help once more? I am still struggling with zig. I never used a language with manual memory management before. So I have some difficulties with it.</p>\n<p>I am trying to write a function in zig, that calls roc and then returns a pointer to a zig-struct with two values. If I am correct, I have to allocate this struct on the heap. But as soon as I allocate anything, the value from roc gets corrupted.</p>\n<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"kr\">var</span><span class=\"w\"> </span><span class=\"n\">roc_result</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">undefined</span><span class=\"p\">;</span>\n<span class=\"n\">roc__mainForHost_1_exposed</span><span class=\"p\">(</span><span class=\"n\">roc_result</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">arg</span><span class=\"p\">);</span>\n<span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">roc_result</span><span class=\"p\">;</span>\n</code></pre></div>\n<p>This does not work:</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">allocator</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">.</span><span class=\"n\">heap</span><span class=\"p\">.</span><span class=\"n\">page_allocator</span><span class=\"p\">;</span>\n\n<span class=\"kr\">var</span><span class=\"w\"> </span><span class=\"n\">roc_result</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">undefined</span><span class=\"p\">;</span>\n<span class=\"n\">roc__mainForHost_1_exposed</span><span class=\"p\">(</span><span class=\"n\">roc_result</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">arg</span><span class=\"p\">);</span>\n<span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">allocator</span><span class=\"p\">.</span><span class=\"n\">create</span><span class=\"p\">(</span><span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">catch</span>\n<span class=\"w\">    </span><span class=\"nb\">@panic</span><span class=\"p\">(</span><span class=\"s\">\"failed to allocate result type\"</span><span class=\"p\">);</span>\n<span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">roc_result</span><span class=\"p\">;</span>\n</code></pre></div>\n<p>I use the <code>roc_alloc</code> function, that is used by any zig-platform in the repo:</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">Align</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kr\">extern</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"w\"> </span><span class=\"p\">};</span>\n<span class=\"kr\">extern</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">malloc</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">callconv</span><span class=\"p\">(.</span><span class=\"n\">C</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">?*</span><span class=\"kr\">align</span><span class=\"p\">(</span><span class=\"nb\">@alignOf</span><span class=\"p\">(</span><span class=\"n\">Align</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"n\">anyopaque</span><span class=\"p\">;</span>\n<span class=\"kr\">extern</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">realloc</span><span class=\"p\">(</span><span class=\"n\">c_ptr</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"o\">*</span><span class=\"p\">]</span><span class=\"kr\">align</span><span class=\"p\">(</span><span class=\"nb\">@alignOf</span><span class=\"p\">(</span><span class=\"n\">Align</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">callconv</span><span class=\"p\">(.</span><span class=\"n\">C</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">?*</span><span class=\"n\">anyopaque</span><span class=\"p\">;</span>\n<span class=\"kr\">extern</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">free</span><span class=\"p\">(</span><span class=\"n\">c_ptr</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"o\">*</span><span class=\"p\">]</span><span class=\"kr\">align</span><span class=\"p\">(</span><span class=\"nb\">@alignOf</span><span class=\"p\">(</span><span class=\"n\">Align</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">callconv</span><span class=\"p\">(.</span><span class=\"n\">C</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"p\">;</span>\n<span class=\"kr\">extern</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">memcpy</span><span class=\"p\">(</span><span class=\"n\">dest</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">anyopaque</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">src</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">anyopaque</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">count</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">anyopaque</span><span class=\"p\">;</span>\n\n<span class=\"kr\">export</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">roc_alloc</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">alignment</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">callconv</span><span class=\"p\">(.</span><span class=\"n\">C</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">?*</span><span class=\"n\">anyopaque</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">alignment</span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">malloc</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"kr\">export</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">roc_realloc</span><span class=\"p\">(</span><span class=\"n\">c_ptr</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">anyopaque</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">new_size</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">old_size</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">alignment</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">callconv</span><span class=\"p\">(.</span><span class=\"n\">C</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">?*</span><span class=\"n\">anyopaque</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">old_size</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">alignment</span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">realloc</span><span class=\"p\">(</span><span class=\"nb\">@alignCast</span><span class=\"p\">(</span><span class=\"nb\">@alignOf</span><span class=\"p\">(</span><span class=\"n\">Align</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"nb\">@ptrCast</span><span class=\"p\">([</span><span class=\"o\">*</span><span class=\"p\">]</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">c_ptr</span><span class=\"p\">)),</span><span class=\"w\"> </span><span class=\"n\">new_size</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"kr\">export</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">roc_dealloc</span><span class=\"p\">(</span><span class=\"n\">c_ptr</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">anyopaque</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">alignment</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">callconv</span><span class=\"p\">(.</span><span class=\"n\">C</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">alignment</span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"n\">free</span><span class=\"p\">(</span><span class=\"nb\">@alignCast</span><span class=\"p\">(</span><span class=\"nb\">@alignOf</span><span class=\"p\">(</span><span class=\"n\">Align</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"nb\">@ptrCast</span><span class=\"p\">([</span><span class=\"o\">*</span><span class=\"p\">]</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">c_ptr</span><span class=\"p\">)));</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Could it be, that the zig <code>page_allocator</code> and <code>roc_alloc</code> are writing to the same places? How could I rewrite the <code>roc_alloc</code> to use the <code>page_allocator</code>?</p>",
        "id": 372294365,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688474351
    },
    {
        "content": "<p>bunch of stuff going on here. </p>\n<p>what is the signature of <code>roc__mainForHost_1_exposed</code>? </p>\n<div class=\"codehilite\"><pre><span></span><code>var roc_result: u32 = undefined;\nroc__mainForHost_1_exposed(roc_result, arg);\n</code></pre></div>",
        "id": 372295860,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688474677
    },
    {
        "content": "<p>you seem to give it a <code>u32</code> which is almost certainly not what the LLVM code says it should be</p>",
        "id": 372295925,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688474694
    },
    {
        "content": "<p>I expect that it wants a pointer, maybe <code>i32*</code> in the llvm IR? or something ending in <code>*</code> certainly</p>",
        "id": 372296079,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688474724
    },
    {
        "content": "<p>so in general. the fact that the earlier program seems to work is coincidence. the zig side has to match the roc (llvm) side exactly</p>",
        "id": 372296738,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688474862
    },
    {
        "content": "<p>I am not able to read the llvm definitions. Here it is:</p>\n<div class=\"codehilite\" data-code-language=\"LLVM\"><pre><span></span><code><span class=\"k\">define</span><span class=\"w\"> </span><span class=\"k\">void</span><span class=\"w\"> </span><span class=\"vg\">@roc__mainForHost_1_exposed</span><span class=\"p\">({</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">0</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">12</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">3</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"nv\">%list.RocList</span><span class=\"w\"> </span><span class=\"p\">}*</span><span class=\"w\"> </span><span class=\"k\">sret</span><span class=\"p\">({</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">0</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">12</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">3</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"nv\">%list.RocList</span><span class=\"w\"> </span><span class=\"p\">})</span><span class=\"w\"> </span><span class=\"nv nv-Anonymous\">%0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">*,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"p\">}*</span><span class=\"w\"> </span><span class=\"nv nv-Anonymous\">%1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"nl\">entry:</span>\n<span class=\"w\">  </span><span class=\"nv\">%result_value</span><span class=\"w\"> </span><span class=\"p\">=</span><span class=\"w\"> </span><span class=\"k\">alloca</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">0</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">12</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">3</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"nv\">%list.RocList</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"k\">align</span><span class=\"w\"> </span><span class=\"m\">8</span>\n<span class=\"w\">  </span><span class=\"nv\">%bitcast_arg</span><span class=\"w\"> </span><span class=\"p\">=</span><span class=\"w\"> </span><span class=\"k\">bitcast</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">*,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"p\">}*</span><span class=\"w\"> </span><span class=\"nv nv-Anonymous\">%1</span><span class=\"w\"> </span><span class=\"k\">to</span><span class=\"w\"> </span><span class=\"nv\">%list.RocList</span><span class=\"p\">*</span>\n<span class=\"w\">  </span><span class=\"nv\">%load_arg</span><span class=\"w\"> </span><span class=\"p\">=</span><span class=\"w\"> </span><span class=\"k\">load</span><span class=\"w\"> </span><span class=\"nv\">%list.RocList</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">%list.RocList</span><span class=\"p\">*</span><span class=\"w\"> </span><span class=\"nv\">%bitcast_arg</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">align</span><span class=\"w\"> </span><span class=\"m\">4</span>\n<span class=\"w\">  </span><span class=\"k\">call</span><span class=\"w\"> </span><span class=\"k\">fastcc</span><span class=\"w\"> </span><span class=\"k\">void</span><span class=\"w\"> </span><span class=\"vg\">@_mainForHost_c610e85212d0697cb161d4ba431ba63f273feee7dcb7927c9ff5d74ae6cbfa3</span><span class=\"p\">(</span><span class=\"nv\">%list.RocList</span><span class=\"w\"> </span><span class=\"nv\">%load_arg</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">0</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">12</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">3</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"nv\">%list.RocList</span><span class=\"w\"> </span><span class=\"p\">}*</span><span class=\"w\"> </span><span class=\"nv\">%result_value</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"nv\">%load_roc_result</span><span class=\"w\"> </span><span class=\"p\">=</span><span class=\"w\"> </span><span class=\"k\">load</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">0</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">12</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">3</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"nv\">%list.RocList</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">0</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">12</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">3</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"nv\">%list.RocList</span><span class=\"w\"> </span><span class=\"p\">}*</span><span class=\"w\"> </span><span class=\"nv\">%result_value</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">align</span><span class=\"w\"> </span><span class=\"m\">4</span>\n<span class=\"w\">  </span><span class=\"k\">store</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">0</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">12</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">3</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"nv\">%list.RocList</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"nv\">%load_roc_result</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">0</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">12</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"m\">3</span><span class=\"w\"> </span><span class=\"k\">x</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"nv\">%list.RocList</span><span class=\"w\"> </span><span class=\"p\">}*</span><span class=\"w\"> </span><span class=\"nv nv-Anonymous\">%0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">align</span><span class=\"w\"> </span><span class=\"m\">4</span>\n<span class=\"w\">  </span><span class=\"k\">ret</span><span class=\"w\"> </span><span class=\"k\">void</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>I used [*]u8 before, but it worked with u32 and it was easier with it :)</p>",
        "id": 372296755,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688474866
    },
    {
        "content": "<p>assuming you're on a 64-bit machine, using <code>u64</code> (or <code>usize</code>, to be generic) is usually the better choice</p>",
        "id": 372297060,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688474920
    },
    {
        "content": "<p>if you just want to hack around a bit</p>",
        "id": 372297083,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688474926
    },
    {
        "content": "<p>I try to compile it with --target=wasm32. So its 32bit</p>",
        "id": 372297192,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688474952
    },
    {
        "content": "<p>ah, ok, that makes sense then</p>",
        "id": 372297243,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688474962
    },
    {
        "content": "<p>This is my current zig definition for the function:</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">RocJob</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kr\">extern</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">placeholder_I_dont_understand</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">u128</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">RocList</span><span class=\"w\"> </span><span class=\"p\">};</span>\n<span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">RocList</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kr\">extern</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">pointer</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"o\">*</span><span class=\"p\">]</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">capacity</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"w\"> </span><span class=\"p\">};</span>\n<span class=\"c1\">// TODO: u32 works, but use a pointer, so it is more clear</span>\n<span class=\"kr\">extern</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">roc__mainForHost_1_exposed</span><span class=\"p\">(</span><span class=\"n\">job</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">argument</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">RocList</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"p\">;</span>\n</code></pre></div>",
        "id": 372297630,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688475035
    },
    {
        "content": "<p>sure, ok</p>",
        "id": 372297689,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688475049
    },
    {
        "content": "<p>well, we need that integer to be a valid pointer now</p>",
        "id": 372297794,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688475068
    },
    {
        "content": "<p>because you know exactly what types and sizes you expect, no (heap) allocation is needed</p>",
        "id": 372298017,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688475115
    },
    {
        "content": "<p>also because this already uses the <code>sret</code> attribute (\"stack return\"), I wonder if this might just work</p>\n<div class=\"codehilite\"><pre><span></span><code>extern fn roc__mainForHost_1_exposed(argument: *RocList) RocJob;\n</code></pre></div>",
        "id": 372298431,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688475184
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281543\">Folkert de Vries</span> <a href=\"#narrow/stream/302903-Writing-a-platform/topic/zig.20layout.20for.20a.20roc.20struct.20that.20contains.20a.20function/near/372298431\">said</a>:</p>\n<blockquote>\n<p>also because this already uses the <code>sret</code> attribute (\"stack return\"), I wonder if this might just work</p>\n<p><div class=\"codehilite\"><pre><span></span><code>extern fn roc__mainForHost_1_exposed(argument: *RocList) RocJob;\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Yes. This works and looks nicer. But it still does not work if I add an allocation:</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"kr\">var</span><span class=\"w\"> </span><span class=\"n\">roc_result</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">roc__mainForHost_1_exposed</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">);</span>\n\n<span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">allocator</span><span class=\"p\">.</span><span class=\"n\">create</span><span class=\"p\">(</span><span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">catch</span>\n<span class=\"w\">        </span><span class=\"nb\">@panic</span><span class=\"p\">(</span><span class=\"s\">\"failed to allocate result type\"</span><span class=\"p\">);</span>\n\n<span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">@ptrToInt</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">roc_result</span><span class=\"p\">);</span>\n</code></pre></div>\n<p>Without the allocatio it works as before.</p>",
        "id": 372300227,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688475503
    },
    {
        "content": "<p>The goal is, to return something like this (both are pointers, I just use u32 for the moment to make it better understand it from the JavaScript-die):</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">ExternJob</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kr\">extern</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">callback</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"w\"> </span><span class=\"p\">};</span>\n</code></pre></div>",
        "id": 372300551,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688475575
    },
    {
        "content": "<p>describe \"does not work\" in more detail? no allocation is happening. malloc and the rust page allocator don't interfere</p>",
        "id": 372301639,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688475779
    },
    {
        "content": "<p>ah, wait</p>",
        "id": 372301725,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688475795
    },
    {
        "content": "<p>what is happening here is that you are returning a  pointer that does not live long enough</p>",
        "id": 372301775,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688475807
    },
    {
        "content": "<p>and, kind of depending on a bunch of things, that usually does not work</p>",
        "id": 372301868,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688475824
    },
    {
        "content": "<p>the <code>&amp;roc_result</code> takes a pointer to the <code>roc_result</code> value as it lives on the stack of the surrounding function. But when you return, that stack memory is free'd up. So whoever you return this pointer to gets a pointer that points to invalid memory (it has  just been cleaned up)</p>",
        "id": 372302468,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688475923
    },
    {
        "content": "<p>I don't think your surrounding function should return a pointer. would make things way simpler</p>",
        "id": 372302626,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688475952
    },
    {
        "content": "<p>That is true. But wasm only supports basic types like u32. So a pointer is all I can return</p>",
        "id": 372302884,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688475988
    },
    {
        "content": "<p>kind of. if it's an extern function. One possible approach (given that you know the types) is to provide the function with a pointer to write the result into</p>",
        "id": 372303210,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688476040
    },
    {
        "content": "<p>in other words, make finding the memory the caller's problem</p>",
        "id": 372303477,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688476094
    },
    {
        "content": "<p>Its hard to tell what is going wrong. What should happen is, that I return a pointer to the closure (I don't know if this is the correct word) that I have to use to later call <code>roc__mainForHost_0_caller</code>. So in result, I call roc with two arguments. One to <code>roc__mainForHost_1_exposed</code> and on to <code>roc__mainForHost_0_caller</code>. The two arguments should be combined with this roc function:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">main</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"nx\">arg1</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"nx\">arg2</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"arg1: \\(arg1), arg2: \\(arg2)\"</span>\n</code></pre></div>\n<p>When I said, it works, then this happend. When I said it does not work, then it was a strange behavior. For exmaple it returns a string where <code>arg1</code> was the variable I put into <code>arg2</code></p>",
        "id": 372304119,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688476215
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281543\">Folkert de Vries</span> <a href=\"#narrow/stream/302903-Writing-a-platform/topic/zig.20layout.20for.20a.20roc.20struct.20that.20contains.20a.20function/near/372303210\">said</a>:</p>\n<blockquote>\n<p>kind of. if it's an extern function. One possible approach (given that you know the types) is to provide the function with a pointer to write the result into</p>\n</blockquote>\n<p>That could work. I will try it.</p>\n<p>But it has one problem. I do not know hat the size of the closure is :) I just returned the pointer. But if I save it somewhere, I have to know the size.</p>",
        "id": 372304627,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688476315
    },
    {
        "content": "<p>oh. hmm. well really I think you should not do this manually if you expect the roc program to change</p>",
        "id": 372305061,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688476391
    },
    {
        "content": "<p>or is that the literal main function you will always use?</p>",
        "id": 372305287,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688476429
    },
    {
        "content": "<p>no. I would like to write a platform, that supports different main functions</p>",
        "id": 372305449,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688476452
    },
    {
        "content": "<p>yeah. this is why we have glue (for rust for now)</p>",
        "id": 372305570,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688476478
    },
    {
        "content": "<p>because also the function could be nested arbitrarily, right</p>",
        "id": 372305696,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688476503
    },
    {
        "content": "<p>basically, there is no reasonable way for the zig code to know what roc will give it, and what structure it will have</p>",
        "id": 372305829,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688476531
    },
    {
        "content": "<p>so unless you know the structure exactly and it does not change as you change the roc program, you'll run into trouble</p>",
        "id": 372306140,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688476590
    },
    {
        "content": "<p>and here structure means, loosely, the type of main. Loosely because when you start returning closures things get complicated</p>",
        "id": 372306267,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688476618
    },
    {
        "content": "<p>All I would need is the size. What does <code>roc__mainForHost_1_size()</code> or  <code>roc__mainForHost_0_size</code> do? They sound as if they could return the size?</p>",
        "id": 372307337,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688476855
    },
    {
        "content": "<p>yes they do. but this only works for one level. (if that is all you need, great!)</p>",
        "id": 372307579,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688476909
    },
    {
        "content": "<p>the <code>crates/cli_testing_examples/benchmarks/platform/host.zig</code> file might be helpful</p>",
        "id": 372308091,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688477012
    },
    {
        "content": "<p>in particular</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"kt\">u8</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">stderr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">.</span><span class=\"n\">io</span><span class=\"p\">.</span><span class=\"n\">getStdErr</span><span class=\"p\">().</span><span class=\"n\">writer</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// The size might be zero; if so, make it at least 8 so that we don't have a nullptr</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">.</span><span class=\"n\">math</span><span class=\"p\">.</span><span class=\"n\">max</span><span class=\"p\">(</span><span class=\"nb\">@intCast</span><span class=\"p\">(</span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">roc__mainForHost_1_exposed_size</span><span class=\"p\">()),</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">raw_output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">roc_alloc</span><span class=\"p\">(</span><span class=\"nb\">@intCast</span><span class=\"p\">(</span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"nb\">@alignOf</span><span class=\"p\">(</span><span class=\"kt\">u64</span><span class=\"p\">)).</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"kr\">var</span><span class=\"w\"> </span><span class=\"n\">output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@ptrCast</span><span class=\"p\">([</span><span class=\"o\">*</span><span class=\"p\">]</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">raw_output</span><span class=\"p\">);</span>\n\n<span class=\"w\">    </span><span class=\"k\">defer</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">roc_dealloc</span><span class=\"p\">(</span><span class=\"n\">raw_output</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">@alignOf</span><span class=\"p\">(</span><span class=\"kt\">u64</span><span class=\"p\">));</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n\n<span class=\"w\">    </span><span class=\"kr\">var</span><span class=\"w\"> </span><span class=\"n\">timer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">.</span><span class=\"n\">time</span><span class=\"p\">.</span><span class=\"n\">Timer</span><span class=\"p\">.</span><span class=\"n\">start</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">catch</span><span class=\"w\"> </span><span class=\"k\">unreachable</span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"n\">roc__mainForHost_1_exposed_generic</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"p\">);</span>\n\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">closure_data_pointer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@ptrCast</span><span class=\"p\">([</span><span class=\"o\">*</span><span class=\"p\">]</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">output</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 372308343,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688477052
    },
    {
        "content": "<p>shows how to do the allocation</p>",
        "id": 372308381,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688477058
    },
    {
        "content": "<p>in your case remove the <code>defer</code> block, because it would clean up the memory, but you want to return it</p>",
        "id": 372308558,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688477090
    },
    {
        "content": "<p>My internet connection will break in some minutes. So I say thank you for know and will tell you when I tested it</p>",
        "id": 372308678,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688477108
    },
    {
        "content": "<p>I don't see how this could work.</p>\n<p>In you example, the roc function looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">mainForHost</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">Task</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"p\">[]</span><span class=\"w\"> </span><span class=\"nx\">as</span><span class=\"w\"> </span><span class=\"nx\">Fx</span>\n</code></pre></div>\n<p>But what if it would had an argument:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">mainForHost</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">List</span><span class=\"w\"> </span><span class=\"nx\">U8</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nx\">Task</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"p\">[]</span><span class=\"w\"> </span><span class=\"nx\">as</span><span class=\"w\"> </span><span class=\"nx\">Fx</span>\n</code></pre></div>\n<p>In this case, the closure would (or at least could) contain the a variable sized argument. So the size of the closure could only be known at runtime. But as far as I can see, al the <code>*_size()</code> functions return a value, that is independent of the size of the input argument. I tested it with all of these functions:</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"kr\">extern</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">roc__mainForHost_1_exposed_size</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"kt\">i64</span><span class=\"p\">;</span>\n<span class=\"kr\">extern</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">roc__mainForHost_0_size</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"kt\">i64</span><span class=\"p\">;</span>\n<span class=\"kr\">extern</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">roc__mainForHost_0_result_size</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"kt\">i64</span><span class=\"p\">;</span>\n<span class=\"kr\">extern</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">roc__mainForHost_1_size</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"kt\">i64</span><span class=\"p\">;</span>\n<span class=\"kr\">extern</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">roc__mainForHost_1_result_size</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"kt\">i64</span><span class=\"p\">;</span>\n</code></pre></div>\n<p>I don't think that <code>roc glue</code> can help, since it does not run at runtime.</p>\n<p>When <code>roc</code> returns a list, then the returned data looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">RocList</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kr\">extern</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">pointer</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"o\">*</span><span class=\"p\">]</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">capacity</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"w\"> </span><span class=\"p\">};</span>\n</code></pre></div>\n<p>So it not only returns a pointer to the data, but also the length of the data. If it would only return the pointer, then it would not be possible to do anything with it.</p>\n<p>So I think, it should be the same for a closure. A closure should also return its size.</p>\n<p>Is this already the case? If yes: how can I access it? if not, do you also see, that is would be helpful?</p>",
        "id": 372331628,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688481272
    },
    {
        "content": "<p>yes this is why closures are a problem</p>",
        "id": 372334035,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688481702
    },
    {
        "content": "<p>in this case, we statically know (when we compile the app) exactly how big that closure is</p>",
        "id": 372334596,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688481808
    },
    {
        "content": "<p>or, how big it could get, worst case</p>",
        "id": 372334615,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688481813
    },
    {
        "content": "<p>How is that possible? I would have thought, that the closure has to contain all the data that the main function was called with. If you call main with 1GB of data, I would think, that the closure is 1GB +X.</p>",
        "id": 372340970,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688482929
    },
    {
        "content": "<p>you mean if that input list is 1gb of data?</p>",
        "id": 372342730,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688483253
    },
    {
        "content": "<p>because if so, all we store in the closure is 3 usize values: ptr, len, capacity. the actual contents of the list are elsewhere in memory and kept alive (as in, not cleaned up) because the closure contains them, but it does not count towards the data that is returned from main</p>",
        "id": 372343029,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688483303
    },
    {
        "content": "<p>Ahh this makes sense. But I still don't get it 100%. The argument list it can be saved elsewhere. But what about data, that is allocated from roc? For example the following function</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nv\">main</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">List</span><span class=\"w\"> </span><span class=\"nx\">Str</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"> </span><span class=\"nx\">U32</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nx\">List</span><span class=\"w\"> </span><span class=\"nx\">Str</span><span class=\"w\"> </span><span class=\"p\">)</span>\n<span class=\"nv\">main</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"nx\">list</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"nv\">new_list</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nx\">List</span><span class=\"p\">.</span><span class=\"nx\">map</span><span class=\"w\"> </span><span class=\"nx\">list</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"err\">\\</span><span class=\"nx\">s</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"s\">\"hello (\\s)\"</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"err\">\\</span><span class=\"nx\">i</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"w\">        </span><span class=\"nx\">List</span><span class=\"p\">.</span><span class=\"nx\">map</span><span class=\"w\"> </span><span class=\"nx\">new_list</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"err\">\\</span><span class=\"nx\">s</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nx\">Str</span><span class=\"p\">.</span><span class=\"nx\">repeat</span><span class=\"w\"> </span><span class=\"nx\">s</span><span class=\"w\"> </span><span class=\"nx\">i</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>This would return a closure that has to contain <code>new_list</code>. But since it has a variable size, it has to be stored elsewhere. So when will the actual content of <code>new_list</code> be freed? <code>roc</code> can not know, if the platform saves the closure (with the pointer to <code>new_list</code>) to call it later.</p>",
        "id": 372409791,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688501970
    },
    {
        "content": "<p>If the platform saves <code>new_list</code>, it must increment the refcount</p>",
        "id": 372415692,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1688504888
    },
    {
        "content": "<p>Otherwise, if <code>new_list</code> were passed back into roc without the refcount incremented, roc would free it.</p>",
        "id": 372415751,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1688504929
    },
    {
        "content": "<p>If <code>new_list</code> is passed to the platform with a unique refcount, the platform is responsible for freeing it assuming that the list isn't passed back into roc.</p>",
        "id": 372415815,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1688504969
    },
    {
        "content": "<p>Also, theoretically <code>new_list</code> may not even be a new allocation. It may be the same allocation as <code>list</code>. Depends on if <code>list</code> was unique to begin with and if we can update in place.</p>",
        "id": 372416005,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1688505070
    },
    {
        "content": "<p>By default, <code>new_list</code>, which is saved in the closure, would have a unique refcount. As such, roc would free it after the closure is run. (Though it still may in place update and reuse the allocation instead of freeing).</p>",
        "id": 372416207,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1688505210
    },
    {
        "content": "<p>If the closure was going to be called multiple times, the list captured by the closure would need its refcount incremented before each call to avoid being freed or reused.</p>",
        "id": 372416287,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1688505248
    },
    {
        "content": "<p>That is interesting. With this information, I am not sure, if my use case is possible.</p>\n<p>I want to call roc, receive a closure, copy the closure to the heap and return the pointer to the wasm-runtime. Later, another function calls run_closure with the pointer.</p>\n<p>If I understand you both correctly, as soon as the first function returns, the original closure will be freed. Since the allocated data has a refcound of 1, it will also be freed. To solve this, I would have to add the refcound of all data referenced by the closure by 1. I don't know how to do this.</p>\n<p>Would it be possible to tell roc somehow, that I made a copy of the closure and that it should not reduce the refcounter, when the original closure on the stack gets \"freed\"? </p>\n<p>Or do you have another idea, how a task-like feature could work with webassembly?</p>",
        "id": 372423504,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688509811
    },
    {
        "content": "<p>once the data is out of roc, freeing the memory is your responsibility. you can just not do it</p>",
        "id": 372425706,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688511262
    },
    {
        "content": "<p>so if you don't actively free heap memory,  it'll just keep existing</p>",
        "id": 372425741,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688511298
    },
    {
        "content": "<p>now, for the storing of the closure, I think by far the easiest is to have roc return a <code>Box YourActualReturnType</code></p>",
        "id": 372425786,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688511336
    },
    {
        "content": "<p>it makes roc do the allocation, so everything is the right size</p>",
        "id": 372425871,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688511372
    },
    {
        "content": "<p>but you can also do the allocation yourself on the zig side</p>",
        "id": 372425910,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688511417
    },
    {
        "content": "<p>using those size constants we talked about before</p>",
        "id": 372425934,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688511432
    },
    {
        "content": "<p>then the <code>mainforhost_exposed_generic</code> function takes a pointer as an argument and writes the return value into it. usually we'd give a stack pointer, but you can provide a heap pointer (given to you by the allocater) as well</p>",
        "id": 372426072,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688511524
    },
    {
        "content": "<p>we're working on better support for <code>Task</code> using glue. it is quite tricky to do it in general though.</p>",
        "id": 372426162,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1688511581
    },
    {
        "content": "<p>I still don't get, when the memory is deallocated. But after I copied the closure_data to a manually allocated memory, everything works. So thank you for you help.</p>\n<p>Afterwards I realized, that I misunderstood, how Task work. Now I get, that I have to define the effects in a special <code>hosted Effect</code> module. This makes it much easier. I have other questions about this, but I will ask them i a different thread :)</p>",
        "id": 373739260,
        "sender_full_name": "Oskar Hahn",
        "timestamp": 1688919639
    }
]