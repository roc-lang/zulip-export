[
    {
        "content": "<p>FYI, I discovered that we need to make binops have a type constraint where both sides are equal after all (I previously thought we could get away without doing this, but turns out not!)</p>",
        "id": 560055556,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764036981
    },
    {
        "content": "<p>example situation where the unconstrained design (where e.g. <code>a * b</code> desugars to <code>a.times(b)</code> and that's it, <code>a</code> and <code>b</code> are permitted to have totally different types) breaks down:</p>",
        "id": 560055600,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764037018
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"n\">answer</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Answer</span>\n<span class=\"n\">answer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">my_custom_number</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">MyVector</span>\n<span class=\"w\">    </span><span class=\"n\">my_custom_number</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span>\n\n<span class=\"w\">    </span><span class=\"mi\">5</span><span class=\"o\">.</span><span class=\"n\">times</span><span class=\"p\">(</span><span class=\"n\">my_custom_number</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 560055611,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764037026
    },
    {
        "content": "<p>(that's after desugaring <code>5 * my_custom_number</code> to <code>5.times(my_custom_number)</code>)</p>",
        "id": 560055641,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764037048
    },
    {
        "content": "<p>the type of that <code>5</code> literal is:</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">where</span><span class=\"w\"> </span><span class=\"o\">[</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">from_numeral</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"no\">Try</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">InvalidNumeral</span><span class=\"p\">(</span><span class=\"no\">Str</span><span class=\"p\">)),</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">times</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">MyVector</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"no\">Answer</span><span class=\"p\">,</span>\n<span class=\"o\">]</span>\n</code></pre></div>",
        "id": 560055676,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764037079
    },
    {
        "content": "<p>since nothing is forcing this to be concrete, this ends up \"defaulting to <code>Dec</code>\"</p>",
        "id": 560055708,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764037116
    },
    {
        "content": "<p>however, the way <em>that</em> works is that we unify <code>Dec</code> with this type - which fails, because <code>Dec.times : Dec, Dec -&gt; Dec</code> fails to unify with <code>a.times : a, MyVector -&gt; Answer</code> even if <code>Answer</code> turns out to be a type alias for <code>Dec</code>, because <code>Dec</code> will fail to unify with <code>MyVector</code></p>",
        "id": 560055745,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764037150
    },
    {
        "content": "<p>so we know it can't be <code>Dec</code>, but we can't leave it as unbound, so...what do we do?</p>",
        "id": 560055764,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764037166
    },
    {
        "content": "<p>one design is that we give an error, which means Roc is a language where you can't write <code>2 * x</code> or <code>1 + x</code> etc. - which would be absurd; obviously we're not going with that design</p>",
        "id": 560055802,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764037197
    },
    {
        "content": "<p>another design is where we do our best to guess what number type this should be, since it can't be <code>Dec</code> but we also can't leave it as an unbound variable because we have no how to do operations on that</p>",
        "id": 560055867,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764037258
    },
    {
        "content": "<p>so how would we guess? the only clue we have to go on in that entire type is <code>MyVector</code>, so even if we hand-wave away what the exact heuristic is, it would have to conclude that <code>MyVector</code> is the type to go with</p>",
        "id": 560055900,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764037295
    },
    {
        "content": "<p>at which point there's only one thing for it to do: unify <code>MyVector</code> with this type, which in turn means it has to unify <code>MyVector.times : MyVector, _ -&gt; _</code> with <code>a.times : a, MyVector -&gt; Answer</code> - a type where the only way it can _possibly_ successfully unify is if <code>MyVector.times</code> has both arguments being the same type</p>",
        "id": 560056142,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764037523
    },
    {
        "content": "<p>at which point the final design option, which I conclude is the correct one by process of elimination, is just a strictly clearer and more performant (in terms of compiler performance, due to not needing to have a heuristic for howto guess this) design compared to the second option, is:</p>",
        "id": 560056195,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764037574
    },
    {
        "content": "<p>we require that both sides of the binop have the same type</p>",
        "id": 560056230,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764037602
    },
    {
        "content": "<p>so it's not _just_ <code>a * b</code> is sugar for <code>a.times(b)</code>, it's that it's <code>a * b</code> is sugar for \"<code>a.times(b)</code> where <code>a</code> and <code>b</code> have the same type\"</p>",
        "id": 560056299,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764037671
    },
    {
        "content": "<p>at that point this is all trivial because they just unify</p>",
        "id": 560056410,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764037767
    },
    {
        "content": "<p>so none of these problems exist</p>",
        "id": 560056964,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764038194
    },
    {
        "content": "<p>because <code>5.times(blah)</code> just unifies to both arguments of <code>times</code> being the same, which means we just end up dispatching on whatever the type of <code>blah</code> is and we're all set</p>",
        "id": 560056999,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1764038230
    },
    {
        "content": "<p>I think one of a common patterns in scientific computing which as far as I know is a motivation to have \"operator overloading\" is to enable stuff like \"5 * x\" where x is not necessarily another number, but can be a vector or a matrix or a tensor.</p>",
        "id": 560718368,
        "sender_full_name": "Andres Villegas",
        "timestamp": 1764313906
    },
    {
        "content": "<p>Will this design limit those use cases?</p>",
        "id": 560718392,
        "sender_full_name": "Andres Villegas",
        "timestamp": 1764313920
    },
    {
        "content": "<p>I think you could implement a <code>from_numeral</code>to turn the number into the same type as the matrix. Might be a bit of effort so that both <code>5 + x</code> and <code>5 * x</code> all do the right thing, but I think it should be possible?</p>",
        "id": 560770497,
        "sender_full_name": "Fabian Schmalzried",
        "timestamp": 1764331611
    },
    {
        "content": "<p>Matrix * vector would be a bigger problem, right? Like you could define MatrixN.from_numeral(1) to be the identity matrix, but normal usage of matrices still want an assymetric operation.</p>",
        "id": 560784430,
        "sender_full_name": "Dan G Knutson",
        "timestamp": 1764335682
    },
    {
        "content": "<p>You probably would want a generic tensor type that can be a matrix or vector or etc</p>",
        "id": 560836447,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1764352835
    },
    {
        "content": "<p>Otherwise, yeah, you need <code>matrix.matmul(matrix2)</code> and <code>matrix.matmalV(vector)</code></p>",
        "id": 560836542,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1764352877
    },
    {
        "content": "<p>Or something of that nature</p>",
        "id": 560836559,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1764352884
    },
    {
        "content": "<p>You will need a solution like the above anyway in roc cause we don't have custom operators. So you can't define <code>@</code> to be the generic matmul like numpy/must python libs</p>",
        "id": 560836689,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1764352938
    }
]