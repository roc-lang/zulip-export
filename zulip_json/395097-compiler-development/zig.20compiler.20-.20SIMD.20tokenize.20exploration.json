[
    {
        "content": "<p>I'm happy to report that in my experiment making <code>chompTrivia</code> faster using SIMD (<a href=\"https://github.com/roc-lang/roc/pull/7815\">https://github.com/roc-lang/roc/pull/7815</a>)... I think I may have made it slower. </p>\n<div class=\"codehilite\"><pre><span></span><code>12:06:41 ~/Documents/GitHub/roc simd_chomp_trivia $ zig build test_chomp_perf -Dsimd=false\n=== chompTrivia Performance Test ===\nSIMD Enabled: false\nSIMD Width: 16 bytes\n\nTesting with src/BigFile.roc\nTime (µs) | Throughput (MB/s) | SIMD Chunks | File Size (bytes)\n------------------------------------------------------------\n   9.78e3 |            2.32e1 |           0 |            226943\n12:08:08 ~/Documents/GitHub/roc simd_chomp_trivia $ zig build test_chomp_perf -Dsimd-width=8\n=== chompTrivia Performance Test ===\nSIMD Enabled: true\nSIMD Width: 8 bytes\n\nTesting with src/BigFile.roc\nTime (µs) | Throughput (MB/s) | SIMD Chunks | File Size (bytes)\n------------------------------------------------------------\n   1.06e4 |            2.14e1 |         371 |            226943\n</code></pre></div>\n<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 522483346,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1749089350
    },
    {
        "content": "<p>It was a fun experiment... I definitely need to rethink my approach though if this has any chance of landing someday.</p>",
        "id": 522483802,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1749089633
    },
    {
        "content": "<p>Not sure it will help here, Simd width likely should be bigger than 8 bytes</p>",
        "id": 522485988,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1749090946
    },
    {
        "content": "<p>Probably 32?</p>",
        "id": 522486040,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1749090972
    },
    {
        "content": "<p>Anyway, likely your are hiting fallback cases to much and need some sort of better handling of index of specific characters instead of doing it byte by byte</p>",
        "id": 522486574,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1749091311
    },
    {
        "content": "<p>Thank you for the comments Brendan.  I'm a SIMD noob, so learning by doing on this one.</p>",
        "id": 522490426,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1749093907
    },
    {
        "content": "<p>I simplified the problem a little and have been noodling around with it a bit. </p>\n<p>I've managed to get some things working ok, but there are a lot of edge cases that need to be handled or really thought through. Using a fixed (compile time) width SIMD chunk makes things a little challenging. </p>\n<p>Here is an example of where I got to today. It's definitely not doing everything we want, but compiles and passes a bunch of simple test cases. I can't tell you if it's any faster than the <code>while</code> loop or anything, I'm just exploring how to write SIMD things like this with Zig and thought I'd share in case anyone is interested. </p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"c1\">// Return the indent after the first newline (if any) or null if no newline is found</span>\n<span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">chompTrivia</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[]</span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"kt\">u16</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kr\">var</span><span class=\"w\"> </span><span class=\"n\">first_newline_idx</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"kt\">u16</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">null</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@Vector</span><span class=\"p\">(</span><span class=\"n\">SIMD_WIDTH</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">ones</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@as</span><span class=\"p\">(</span><span class=\"n\">Vec</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">@splat</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">));</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">zeros</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@as</span><span class=\"p\">(</span><span class=\"n\">Vec</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">@splat</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">));</span>\n\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">chunk</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Vec</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">..</span><span class=\"n\">SIMD_WIDTH</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">..</span><span class=\"n\">SIMD_WIDTH</span><span class=\"p\">].</span><span class=\"o\">*</span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Find the index of the first newline in the chunk</span>\n<span class=\"w\">    </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// Create a vector filled with newline characters</span>\n<span class=\"w\">        </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">newline_needle</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@as</span><span class=\"p\">(</span><span class=\"n\">Vec</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">@splat</span><span class=\"p\">(</span><span class=\"se\">'\\n'</span><span class=\"p\">));</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Compare each byte with '\\n', resulting in a vector of booleans</span>\n<span class=\"w\">        </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">matches</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">chunk</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">newline_needle</span><span class=\"p\">;</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Convert the boolean vector to a bitmask (where each true becomes a bit)</span>\n<span class=\"w\">        </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">mask</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@as</span><span class=\"p\">(</span><span class=\"kt\">u16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">@bitCast</span><span class=\"p\">(</span><span class=\"nb\">@select</span><span class=\"p\">(</span><span class=\"n\">u1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">matches</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ones</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">zeros</span><span class=\"p\">)));</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// If we found any newlines, return the position of the first one</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">mask</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"n\">first_newline_idx</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@ctz</span><span class=\"p\">(</span><span class=\"n\">mask</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// If no newline found, return null</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">first_newline_idx</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"kc\">null</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"kc\">null</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Get index of position after newline</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">first_newline_idx</span><span class=\"p\">.</span><span class=\"o\">?</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"o\">&gt;=</span><span class=\"w\"> </span><span class=\"n\">SIMD_WIDTH</span><span class=\"w\"> </span><span class=\"k\">or</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"w\"> </span><span class=\"o\">&gt;=</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// No space after newline</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Create masks for spaces and tabs</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">space_matches</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">chunk</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"nb\">@as</span><span class=\"p\">(</span><span class=\"n\">Vec</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">@splat</span><span class=\"p\">(</span><span class=\"s\">' '</span><span class=\"p\">));</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">tab_matches</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">chunk</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"nb\">@as</span><span class=\"p\">(</span><span class=\"n\">Vec</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">@splat</span><span class=\"p\">(</span><span class=\"se\">'\\t'</span><span class=\"p\">));</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Find the first non-space, non-tab character after the newline</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">space_mask</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@select</span><span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">space_matches</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ones</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">zeros</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">tab_mask</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@select</span><span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">tab_matches</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ones</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">zeros</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">trivia_mask</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">space_mask</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">tab_mask</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">non_trivia</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">~</span><span class=\"n\">trivia_mask</span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Create a vector with indices to handle position-based operations</span>\n<span class=\"w\">    </span><span class=\"kr\">var</span><span class=\"w\"> </span><span class=\"n\">indices</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">SIMD_WIDTH</span><span class=\"p\">]</span><span class=\"kt\">u8</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">undefined</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">..</span><span class=\"n\">SIMD_WIDTH</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">i</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">indices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@intCast</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">index_vec</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@as</span><span class=\"p\">(</span><span class=\"n\">Vec</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">indices</span><span class=\"p\">);</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Create masks for the range after the newline</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">after_newline</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">index_vec</span><span class=\"w\"> </span><span class=\"o\">&gt;=</span><span class=\"w\"> </span><span class=\"nb\">@as</span><span class=\"p\">(</span><span class=\"n\">Vec</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">@splat</span><span class=\"p\">(</span><span class=\"nb\">@as</span><span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">@intCast</span><span class=\"p\">(</span><span class=\"n\">idx</span><span class=\"p\">))));</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">after_newline_u8</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@select</span><span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">after_newline</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ones</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">zeros</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">non_trivia_after_newline</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">non_trivia</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"n\">after_newline_u8</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">non_trivia_mask</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@as</span><span class=\"p\">(</span><span class=\"kt\">u16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">@bitCast</span><span class=\"p\">(</span><span class=\"nb\">@select</span><span class=\"p\">(</span><span class=\"n\">u1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">non_trivia_after_newline</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"n\">zeros</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ones</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">zeros</span><span class=\"p\">)));</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Calculate the ending position (first non-trivia after newline or end of chunk)</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">end_pos</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">non_trivia_mask</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"w\">        </span><span class=\"nb\">@ctz</span><span class=\"p\">(</span><span class=\"n\">non_trivia_mask</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">        </span><span class=\"n\">SIMD_WIDTH</span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Create a mask for the valid range (after newline and before the first non-trivia)</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">before_end</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">index_vec</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"nb\">@as</span><span class=\"p\">(</span><span class=\"n\">Vec</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">@splat</span><span class=\"p\">(</span><span class=\"n\">end_pos</span><span class=\"p\">));</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">valid_range</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@select</span><span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">after_newline</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ones</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">zeros</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"nb\">@select</span><span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">before_end</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ones</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">zeros</span><span class=\"p\">);</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Apply the masks to get valid spaces and tabs</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">valid_spaces</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@select</span><span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">space_matches</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ones</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">zeros</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"n\">valid_range</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">valid_tabs</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@select</span><span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">tab_matches</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ones</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">zeros</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"n\">valid_range</span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Count the number of spaces and tabs using popcount on bitmasks</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">spaces_mask</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@as</span><span class=\"p\">(</span><span class=\"kt\">u16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">@bitCast</span><span class=\"p\">(</span><span class=\"nb\">@select</span><span class=\"p\">(</span><span class=\"n\">u1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">valid_spaces</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"n\">zeros</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ones</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">zeros</span><span class=\"p\">)));</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">tabs_mask</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@as</span><span class=\"p\">(</span><span class=\"kt\">u16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">@bitCast</span><span class=\"p\">(</span><span class=\"nb\">@select</span><span class=\"p\">(</span><span class=\"n\">u1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">valid_tabs</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"n\">zeros</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ones</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">zeros</span><span class=\"p\">)));</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">spaces_count</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@popCount</span><span class=\"p\">(</span><span class=\"n\">spaces_mask</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">tabs_count</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@popCount</span><span class=\"p\">(</span><span class=\"n\">tabs_mask</span><span class=\"p\">);</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Calculate the indentation (1 for each space, 4 for each tab)</span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">spaces_count</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">tabs_count</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 522524062,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1749110119
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>const chunk: Vec = buf[0..SIMD_WIDTH][0..SIMD_WIDTH].*;\n</code></pre></div>\n<p>This line looks off</p>",
        "id": 522688943,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1749171690
    },
    {
        "content": "<p>I think this should be an <code>inline for</code>:<br>\n<code>for (0..SIMD_WIDTH) |i| {</code></p>",
        "id": 522688992,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1749171746
    },
    {
        "content": "<p>I think that line is ok. I got if from the zig docs... </p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"w\">    </span><span class=\"c1\">// To extract a comptime-known length from a runtime-known offset,</span>\n<span class=\"w\">    </span><span class=\"c1\">// first extract a new slice from the starting offset, then an array of</span>\n<span class=\"w\">    </span><span class=\"c1\">// comptime-known length</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">vec3</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nb\">@Vector</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">f32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">slice</span><span class=\"p\">[</span><span class=\"n\">offset</span><span class=\"p\">..][</span><span class=\"mi\">0</span><span class=\"p\">..</span><span class=\"mi\">2</span><span class=\"p\">].</span><span class=\"o\">*</span><span class=\"p\">;</span>\n</code></pre></div>",
        "id": 522689046,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1749171803
    },
    {
        "content": "<p>why <code>[0..SIMD_WIDTH]</code> twice?</p>",
        "id": 522689063,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1749171826
    },
    {
        "content": "<p>Also, yeah, getting simd right is hard. It is easy to use simd and get worse perf.</p>",
        "id": 522689141,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1749171898
    }
]