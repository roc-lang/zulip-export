[
    {
        "content": "<p>I noticed in my last PR some subtle memory issues with how slice fields in typed nodes returned from the NodeStore worked.  I believe there are places where if the <code>scratch</code> array that one of those structs came from resize while you still have a reference to that slice you can get some weird behavior.</p>\n<p>I <em>really</em> would like to avoid creating owned slices over data that is in <code>extra_data</code>.  My idea is to replace the slices with a new data structure called a <code>DataSpan</code> defined like this:</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">DataSpan</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">start</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"n\">len</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"p\">};</span>\n</code></pre></div>\n<p>This would be created by separately sending the slice (on typed node creation) to a method that would return a <em>typed</em> instance of this DataSpan type - which would just have information about where the nodes were stored in extra_data.</p>\n<p>When you want to get the items from the Store, you would call a method on the Store that take the <em>typed</em> DataSpan and return a <em>typed</em> Iterator that you can use:</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">ExprSpan</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">span</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DataSpan</span><span class=\"w\"> </span><span class=\"p\">};</span>\n\n<span class=\"w\">    </span><span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">IdIter</span><span class=\"p\">(</span><span class=\"kr\">comptime</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">anytype</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kt\">type</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"n\">iter</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Iterator</span><span class=\"p\">,</span>\n<span class=\"w\">            </span><span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"p\">(</span><span class=\"n\">self</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"nb\">@This</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">                </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">iter</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">n</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">                    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">.{</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"p\">};</span>\n<span class=\"w\">                </span><span class=\"p\">}</span>\n<span class=\"w\">                </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"kc\">null</span><span class=\"p\">;</span>\n<span class=\"w\">            </span><span class=\"p\">}</span>\n<span class=\"w\">        </span><span class=\"p\">};</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n\n<span class=\"w\">    </span><span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">ExprIter</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">IdIter</span><span class=\"p\">(</span><span class=\"n\">ExprIdx</span><span class=\"p\">);</span>\n\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">Iterator</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">start</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"n\">end</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"n\">pos</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"n\">data</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">std</span><span class=\"p\">.</span><span class=\"n\">ArrayList</span><span class=\"p\">(</span><span class=\"kt\">u32</span><span class=\"p\">),</span>\n\n<span class=\"w\">        </span><span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">span</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">DataSpan</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">std</span><span class=\"p\">.</span><span class=\"n\">ArrayList</span><span class=\"p\">(</span><span class=\"kt\">u32</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"nb\">@This</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">@as</span><span class=\"p\">(</span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">@intCast</span><span class=\"p\">(</span><span class=\"n\">span</span><span class=\"p\">.</span><span class=\"n\">start</span><span class=\"p\">));</span>\n<span class=\"w\">            </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">@as</span><span class=\"p\">(</span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">@intCast</span><span class=\"p\">(</span><span class=\"n\">span</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">));</span>\n<span class=\"w\">            </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">.{</span>\n<span class=\"w\">                </span><span class=\"p\">.</span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"p\">,</span>\n<span class=\"w\">                </span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">end</span><span class=\"p\">,</span>\n<span class=\"w\">                </span><span class=\"p\">.</span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"p\">,</span>\n<span class=\"w\">                </span><span class=\"p\">.</span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"p\">,</span>\n<span class=\"w\">            </span><span class=\"p\">};</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n\n<span class=\"w\">        </span><span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"p\">(</span><span class=\"n\">self</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"nb\">@This</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"kt\">u32</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"k\">or</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">items</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">&lt;=</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">pos</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">                </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"kc\">null</span><span class=\"p\">;</span>\n<span class=\"w\">            </span><span class=\"p\">}</span>\n<span class=\"w\">            </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">curr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">items</span><span class=\"p\">[</span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">pos</span><span class=\"p\">];</span>\n<span class=\"w\">            </span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"w\">            </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">curr</span><span class=\"p\">;</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">};</span>\n</code></pre></div>\n<p>The advantage is we are not allocating a bunch of short-lived slices that we have to manage their lifetimes or worry about pointers being invalidated (or memory regions being overwritten).  And working with these Spans and Iterators are relatively straightforward.</p>",
        "id": 502268216,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740658473
    },
    {
        "content": "<p>So today, instead of this when creating a <code>Expr.list</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"w\">            </span><span class=\"c1\">// ... collect the list items in scratch_exprs</span>\n<span class=\"w\">            </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">items</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">scratch_exprs</span><span class=\"p\">.</span><span class=\"n\">items</span><span class=\"p\">[</span><span class=\"n\">scratch_top</span><span class=\"p\">..];</span>\n<span class=\"w\">            </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">addExpr</span><span class=\"p\">(.{</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"n\">list</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">.{</span>\n<span class=\"w\">                </span><span class=\"p\">.</span><span class=\"n\">items</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">items</span><span class=\"p\">,</span>\n<span class=\"w\">                </span><span class=\"p\">.</span><span class=\"n\">region</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">.{</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"p\">},</span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">});</span>\n</code></pre></div>\n<p>you would have one additional step (really function call):</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"w\">            </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">items</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">addExprSpan</span><span class=\"p\">(</span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">scratch_exprs</span><span class=\"p\">.</span><span class=\"n\">items</span><span class=\"p\">[</span><span class=\"n\">scratch_top</span><span class=\"p\">..]);</span>\n<span class=\"w\">            </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">addExpr</span><span class=\"p\">(.{</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"n\">list</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">.{</span>\n<span class=\"w\">                </span><span class=\"p\">.</span><span class=\"n\">items</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">items</span><span class=\"p\">,</span>\n<span class=\"w\">                </span><span class=\"p\">.</span><span class=\"n\">region</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">.{</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"p\">},</span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">});</span>\n</code></pre></div>\n<p>The pattern above is common enough it may instead be</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"w\">            </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">items</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">addExprSpan</span><span class=\"p\">(</span><span class=\"n\">scratch_top</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// addExprSpan will make the span from scratch_top until the end of the ArrayList's items</span>\n<span class=\"w\">            </span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">addExpr</span><span class=\"p\">(.{</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"n\">list</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">.{</span>\n<span class=\"w\">                </span><span class=\"p\">.</span><span class=\"n\">items</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">items</span><span class=\"p\">,</span>\n<span class=\"w\">                </span><span class=\"p\">.</span><span class=\"n\">region</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">.{</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">pos</span><span class=\"w\"> </span><span class=\"p\">},</span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">});</span>\n</code></pre></div>",
        "id": 502270463,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740659163
    },
    {
        "content": "<p>And getting it for things like formatting (or reading to move to next IR) is very simple as well, this:</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">list</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">l</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"n\">fmt</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"s\">'['</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"kr\">var</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"w\">            </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">items</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">item</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">                </span><span class=\"n\">fmt</span><span class=\"p\">.</span><span class=\"n\">formatExpr</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">);</span>\n<span class=\"w\">                </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">items</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">                    </span><span class=\"n\">fmt</span><span class=\"p\">.</span><span class=\"n\">pushAll</span><span class=\"p\">(</span><span class=\"s\">\", \"</span><span class=\"p\">);</span>\n<span class=\"w\">                </span><span class=\"p\">}</span>\n<span class=\"w\">                </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"w\">            </span><span class=\"p\">}</span>\n<span class=\"w\">            </span><span class=\"n\">fmt</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"s\">']'</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"p\">},</span>\n</code></pre></div>\n<p>Becomes:</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">list</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">l</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"n\">fmt</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"s\">'['</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"kr\">var</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"w\">            </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">iter</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fmt</span><span class=\"p\">.</span><span class=\"n\">ast</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">getExprIter</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">items</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// Get the IdIterator</span>\n<span class=\"w\">            </span><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">iter</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">item</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"c1\">// Consume items while next() returns a value</span>\n<span class=\"w\">                </span><span class=\"n\">fmt</span><span class=\"p\">.</span><span class=\"n\">formatExpr</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">);</span>\n<span class=\"w\">                </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">items</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">                    </span><span class=\"n\">fmt</span><span class=\"p\">.</span><span class=\"n\">pushAll</span><span class=\"p\">(</span><span class=\"s\">\", \"</span><span class=\"p\">);</span>\n<span class=\"w\">                </span><span class=\"p\">}</span>\n<span class=\"w\">                </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"w\">            </span><span class=\"p\">}</span>\n<span class=\"w\">            </span><span class=\"n\">fmt</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"s\">']'</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"p\">},</span>\n</code></pre></div>\n<p><code>DataSpan</code> still has a len field, so the if condition there can remain the way it is!</p>",
        "id": 502272060,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740659613
    },
    {
        "content": "<p>The other thing that you could do is guarantee that the child nodes for a given node are all contiguous, by returning and buffering the full node struct rather than using a list of node ids. That means that each node only needs a begin and end index into the primary node store - no need for an unbounded-size “extra” data.</p>",
        "id": 502283045,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1740662715
    },
    {
        "content": "<p>Not really possible due to recursion</p>",
        "id": 502287529,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740663879
    },
    {
        "content": "<p>I'm very interested in feedback here from <span class=\"user-mention\" data-user-id=\"461444\">@Sam Mohr</span> and others working downstream from Parse IR</p>",
        "id": 502288073,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740664023
    },
    {
        "content": "<p>Hmm I don’t follow why recursion would cause problems?</p>",
        "id": 502298195,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1740666568
    },
    {
        "content": "<p>This is exactly what I’ve done for some IRs in the past</p>",
        "id": 502298337,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1740666600
    },
    {
        "content": "<p>What do you use to track the nested nodes?</p>",
        "id": 502300617,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740667141
    },
    {
        "content": "<p>Let's say you have this list expression:</p>\n<div class=\"codehilite\"><pre><span></span><code>[\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9],\n]\n</code></pre></div>\n<p>if you store the top level list's items - what would that look like?</p>",
        "id": 502301072,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740667231
    },
    {
        "content": "<p>I guess the more relevant question is, have you implemented those IRs using SOA before?</p>",
        "id": 502302185,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740667500
    },
    {
        "content": "<p>If so, maybe there is a technique you know that I'm not thinking of!</p>",
        "id": 502302254,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740667516
    },
    {
        "content": "<p>You can use a stack of scratch nodes, just like you're using now.<br>\nIn your example, the parser would:</p>\n<ul>\n<li>Start a list, track the stack location of the beginning of the list (stack location 0)</li>\n<li>Start the second list (stack location 0)</li>\n<li>Push nodes for 1, 2, and 3 to the stack</li>\n<li>Close that list, which we know started at stack loctaion 0. Pop off three items and copy them to the permanent node store. We know they're contiguous in the permanent node store, so just use a range to represent them.</li>\n<li>Push a node for that list to the stack</li>\n<li>Start a list (stack location 1), push 4, 5, 6, then close that list, copy those three items to the permanent node store</li>\n<li>etc</li>\n</ul>",
        "id": 502309016,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1740669232
    },
    {
        "content": "<p>So slices are just stored as u32 length?  And then we have to load each of them to know how far to backtrack to build up the slice of items?</p>",
        "id": 502316942,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740671109
    },
    {
        "content": "<p>So <a href=\"https://github.com/roc-lang/roc/issues/13\">#13</a> (the parent list) is requested, it has a length for items of 3. I have to load <a href=\"https://github.com/roc-lang/roc/issues/12\">#12</a> recursively to see where it ends (the index of the first descendant recursively), then do the same for the other two?</p>",
        "id": 502317855,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740671333
    },
    {
        "content": "<p>Seems like I have to load all of the nodes from the one requested to the first one added while it was added to just get the list of node idxs for its children</p>",
        "id": 502318145,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740671404
    },
    {
        "content": "<p>And will have to do that each time</p>",
        "id": 502318182,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740671415
    },
    {
        "content": "<p>Slices are a begin and end NodeIdx</p>",
        "id": 502318345,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1740671461
    },
    {
        "content": "<p>But I still have to load each child to get it</p>",
        "id": 502318437,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740671489
    },
    {
        "content": "<p>Not sure I follow? When is this is load happening?</p>",
        "id": 502318604,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1740671524
    },
    {
        "content": "<p>To get the slice info</p>",
        "id": 502318708,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740671552
    },
    {
        "content": "<p>Which is the data field on the node</p>",
        "id": 502318743,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740671561
    },
    {
        "content": "<p>Today</p>",
        "id": 502318773,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740671568
    },
    {
        "content": "<p>The begin/end are the lhs and rhs</p>",
        "id": 502318929,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1740671614
    },
    {
        "content": "<p>We should chat about this later. Hard to illustrate on my phone while in a meeting</p>",
        "id": 502318963,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740671622
    },
    {
        "content": "<p>And I want to make sure I understand your approach</p>",
        "id": 502319026,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740671640
    },
    {
        "content": "<p>Haha yeah I’m trying to type on the train and not fall over</p>",
        "id": 502319114,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1740671653
    },
    {
        "content": "<p><span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span>. Been there, used to be everyday on the Muni</p>",
        "id": 502319221,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740671681
    },
    {
        "content": "<p>Later is probs better</p>",
        "id": 502319225,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1740671682
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"781658\">Anthony Bullard</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20dealing.20with.20memory.20dynamics.20of.20temporary.20.2E.2E.2E/near/502268216\">said</a>:</p>\n<blockquote>\n<p>I noticed in my last PR some subtle memory issues with how slice fields in typed nodes returned from the NodeStore worked.  I believe there are places where if the <code>scratch</code> array that one of those structs came from resize while you still have a reference to that slice you can get some weird behavior.</p>\n<p>I <em>really</em> would like to avoid creating owned slices over data that is in <code>extra_data</code>.  My idea is to replace the slices with a new data structure called a <code>DataSpan</code> defined like this:</p>\n<p><div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">DataSpan</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">start</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"n\">len</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"p\">};</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Just to quickly note, this is a totally reasonable alternative to slices when you are working with data with unstable pointers. Fundamentally, you can't keep a slice to a growing container. When the containers grow, all pointers will become invalid.</p>\n<p>As long as we link the data span to the original container, that is fundamentally reasonable.</p>\n<p>Also, I don't think arraylists have this feature yet but zig has a feature to lock pointers and ensure stability (at least on hashmaps). It doesn't solve this issue, but it does make it easier to catch these kinds of issues.</p>\n<hr>\n<p>That said, having the slices in the first place that outlive growth might be a sign of an issue in how we are designing this.</p>\n<p>Slices never own data. They are at the whims of the owning container and must be used carefully.</p>",
        "id": 502357962,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740683219
    },
    {
        "content": "<p>I don't think the canonicalization would have any problem ingesting data with this interface, and I expect that a small proportion of the canonicalization work is actually \"talking\" to the parse AST, and most of the work is elsewhere</p>",
        "id": 502456982,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1740696998
    },
    {
        "content": "<p>So this seems fine to me</p>",
        "id": 502456994,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1740697007
    },
    {
        "content": "<p>Oh previously the list expression was storing a slice of sub expression</p>",
        "id": 502458611,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740697773
    },
    {
        "content": "<p>If we plan to serialize list expression, they would need the integer based spans anyway</p>",
        "id": 502458712,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740697810
    },
    {
        "content": "<p>That said, this is parse ast and caching just requires serializing the can ast. So not sure that is important.</p>",
        "id": 502458751,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740697835
    },
    {
        "content": "<p>What actually owns the scratch expressions? If they are stored in the other expression nodes, it seems that they need proper ownership and are not just scratch.</p>",
        "id": 502458847,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740697891
    },
    {
        "content": "<p>The scratch is just that, temporary bits of memory to go from raw u32s to typed ids and back</p>",
        "id": 502465715,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740701744
    },
    {
        "content": "<p>This change will ensure that they are always temporary - data added will never outlive the function scope</p>",
        "id": 502465844,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740701798
    },
    {
        "content": "<p>The span will just describe where the extra data for the node lives if any</p>",
        "id": 502465910,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740701837
    },
    {
        "content": "<p>And Brendan scratch is a stack so it helps us keep related extra data contiguous in the array list</p>",
        "id": 502466628,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740702209
    },
    {
        "content": "<p>And a serialzation scheme could easily consume this and I believe should be able to recreate the exact same layout deterministically</p>",
        "id": 502466823,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740702305
    },
    {
        "content": "<p>Here's my first PR towards implementing this.  It was pretty painless: <a href=\"https://github.com/roc-lang/roc/pull/7649\">https://github.com/roc-lang/roc/pull/7649</a></p>",
        "id": 502771129,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1740852091
    },
    {
        "content": "<p>I hadn’t considered just making the scratch stack a stack of ids rather than full nodes. It looks pretty clean tho!</p>",
        "id": 502795414,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1740868869
    },
    {
        "content": "<p>Doing nodes instead would trade off a bit of extra data movement during parsing for better data locality later.</p>",
        "id": 502795531,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1740868979
    },
    {
        "content": "<p>We might be able to selectively remove that data shuffling during parsing <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 502795552,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1740869005
    },
    {
        "content": "<p>Anyway, this looks like a clear improvement as is.</p>",
        "id": 502795572,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1740869026
    }
]