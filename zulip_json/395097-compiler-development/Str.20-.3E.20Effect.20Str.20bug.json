[
    {
        "content": "<p>I ran into <a href=\"https://github.com/roc-lang/roc/issues/5681\">this issue</a> at work today, and haven't figured out a workaround; can anyone think of an idea for a workaround?</p>",
        "id": 376828445,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1689818935
    },
    {
        "content": "<p>can you dump the llvm ir for both rust and the roc program? it's likely an incompatibility there</p>",
        "id": 376829217,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1689819388
    },
    {
        "content": "<p><code>roc_fx_envVar</code> on the roc side:</p>\n<div class=\"codehilite\"><pre><span></span><code>declare void @roc_fx_envVar(%str.RocStr* sret(%str.RocStr), { i8*, i64, i64 }*)\n</code></pre></div>\n<p>on the rust side:</p>\n<div class=\"codehilite\"><pre><span></span><code>; Function Attrs: uwtable\ndefine void @roc_fx_envVar(ptr sret(%&quot;roc_std::roc_str::RocStr&quot;) %0, ptr align 8 %1) unnamed_addr #1 !dbg !10953 {\nstart:\n  %_18 = alloca [1 x { ptr, ptr }], align 8\n  %_11 = alloca %&quot;core::fmt::Arguments&lt;&#39;_&gt;&quot;, align 8\n  %_3 = alloca %&quot;core::fmt::Arguments&lt;&#39;_&gt;&quot;, align 8\n  %roc_str = alloca ptr, align 8\n  store ptr %1, ptr %roc_str, align 8\n  call void @llvm.dbg.declare(metadata ptr %roc_str, metadata !10957, metadata !DIExpression()), !dbg !10958\n; call core::fmt::Arguments::new_v1\n  call void @_ZN4core3fmt9Arguments6new_v117hc9cd7c67f24d5224E(ptr sret(%&quot;core::fmt::Arguments&lt;&#39;_&gt;&quot;) %_3, ptr align 8 @all\noc1112, i64 1, ptr align 8 @alloc1114, i64 0), !dbg !10959\n; call std::io::stdio::_print\n  call void @_ZN3std2io5stdio6_print17h8769d5b8d07b47a7E(ptr %_3), !dbg !10959\n; call core::fmt::ArgumentV1::new_debug\n  %2 = call { ptr, ptr } @_ZN4core3fmt10ArgumentV19new_debug17h70af07452f17459eE(ptr align 8 %roc_str), !dbg !10960\n  %_19.0 = extractvalue { ptr, ptr } %2, 0, !dbg !10960\n  %_19.1 = extractvalue { ptr, ptr } %2, 1, !dbg !10960\n  %3 = getelementptr inbounds [1 x { ptr, ptr }], ptr %_18, i64 0, i64 0, !dbg !10960\n  %4 = getelementptr inbounds { ptr, ptr }, ptr %3, i32 0, i32 0, !dbg !10960\n  store ptr %_19.0, ptr %4, align 8, !dbg !10960\n  %5 = getelementptr inbounds { ptr, ptr }, ptr %3, i32 0, i32 1, !dbg !10960\n  store ptr %_19.1, ptr %5, align 8, !dbg !10960\n; call core::fmt::Arguments::new_v1\n  call void @_ZN4core3fmt9Arguments6new_v117hc9cd7c67f24d5224E(ptr sret(%&quot;core::fmt::Arguments&lt;&#39;_&gt;&quot;) %_11, ptr align 8 @alloc1117, i64 2, ptr align 8 %_18, i64 1), !dbg !10960\n; call std::io::stdio::_print\n  call void @_ZN3std2io5stdio6_print17h8769d5b8d07b47a7E(ptr %_11), !dbg !10960\n; call &lt;roc_std::roc_str::RocStr as core::default::Default&gt;::default\n  call void @&quot;_ZN67_$LT$roc_std..roc_str..RocStr$u20$as$u20$core..default..Default$GT$7default17h4cb6e5af3316de95E&quot;(ptr sret(%&quot;roc_std::roc_str::RocStr&quot;) %0), !dbg !10961\n  ret void, !dbg !10962\n}\n</code></pre></div>",
        "id": 377135328,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1689897258
    },
    {
        "content": "<p>so they're both void and have the same name, so the differences look like:</p>\n<p>first argument: (pointer to returned RocStr)<br>\nRust: <code>ptr sret(%\"roc_std::roc_str::RocStr\") %0</code><br>\nRoc:  <code>%str.RocStr* sret(%str.RocStr)</code></p>\n<p>second argument: (RocStr passed by reference)<br>\nRust: <code>ptr align 8 %1</code><br>\nRoc: <code>{ i8*, i64, i64 }*</code></p>\n<p>aside from the notation differences I think those are saying the same thing, so doesn't look like a type disagreement unless I'm missing something</p>",
        "id": 377135710,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1689897517
    },
    {
        "content": "<p>and it ends in what certainly appears to be calling <code>RocStr::default()</code>, writing it into the <code>sret</code> pointer (so, \"returning\" it), and then actually returning void</p>\n<div class=\"codehilite\"><pre><span></span><code>; call &lt;roc_std::roc_str::RocStr as core::default::Default&gt;::default\n  call void @&quot;_ZN67_$LT$roc_std..roc_str..RocStr$u20$as$u20$core..default..Default$GT$7default17h4cb6e5af3316de95E&quot;(ptr sret(%&quot;roc_std::roc_str::RocStr&quot;) %0), !dbg !10961\n  ret void, !dbg !10962\n</code></pre></div>",
        "id": 377136853,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1689898020
    },
    {
        "content": "<p>hm, this might be something:</p>\n<div class=\"codehilite\"><pre><span></span><code>define internal fastcc void @roc_fx_envVar_fastcc_wrapper(%str.RocStr* %arg, %str.RocStr* %arg1) {\nentry:\n  %to_cc_type_ptr = bitcast %str.RocStr* %arg to { i8*, i64, i64 }*\n  call void @roc_fx_envVar(%str.RocStr* %arg1, { i8*, i64, i64 }* %to_cc_type_ptr)\n  ret void\n}\n</code></pre></div>",
        "id": 377137256,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1689898209
    },
    {
        "content": "<p>the fastcc wrapper reverses the argument order; it takes the return pointer last rather than first</p>",
        "id": 377137364,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1689898269
    },
    {
        "content": "<p>but then again, the fastcc wrapper is only called here:</p>\n<div class=\"codehilite\"><pre><span></span><code>define internal fastcc void @Effect_effect_closure_envVar_669c1355a3e727bb53dd458f2e96e48571aa45dfabcfb4b7de1689484f11({}\n%&quot;13&quot;, %str.RocStr* %closure_arg_envVar_0, %str.RocStr* %arg) {\nentry:\n  %result_value = alloca %str.RocStr, align 8\n  call fastcc void @roc_fx_envVar_fastcc_wrapper(%str.RocStr* %closure_arg_envVar_0, %str.RocStr* nonnull %result_value)\n  call fastcc void @&quot;#Attr_#dec_1&quot;(%str.RocStr* %closure_arg_envVar_0)\n  %i = bitcast %str.RocStr* %arg to i8*\n  %i1 = bitcast %str.RocStr* %result_value to i8*\n  call void @llvm.memcpy.p0i8.p0i8.i64(i8* noundef nonnull align 8 dereferenceable(24) %i, i8* noundef nonnull align 8 der\neferenceable(24) %i1, i64 24, i1 false)\n  ret void\n}\n</code></pre></div>",
        "id": 377137680,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1689898406
    },
    {
        "content": "<p>which looks to be correctly passing the return pointer last</p>",
        "id": 377137707,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1689898420
    },
    {
        "content": "<p>(the full dumps, for reference:)</p>\n<p><a href=\"/user_uploads/22008/FHvF0Kn7ZRGTf1LZfz9lCeTu/echo.ll\">echo.ll</a><br>\n<a href=\"/user_uploads/22008/v-r12KTdXNJtDNutYJad0KeD/host.ll\">host.ll</a></p>",
        "id": 377137957,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1689898540
    },
    {
        "content": "<p>yeah our fastcc puts return-by-pointer arguments last. But C ABI wants in the first position</p>",
        "id": 377141096,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1689899704
    },
    {
        "content": "<p>what is the alignment of RocStr, <code>{ i8*, i64, i64 }*</code>?</p>",
        "id": 377141169,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1689899729
    },
    {
        "content": "<p>depends on your platform, right?</p>",
        "id": 377203078,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1689925681
    },
    {
        "content": "<p>but I'd say 8 because of the <code>i64</code></p>",
        "id": 377203199,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1689925705
    },
    {
        "content": "<p>I'd assume 8 because it's a pointer and this is a 64-bit system</p>",
        "id": 377266640,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1689939452
    },
    {
        "content": "<p>noice, after some dialogue with chatGPT, found a fix! The Rust host code was wrong; this is the corrected implementation:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[no_mangle]</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">rust_main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">roc_main_size</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">layout</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Layout</span>::<span class=\"n\">array</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// TODO allocate on the stack if it's under a certain size</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">buffer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">alloc</span>::<span class=\"n\">alloc</span><span class=\"p\">(</span><span class=\"n\">layout</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"n\">roc_main</span><span class=\"p\">(</span><span class=\"n\">buffer</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">closure_output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">call_the_closure</span><span class=\"p\">(</span><span class=\"n\">buffer</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">answer</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">RocStr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">closure_output</span><span class=\"p\">.</span><span class=\"n\">cast</span><span class=\"p\">();</span>\n\n<span class=\"w\">        </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Answer was: {:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"n\">answer</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"n\">std</span>::<span class=\"n\">alloc</span>::<span class=\"n\">dealloc</span><span class=\"p\">(</span><span class=\"n\">buffer</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">layout</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"n\">std</span>::<span class=\"n\">alloc</span>::<span class=\"n\">dealloc</span><span class=\"p\">(</span><span class=\"n\">closure_output</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">layout</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">call_the_closure</span><span class=\"p\">(</span><span class=\"n\">closure_data_ptr</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"c1\">// return type changed</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">size_Fx_result</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">layout</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Layout</span>::<span class=\"n\">array</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">buffer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">alloc</span>::<span class=\"n\">alloc</span><span class=\"p\">(</span><span class=\"n\">layout</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"n\">call_Fx</span><span class=\"p\">(</span>\n<span class=\"w\">        </span><span class=\"c1\">// This flags pointer will never get dereferenced</span>\n<span class=\"w\">        </span><span class=\"n\">MaybeUninit</span>::<span class=\"n\">uninit</span><span class=\"p\">().</span><span class=\"n\">as_ptr</span><span class=\"p\">(),</span>\n<span class=\"w\">        </span><span class=\"n\">closure_data_ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"n\">buffer</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"p\">);</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Don't deallocate the buffer here</span>\n<span class=\"w\">    </span><span class=\"c1\">// std::alloc::dealloc(buffer, layout);</span>\n\n<span class=\"w\">    </span><span class=\"n\">buffer</span><span class=\"w\"> </span><span class=\"c1\">// return the buffer</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 377659271,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1690049777
    },
    {
        "content": "<p>so I need to update glue accordingly</p>",
        "id": 377659296,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1690049798
    },
    {
        "content": "<p>for my own future reference, the glue we want to generate:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">rust_main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">answer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">mainForHost</span><span class=\"p\">().</span><span class=\"n\">force_thunk</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Answer was: {:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">answer</span><span class=\"w\"> </span><span class=\"p\">});</span>\n<span class=\"p\">}</span>\n\n<span class=\"cp\">#[repr(C)]</span>\n<span class=\"cp\">#[derive(Debug, Clone)]</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">RocFunction_71</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">closure_data</span>: <span class=\"nc\">roc_std</span>::<span class=\"n\">RocList</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">RocFunction_71</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">force_thunk</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">roc_std</span>::<span class=\"n\">RocStr</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"k\">fn</span> <span class=\"nf\">roc__mainForHost_0_caller</span><span class=\"p\">(</span>\n<span class=\"w\">                </span><span class=\"n\">arg0</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">(),</span>\n<span class=\"w\">                </span><span class=\"n\">closure_data</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span>\n<span class=\"w\">                </span><span class=\"n\">output</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">roc_std</span>::<span class=\"n\">RocStr</span><span class=\"p\">,</span>\n<span class=\"w\">            </span><span class=\"p\">);</span>\n\n<span class=\"w\">            </span><span class=\"k\">fn</span> <span class=\"nf\">roc__mainForHost_0_result_size</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i64</span><span class=\"p\">;</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span>::<span class=\"n\">uninit</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">closure_ptr</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">            </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">core</span>::<span class=\"n\">mem</span>::<span class=\"n\">ManuallyDrop</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">closure_data</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span>\n\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"n\">roc__mainForHost_0_caller</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">closure_ptr</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">output</span><span class=\"p\">.</span><span class=\"n\">as_mut_ptr</span><span class=\"p\">());</span>\n\n<span class=\"w\">            </span><span class=\"n\">output</span><span class=\"p\">.</span><span class=\"n\">assume_init</span><span class=\"p\">()</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">mainForHost</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">RocFunction_71</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">roc__mainForHost_1_exposed_generic</span><span class=\"p\">(</span><span class=\"n\">_</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">RocFunction_71</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">ret</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">core</span>::<span class=\"n\">mem</span>::<span class=\"n\">MaybeUninit</span>::<span class=\"n\">uninit</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">roc__mainForHost_1_exposed_generic</span><span class=\"p\">(</span><span class=\"n\">ret</span><span class=\"p\">.</span><span class=\"n\">as_mut_ptr</span><span class=\"p\">());</span>\n\n<span class=\"w\">        </span><span class=\"n\">ret</span><span class=\"p\">.</span><span class=\"n\">assume_init</span><span class=\"p\">()</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 377701103,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1690071052
    }
]