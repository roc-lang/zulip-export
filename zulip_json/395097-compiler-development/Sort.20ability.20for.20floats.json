[
    {
        "content": "<p>After speaking with <span class=\"user-mention\" data-user-id=\"477725\">@Jasper Woudenberg</span> , I decided to try and implement the Sort ability for floats. But quickly after starting, I realized there isn't a clear good way to do this. I made a list of strategies below, but was hoping to get some guidance from someone with expertise in the subject.</p>\n<p>Strategies I am aware of:</p>\n<ul>\n<li><a href=\"https://hackage.haskell.org/package/ghc-prim-0.11.0/docs/src/GHC.Classes.html#compare\">Haskell's</a>, implement compare in terms of <code>&lt;</code> and <code>==</code>, which always return false if either operand is a NaN. This resulted in compare always returning GT when there is a NaN involved. I am strongly apposed to this approach because, as the Haskell source code notes, this violates reflexivity which can result in data corruption.</li>\n<li><a href=\"https://hg.openjdk.org/jdk/jdk13/file/1ddf9a99e4ad/src/java.base/share/classes/java/lang/Float.java\">Java's</a>, if one or both operands are a NaN, do a raw bit comparison. If I understand correct, this will put all positive NaNs after positive infinity and all negative NaNs between positive and negative zero. I do not favor this approach because it puts the NaNs in two very different spots based on properties the vast majority of users will not care about. </li>\n<li><a href=\"https://github.com/dotnet/runtime/blob/5535e31a712343a63f5d7d796cd874e563e5ac14/src/libraries/System.Private.CoreLib/src/System/Double.cs#L260C13-L268C26\">C#'s</a>, consider NaNs to be the smallest values. This strikes me as an acceptable approach.</li>\n<li><a href=\"https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html\">Rust's</a>, define a partial order type which float is a member. We could define <code>PartialSort implements partialCompare: a, a -&gt; Result [LessThan, Equivalent, GreaterThan] [Unorderable]</code>. I like this approach because, a) it is honest about the fact that not all floats are comparable, and b), a PartialSort ability is likely useful for other types. I do not like that it will likely make working with floats more awkward.</li>\n<li><a href=\"https://iremi.univ-reunion.fr/IMG/pdf/ieee-754-2008.pdf\">IEEE-754-2008's totalOrder function</a>, this total ordering considers -NaN to be the smallest number and +Nan to be the greatest number. I do not favor this approach because it splits the NaNs based on a property most users do not care about. </li>\n</ul>\n<p>My instinct would be to go with the C# strategy and just make NaNs the smallest, though Rust's partial order approach strikes me as more in line with the Roc ethos.</p>\n<p>Let me know what y'all think.</p>",
        "id": 442318875,
        "sender_full_name": "Ben Plotke",
        "timestamp": 1717434783
    },
    {
        "content": "<p>great question! We talked about this before: </p>\n<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/stream/304641-ideas/topic/supporting.20NaN.2FInfinity.2F-Infinity.3F/near/275915943\">said</a>:</p>\n<blockquote>\n<p>so if we have a default <code>List.sort</code> for be floats, and a default <code>compare</code> for floats, and they both sort NaNs to the edge...what would be the situation where someone writes their own sorting algorithm using <code>&lt;</code> instead of <code>compare</code>?</p>\n</blockquote>\n<p>I think what we want here is:</p>\n<ul>\n<li>all <code>NaN</code>s end up sorted to either the beginning or end</li>\n<li>whatever comparison has the best performance, given that one constraint</li>\n</ul>",
        "id": 442327946,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1717436844
    },
    {
        "content": "<p>so I think C#'s approach makes sense, although it would also be fine to consider <code>NaN</code> to be the largest value (instead of the smallest) if it turns out that's better for performance than treating it as the smallest</p>",
        "id": 442328357,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1717436939
    },
    {
        "content": "<p>I assume it's probably the same perf either way</p>",
        "id": 442328546,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1717436983
    },
    {
        "content": "<p>Thanks! That completely clarifies</p>",
        "id": 442521080,
        "sender_full_name": "Ben Plotke",
        "timestamp": 1717505046
    },
    {
        "content": "<p>I have another implementation question. Which of the two below options would be preferable from a performance perspective? I know a few more instructions can be preferable to branching, but I do not have a feel for how many instructions. <br>\na) A function with if-elses. This has a lot of branches, but the top two cases are the common ones. (I am guessing this does not actually need to be a function, but I am completely new to LLVM and compilers, so I would need some pointers on how to do that.)</p>\n<div class=\"codehilite\"><pre><span></span><code>float_sort(a, b)\n    if a &lt; b\n        return 2\n    if a &gt; b\n        return 1\n    if a == b\n        return 0\n    if b == b  // a is NaN, so smaller\n        return 2\n    if a == a\n        return 1\n    return 0\n</code></pre></div>\n<p>b) This expression <code>(a == a) + 2*(b == b) - (a &lt; b) - 2*(a &gt; b) - 3*(a == b)</code>. This has no branches, but it is a lot of instructions. (It would also warrant a comment with a table demonstrating the logic)</p>",
        "id": 443207661,
        "sender_full_name": "Ben Plotke",
        "timestamp": 1717734562
    },
    {
        "content": "<p>Almost certainly branchless will be better for average performance. That said, the top implement <em>may</em> turn into cmovs anyway, though probably not due to returns. But if you assign that if back to a variable, probably would cmov and be quite good...though not fully sure.</p>",
        "id": 443207848,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1717734690
    },
    {
        "content": "<p>Other way, I would bet on the expression being the better option</p>",
        "id": 443207863,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1717734704
    }
]