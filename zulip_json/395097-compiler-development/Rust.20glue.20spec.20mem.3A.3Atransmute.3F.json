[
    {
        "content": "<p>I've been looking at the current Rust glue spec's output for tag unions. The generated .get_discriminant() function uses mem::transmute to get at the tag union's raw bytes, then uses pointer arithmatic to pull the discriminant out:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">discriminant</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">discriminant_U1</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">       </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">           </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bytes</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">core</span><span class=\"p\">::</span><span class=\"n\">mem</span><span class=\"p\">::</span><span class=\"n\">transmute</span><span class=\"p\">::</span><span class=\"o\">&lt;&amp;</span><span class=\"bp\">Self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">core</span><span class=\"p\">::</span><span class=\"n\">mem</span><span class=\"p\">::</span><span class=\"n\">size_of</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">()]</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">);</span>\n\n\n<span class=\"w\">           </span><span class=\"n\">core</span><span class=\"p\">::</span><span class=\"n\">mem</span><span class=\"p\">::</span><span class=\"n\">transmute</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">discriminant_U1</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">bytes</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">().</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"mi\">24</span><span class=\"p\">))</span>\n<span class=\"w\">       </span><span class=\"p\">}</span>\n<span class=\"w\">   </span><span class=\"p\">}</span>\n</code></pre></div>\n<p>(same goes for set_discriminant()`)</p>\n<p>I'm wondering why the decision was made to do this instead of accessing the discriminant field directly?</p>",
        "id": 472232140,
        "sender_full_name": "Sven van Caem",
        "timestamp": 1727097903
    },
    {
        "content": "<p>Notable here too is that the <code>.is_&lt;variant&gt;()</code> functions do access the field directly:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">   </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">is_VariantA</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">bool</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">       </span><span class=\"fm\">matches!</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">discriminant</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">discriminant_U1</span><span class=\"p\">::</span><span class=\"n\">VariantA</span><span class=\"p\">)</span>\n<span class=\"w\">   </span><span class=\"p\">}</span>\n<span class=\"w\">   </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">is_VariantB</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">bool</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">       </span><span class=\"fm\">matches!</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">discriminant</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">discriminant_U1</span><span class=\"p\">::</span><span class=\"n\">VariantB</span><span class=\"p\">)</span>\n<span class=\"w\">   </span><span class=\"p\">}</span>\n<span class=\"w\">   </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">is_VariantC</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">bool</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">       </span><span class=\"fm\">matches!</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">discriminant</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">discriminant_U1</span><span class=\"p\">::</span><span class=\"n\">VariantC</span><span class=\"p\">)</span>\n<span class=\"w\">   </span><span class=\"p\">}</span>\n</code></pre></div>",
        "id": 472236201,
        "sender_full_name": "Sven van Caem",
        "timestamp": 1727098865
    },
    {
        "content": "<p>not sure, maybe because then the same skeleton can sort of be reused? anyway, the field access method is better of course</p>",
        "id": 472276380,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1727108502
    }
]