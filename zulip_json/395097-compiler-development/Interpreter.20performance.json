[
    {
        "content": "<p>The interpreter is still quite slow. Is it worth it to optimize it, or will it be replaced by a dev backend soon anyway?</p>\n<p>One concrete slowdown I see is that the compiler get's significantly slower with loops over 2000. </p>\n<div class=\"codehilite\"><pre><span></span><code>app [main!] { pf: platform &quot;https://github.com/lukewilliamboswell/roc-platform-template-zig/releases/download/0.6/2BfGn4M9uWJNhDVeMghGeXNVDFijMfPsmmVeo6M4QjKX.tar.zst&quot; }\n\nmain! = |_| {\n    _foo = 0.to(&lt;n&gt;)\n    Ok({})\n}\n</code></pre></div>\n<p>depending on n, I have the following time output (Windows x86 machine):</p>\n<table>\n<thead>\n<tr>\n<th>n</th>\n<th>time (s)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>500</td>\n<td>0.283</td>\n</tr>\n<tr>\n<td>1000</td>\n<td>0.323</td>\n</tr>\n<tr>\n<td>2000</td>\n<td>0.47</td>\n</tr>\n<tr>\n<td>3000</td>\n<td>1.282</td>\n</tr>\n<tr>\n<td>4000</td>\n<td>2.331</td>\n</tr>\n<tr>\n<td>8000</td>\n<td>9.773</td>\n</tr>\n</tbody>\n</table>\n<p>I did not investigate. Is it worth doing so? And performance of the interpreter in general?</p>",
        "id": 566759993,
        "sender_full_name": "Fabian Schmalzried",
        "timestamp": 1767799804
    },
    {
        "content": "<p>I think we want to keep the interpreter for constant folding. I would also like to keep it to keep our options open. It could be difficult to resurrect compared to just keeping it running. Definitely for this simple case where perf is bad, optimization seems worth it.</p>",
        "id": 566763881,
        "sender_full_name": "Anton",
        "timestamp": 1767800866
    },
    {
        "content": "<p>I recommend checking out <a href=\"https://github.com/roc-lang/roc/blob/main/src/PROFILING/README.md\">https://github.com/roc-lang/roc/blob/main/src/PROFILING/README.md</a></p>",
        "id": 566764475,
        "sender_full_name": "Anton",
        "timestamp": 1767801036
    },
    {
        "content": "<p>My understanding was that the interpreter would eventually become fast enough to become the de-facto dev workflow. Other languages have shown that interpreters can be fast enough for development workflows.  Also, another advantage is that it is much more amenable to a debugger. </p>\n<p>I recall the main benefit of dev backends was to shorten the startup time albeit zero optimization. I believe the interpreter should startup even faster and can eventually be JITTED for optimization on hot paths.</p>\n<p>So what why are the dev backends being resurrected ? I am not sure... I suppose there is a Claude translation just in case so that they are not lost when the rust backend gets yanked.</p>\n<p>(i am just an outsider, so take my words with a huge grain of salt)</p>",
        "id": 566783206,
        "sender_full_name": "Romain Lepert",
        "timestamp": 1767806110
    },
    {
        "content": "<p>Related conversation: <a class=\"message-link\" href=\"/#narrow/channel/358903-advent-of-code/topic/2025.20Day.203/near/563700834\">#advent of code &gt; 2025 Day 3 @ üí¨</a></p>",
        "id": 566790187,
        "sender_full_name": "Anton",
        "timestamp": 1767808319
    },
    {
        "content": "<p>I dont think there is any short or medium term plans to not have an interpreter. </p>\n<p>Longer term the benefits of reviving the dev backends is that we can simplify a lot of things at runtime I think.</p>\n<p>Before we started the rewrite the hypothesis was that an interpreter would be relatively easy to build... in practice we have learnt that there is a lot of type wrangling that has to happen at runtime - to support polymorphism. So instead of using the same Mono build pipeline at compile time we have just as much work to do at runtime.</p>\n<p>In a compiled world with dev backends and if the interpeter didnt exist, we could eliminate all of this additional complexity and just have a single pipeline.</p>",
        "id": 566822603,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1767819721
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"559412\">Fabian Schmalzried</span> <a href=\"#narrow/channel/395097-compiler-development/topic/Interpreter.20performance/near/566759993\">said</a>:</p>\n<blockquote>\n<p>The interpreter is still quite slow. Is it worth it to optimize it, or will it be replaced by a dev backend soon anyway?</p>\n<p>One concrete slowdown I see is that the compiler get's significantly slower with loops over 2000. </p>\n<div class=\"codehilite\"><pre><span></span><code>app [main!] { pf: platform &quot;https://github.com/lukewilliamboswell/roc-platform-template-zig/releases/download/0.6/2BfGn4M9uWJNhDVeMghGeXNVDFijMfPsmmVeo6M4QjKX.tar.zst&quot; }\n\nmain! = |_| {\n    _foo = 0.to(&lt;n&gt;)\n    Ok({})\n}\n</code></pre></div>\n<p>depending on n, I have the following time output (Windows x86 machine):</p>\n<table>\n<thead>\n<tr>\n<th>n</th>\n<th>time (s)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>500</td>\n<td>0.283</td>\n</tr>\n<tr>\n<td>1000</td>\n<td>0.323</td>\n</tr>\n<tr>\n<td>2000</td>\n<td>0.47</td>\n</tr>\n<tr>\n<td>3000</td>\n<td>1.282</td>\n</tr>\n<tr>\n<td>4000</td>\n<td>2.331</td>\n</tr>\n<tr>\n<td>8000</td>\n<td>9.773</td>\n</tr>\n</tbody>\n</table>\n<p>I did not investigate. Is it worth doing so? And performance of the interpreter in general?</p>\n</blockquote>\n<p>I definitely think it's worth investigating any performance issues. It shouldn't be really bad or anything. This could just be some obvious bug in our implementation. </p>\n<p>We had something similar recently where Brendan sped us up like 6000x with a single line change or something like that.</p>",
        "id": 566872486,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1767852618
    },
    {
        "content": "<p>The focus so far has been on correctness, so there is a lot of low hanging fruit in the performance department.</p>",
        "id": 566872571,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1767852689
    },
    {
        "content": "<p>Alright, thanks for all the input. I will try to see what I can do to improve the performance.</p>",
        "id": 566893294,
        "sender_full_name": "Fabian Schmalzried",
        "timestamp": 1767862691
    },
    {
        "content": "<p>So one culprit for the slowdown is <code>types.snapshot()</code> in <code>unifyWithConf(..)</code>, which is used for restoring, when unification fails: <a href=\"https://github.com/roc-lang/roc/blob/eb54be9749da1966bcf0ce01a87b3f96a3919e87/src/check/unify.zig#L183\">https://github.com/roc-lang/roc/blob/eb54be9749da1966bcf0ce01a87b3f96a3919e87/src/check/unify.zig#L183</a></p>\n<p>Removing this turns the ~9.7s to ~1.2s. </p>\n<p>Of cause just removing this does break something, at least the tests are now broken.<br>\nAnyone has some insights on how to handle this? I see those options:</p>\n<ol>\n<li>Maybe rollback is not necessary at all? Unification failed, so why bother rolling back? (No idea on the actual implications on this, probably something to do with \"inform don't block\"?)</li>\n<li>Add some more efficient rollback mechanism (maybe more like database transactions)</li>\n<li>Figure out why this simple code is unifying so much and reduce that (probably worth it anyway)</li>\n</ol>",
        "id": 566933550,
        "sender_full_name": "Fabian Schmalzried",
        "timestamp": 1767876304
    },
    {
        "content": "<p>Helpful commit message here: <a href=\"https://github.com/roc-lang/roc/commit/8b97a2d03e1c485507d599a18262f75c11f074d8\">https://github.com/roc-lang/roc/commit/8b97a2d03e1c485507d599a18262f75c11f074d8</a></p>",
        "id": 566936861,
        "sender_full_name": "Anton",
        "timestamp": 1767877477
    },
    {
        "content": "<p>What do you think <span class=\"user-mention\" data-user-id=\"281383\">@Richard Feldman</span>?</p>",
        "id": 566936880,
        "sender_full_name": "Anton",
        "timestamp": 1767877485
    },
    {
        "content": "<p>I'm leaning towards \"1. Figure out why this simple code is unifying so much and reduce that (probably worth it anyway)\"</p>",
        "id": 566936928,
        "sender_full_name": "Anton",
        "timestamp": 1767877501
    },
    {
        "content": "<p>agree, in this code sample the value of n should not increase the number of times the type checker unifies.</p>\n<p>also note, there are compile time types (in Check) and runtime types (in the interpreter), so it‚Äôs also worth figuring out which part of the codebase the unifies are coming from</p>",
        "id": 566944521,
        "sender_full_name": "Jared Ramirez",
        "timestamp": 1767879755
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"361169\">Anton</span> <a href=\"#narrow/channel/395097-compiler-development/topic/Interpreter.20performance/near/566936861\">said</a>:</p>\n<blockquote>\n<p>Helpful commit message here: <a href=\"https://github.com/roc-lang/roc/commit/8b97a2d03e1c485507d599a18262f75c11f074d8\">https://github.com/roc-lang/roc/commit/8b97a2d03e1c485507d599a18262f75c11f074d8</a></p>\n</blockquote>\n<p>reading through that commit message, the optimistic snapshot seem wasteful if the unification does not error.</p>\n<p>i wonder if there‚Äôs some other way to solve this, like i wonder if we change unification order so we could avoid the ‚Äúinner unify success pollutes outer error message‚Äù thing</p>",
        "id": 566945992,
        "sender_full_name": "Jared Ramirez",
        "timestamp": 1767880178
    },
    {
        "content": "<p>I think this strategy goes all the way back to elm's type checker...the only idea I have for how to improve it is basically a \"double or nothing\" - we optimistically assume there will be no type mismatches in the entire module, and then if we're wrong, we start over and redo type checking for the entire module with snapshotting</p>",
        "id": 566949989,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1767881224
    },
    {
        "content": "<p>the problem is just that unification has to use in-place mutation for performance, and it just unavoidably loses information</p>",
        "id": 566950268,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1767881293
    },
    {
        "content": "<p>i‚Äôll need to double check, but i think in elm, because it uses continuation style passing, type descriptors are not updated until after all recursive unification has succeeded (or not). maybe we could capture ‚Äúpending‚Äù merges during unification, then only actually upadate the types store after we know if it was a success or failure</p>\n<p>but, that aside, it would surprise me if the value of an argument caused the type checking phase to call unify many more times, so i suspect its a unify call in the interpreter</p>",
        "id": 566963295,
        "sender_full_name": "Jared Ramirez",
        "timestamp": 1767884434
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"341568\">Jared Ramirez</span> <a href=\"#narrow/channel/395097-compiler-development/topic/Interpreter.20performance/near/566963295\">said</a>:</p>\n<blockquote>\n<p>but, that aside, it would surprise me if the value of an argument caused the type checking phase to call unify many more times, so i suspect its a unify call in the interpreter</p>\n</blockquote>\n<p>Yes, here: <a href=\"https://github.com/roc-lang/roc/blob/eb54be9749da1966bcf0ce01a87b3f96a3919e87/src/eval/interpreter.zig#L17716\">https://github.com/roc-lang/roc/blob/eb54be9749da1966bcf0ce01a87b3f96a3919e87/src/eval/interpreter.zig#L17716</a><br>\nI think this runs for every <code>.append</code> in the <code>range_to</code> builtin.<br>\nAny idea how to best improve this? <br>\nI also don't quite understand why a copy of the arg is necessary at this point.</p>",
        "id": 566968605,
        "sender_full_name": "Fabian Schmalzried",
        "timestamp": 1767885684
    },
    {
        "content": "<p>Can the unification in the interpreter fail? Type checking should prevent this, right? So we can just have a unification function just for the interpreter that does not create this snapshot?</p>",
        "id": 566976988,
        "sender_full_name": "Fabian Schmalzried",
        "timestamp": 1767887874
    },
    {
        "content": "<p>Would the unification in the interpreter still be required, when we have the <a href=\"#narrow/channel/316715-contributing/topic/Worklog.20.28Draft.20PRs.20and.20coordination.29/near/564799190\">\"monomorphized roc code\"</a></p>",
        "id": 566977928,
        "sender_full_name": "Fabian Schmalzried",
        "timestamp": 1767888112
    },
    {
        "content": "<p>Don't we full type check before the interpreter? Can we removing all type checking from the interpreter and just assert types?</p>",
        "id": 567003740,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1767895777
    },
    {
        "content": "<p>I don't think we need mono. Anything with static dispatch just needs a virtual table. They literally could store an index to their module and anything with dispatch would just grab that module and run, no type checking</p>",
        "id": 567003941,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1767895850
    },
    {
        "content": "<p>I obviously don't know the pipeline. But something of this nature should be doable and huge for perf.</p>",
        "id": 567004025,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1767895881
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"559412\">Fabian Schmalzried</span> <a href=\"#narrow/channel/395097-compiler-development/topic/Interpreter.20performance/near/566976988\">said</a>:</p>\n<blockquote>\n<p>Can the unification in the interpreter fail? Type checking should prevent this, right? So we can just have a unification function just for the interpreter that does not create this snapshot?</p>\n</blockquote>\n<p>that's true, it should never fail in the interpreter!</p>",
        "id": 567074023,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1767935268
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/channel/395097-compiler-development/topic/Interpreter.20performance/near/567003941\">said</a>:</p>\n<blockquote>\n<p>I don't think we need mono. Anything with static dispatch just needs a virtual table. They literally could store an index to their module and anything with dispatch would just grab that module and run, no type checking</p>\n</blockquote>\n<p>If I remember right, I think the reason we have to unify in the interpreter is because of layout:</p>\n<ul>\n<li>the host abi expects the same layout from data it receives from the interpreter as data it receives from optimized llvm builds</li>\n<li>computing that layout requires monomorphic types</li>\n<li>the process of making polymorphic types monomorphic is by going through and unifying the polymorphic types with monomorphic ones, and that's true whether it's happening at compile time or at runtime</li>\n</ul>",
        "id": 567074278,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1767935543
    },
    {
        "content": "<p><a href=\"https://github.com/roc-lang/roc/issues/8967\">#8967</a> for the example above it's now &gt;10x faster</p>",
        "id": 567131242,
        "sender_full_name": "Fabian Schmalzried",
        "timestamp": 1767961732
    },
    {
        "content": "<p>Found something else that I don't know how to fix: <br>\nthe refcount of the list <code>$answer</code> list in <code>range_to</code> is 2 for all the appends, therefore the list is not mutated inplace. I think it should be just 1? Anyone has any hints on where to look for this unnecessary refcount?</p>",
        "id": 567158532,
        "sender_full_name": "Fabian Schmalzried",
        "timestamp": 1767970217
    },
    {
        "content": "<p>Ah. Layouts require it. That makes sense. Maybe the interpreter really does need to be after mono then. Not sure.</p>",
        "id": 567165633,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1767972108
    },
    {
        "content": "<p>For range_to sounds like we get confused by the mutable variable</p>",
        "id": 567167372,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1767972554
    },
    {
        "content": "<p>Cause it is referenced after the loop as well. So that is technically an extra refcount</p>",
        "id": 567167469,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1767972580
    },
    {
        "content": "<p>But that is only true for non-mutable variables. This mutable variable is actually changing in the loop</p>",
        "id": 567167578,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1767972615
    },
    {
        "content": "<p>So sounds like we need special recount exceptions for mutable variables.</p>",
        "id": 567167694,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1767972650
    }
]