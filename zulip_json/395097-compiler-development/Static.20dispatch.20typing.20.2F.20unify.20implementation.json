[
    {
        "content": "<p>What's the strategy for implementing static dispatch in unify? How would this example be handled?</p>\n<div class=\"codehilite\"><pre><span></span><code>|x, y| {\n  joined = x.map2(y, Pair)\n  res = joined.walk([], |acc, el| acc)\n  if false { res } else { res.push(0) }\n}\n</code></pre></div>\n<p>It seems that would need to be something like:</p>\n<div class=\"codehilite\"><pre><span></span><code>a, b -&gt; c\n  where a.map2(b, d): e,\n   e.walk(...): c,\n   c.push(...): c\n</code></pre></div>\n<p>(not sure I have the syntax exactly right there?)</p>\n<p>Prior to static dispatch that method would have resolved as a much more pronounceable <code>List(a), List(b) -&gt; List(c)</code></p>\n<p>Tracking all that in type inference sounds like a headache <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 535712100,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1755878100
    },
    {
        "content": "<p>Tracking it seems manageable but it does not look nice in the LSP type hover...</p>",
        "id": 535714429,
        "sender_full_name": "Anton",
        "timestamp": 1755878839
    },
    {
        "content": "<p>Err, I guess more specifically - is the intent to implement this via separate constraints? or constrained types? or some kind of row polymorphism types?</p>",
        "id": 535714990,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1755879046
    },
    {
        "content": "<p>I believe we have not discussed this before <span class=\"user-mention\" data-user-id=\"281383\">@Richard Feldman</span></p>",
        "id": 535723518,
        "sender_full_name": "Anton",
        "timestamp": 1755882264
    },
    {
        "content": "<p>I ask because I've been tinkering with a type inference system where I tried to do this via row polymorphism... and this is one example where that strategy runs into issues. I think doing it properly that way would require tracking where types are _used_ (i.e. back-links), so that effectively the constraints can be reversed back out of the types. Furthermore, when checking if this function can be applied in a given scenario, we need to follow that whole type graph, making unification much more complicated. So.. probably one of the first two approaches would be best. That, or significant restrictions need to be placed on how much inference we do in this case.</p>",
        "id": 535730982,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1755885618
    },
    {
        "content": "<p>Which is to say, I think some form of global constraint tracking is necessary here</p>",
        "id": 535733778,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1755886813
    },
    {
        "content": "<p>I have a very vague memory of someone here discussing row-polymorphism for implementing static dispatch, but I can't find it, and I could very well be imagining it.</p>",
        "id": 535733918,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1755886884
    },
    {
        "content": "<p>nah it's basically the same as open records or anonymous tag unions</p>",
        "id": 535745433,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755891648
    },
    {
        "content": "<p>I can write it out in more detail tonight</p>",
        "id": 535745448,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755891654
    },
    {
        "content": "<p>Very interested in how it handles that example!</p>",
        "id": 535745668,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1755891744
    },
    {
        "content": "<p>yeah so in that example, it would indeed be something similar - so if you put this into the repl:</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"n\">joined</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">map2</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">Pair</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">joined</span><span class=\"o\">.</span><span class=\"n\">walk</span><span class=\"p\">(</span><span class=\"o\">[]</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">acc</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">el</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kp\">false</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"o\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 535777360,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755917613
    },
    {
        "content": "<p>I believe the inferred type would be:</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">res</span>\n<span class=\"w\">    </span><span class=\"n\">where</span><span class=\"w\"> </span><span class=\"o\">[</span>\n<span class=\"w\">        </span><span class=\"n\">module</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">map2</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"no\">Pair</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..]</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">joined</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"n\">module</span><span class=\"p\">(</span><span class=\"n\">joined</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">walk</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">List</span><span class=\"p\">(</span><span class=\"n\">elem_</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">acc</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">el_</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">acc</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"n\">module</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"n\">module</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">from_digits</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Iter</span><span class=\"p\">(</span><span class=\"no\">U8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"no\">Result</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">BadNumLiteral</span><span class=\"p\">(</span><span class=\"no\">Str</span><span class=\"p\">)),</span>\n<span class=\"w\">    </span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 535777483,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755917872
    },
    {
        "content": "<p>of course, in practice people will normally annotate top-level functions, at which point the type checker would just verify that the body of the function matches the annotation like normal</p>",
        "id": 535777640,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755918074
    },
    {
        "content": "<p>so the only time you'd see big inferred types like that would be if you weren't annotating top-level functions at all, which in turn would likely only be when writing quick scripts anyway</p>",
        "id": 535777663,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755918107
    },
    {
        "content": "<p>as far as how this works across modules, yeah it's row types similar to records or anonymous tag unions</p>",
        "id": 535777694,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755918160
    },
    {
        "content": "<p>so let's say I write this function (no annotation) and just expose it from my module</p>",
        "id": 535777719,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755918194
    },
    {
        "content": "<p>let's say the function's name is <code>join_walk_push</code></p>",
        "id": 535777745,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755918225
    },
    {
        "content": "<p>another module could call it like so:</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"o\">|</span><span class=\"n\">arg1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">arg2</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"no\">FirstModule</span><span class=\"o\">.</span><span class=\"n\">join_walk_push</span><span class=\"p\">(</span><span class=\"n\">arg1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">arg2</span><span class=\"p\">)</span>\n</code></pre></div>",
        "id": 535777767,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755918262
    },
    {
        "content": "<p>in that case, the inferred type of that function would of course be the same, because all it's doing is calling a function with that type and returning its answer</p>",
        "id": 535777781,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755918286
    },
    {
        "content": "<p>similarly, if the other module were to expose <em>that</em> function, and another module were to call <em>it</em>, that function's type would still be unchanged</p>",
        "id": 535777807,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755918313
    },
    {
        "content": "<p>however, if at any point the function gets called with a narrower type, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"o\">|</span><span class=\"n\">arg1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">arg2</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"no\">FirstModule</span><span class=\"o\">.</span><span class=\"n\">join_walk_push</span><span class=\"p\">(</span><span class=\"o\">[].</span><span class=\"n\">concat</span><span class=\"p\">(</span><span class=\"n\">arg1</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">arg2</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>...then the type of <em>that</em> function (but not all the others) would be instantiated (at the call site) and unified to something narrower, in this case (because of the <code>[]</code> being passed for the first arg):</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"no\">List</span><span class=\"p\">(</span><span class=\"n\">elem</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"no\">List</span><span class=\"p\">(</span><span class=\"n\">elem</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"no\">List</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"n\">where</span><span class=\"w\"> </span><span class=\"o\">[</span>\n<span class=\"w\">        </span><span class=\"n\">module</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">from_digits</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Iter</span><span class=\"p\">(</span><span class=\"no\">U8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"no\">Result</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">BadNumLiteral</span><span class=\"p\">(</span><span class=\"no\">Str</span><span class=\"p\">)),</span>\n<span class=\"w\">    </span><span class=\"o\">]</span>\n</code></pre></div>\n<p>(assuming <code>List.push</code> exists; otherwise it's a type mismatch - these end up needing to be <code>List</code>s because of <code>x.map2(y, ...)</code> when <code>x</code> is a <code>List</code> means this <code>map2</code> will be <code>List.map2</code> etc.)</p>",
        "id": 535777917,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755918486
    },
    {
        "content": "<p>and again, you could export <em>that</em> function from the module, and other modules could import it, and then either re-export it by just calling it and returning the answer (in which case this narrower type would be unchanged), or else narrowing it even further</p>",
        "id": 535777960,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755918547
    },
    {
        "content": "<p>Ahh ok, so this is a bit more sorted out in my head now</p>",
        "id": 535778169,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1755918930
    },
    {
        "content": "<p>The issue I was running into is, in the row-polymorphism approach, you end up with this type information hanging off of the inferred argument types of the function. Which would be fine on its own - except that, for reasons, I want/need to understand what properties the return value of that function could possibly have - and that would require traversing all the type references _backwards_.</p>",
        "id": 535778235,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1755919061
    },
    {
        "content": "<p>so the key here is that in order to narrow a type variable in a <code>module</code> (e.g. the <code>x</code> in <code>module(x)</code>), you have to actually pas a specific nominal type</p>",
        "id": 535778255,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755919110
    },
    {
        "content": "<p>and as soon as you've passed a specific nominal type, we know what module it came from</p>",
        "id": 535778264,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755919121
    },
    {
        "content": "<p>and as soon as we know the module, it's trivial to unify <code>moudle(x).foo : type goes here</code> with the type of that module's exposed <code>foo</code> function (or give an error if that module doesn't expose a <code>foo</code>)</p>",
        "id": 535778295,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755919189
    },
    {
        "content": "<p>Yep yep</p>",
        "id": 535778314,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1755919220
    },
    {
        "content": "<p>so basically you can add constraints by calling more methods, and they just accumulate in the inferred type as more <code>module(a).whatever</code>s</p>",
        "id": 535778317,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755919225
    },
    {
        "content": "<p>and then you can reduce constraints by providing actual nominal types</p>",
        "id": 535778320,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755919235
    },
    {
        "content": "<p>and eventually you end up providing nominal types for everything (or variables stay unbound, e.g. empty list, which is also fine)</p>",
        "id": 535778329,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755919251
    },
    {
        "content": "<p>at which point we know all the functions that need to be called, and it all works out! <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 535778340,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755919264
    },
    {
        "content": "<p>Random observation - when you use static dispatch and let the compiler infer the type, the inferred type ends up pretty closely reflecting the shape of the code in the function, but obviously omitting some details. I wonder if that could be useful somehow... <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 535778363,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1755919320
    },
    {
        "content": "<p>that's interesting!</p>",
        "id": 535778819,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755920063
    },
    {
        "content": "<p>I kinda suspect it would be like...\"almost but not quite\" something we could rely on in the compiler</p>",
        "id": 535778829,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755920081
    },
    {
        "content": "<p>like there'd be just enough differences that we couldn't just say \"the type is [just go look at this canonical IR node]\"</p>",
        "id": 535778843,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1755920103
    },
    {
        "content": "<p>Right, it \"looks thru\" inlining, for example</p>",
        "id": 535779085,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1755920455
    },
    {
        "content": "<p>I was more thinking of either from the _user_ side, or perhaps the _possible language extension_ side.</p>",
        "id": 535779102,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1755920476
    },
    {
        "content": "<p>The analogy that was popping into my head was how some ML frameworks (e.g. pytorch) \"compile\" functions via bytecode inspection. And vaguely similarly, you can do interesting things with passing Proxy objects to javascript functions and just always return new proxy objects from them - you end up essentially getting a trace of the execution, minus branching and constant evaluation, etc.</p>",
        "id": 535779212,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1755920655
    }
]