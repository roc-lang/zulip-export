[
    {
        "content": "<p>Wanted to pop this github thread out to zulip: <a href=\"https://github.com/roc-lang/roc/pull/7569#discussion_r1938529685\">https://github.com/roc-lang/roc/pull/7569#discussion_r1938529685</a><br>\n<span class=\"user-mention\" data-user-id=\"781658\">@Anthony Bullard</span> / <span class=\"user-mention\" data-user-id=\"343810\">@Brendan Hansknecht</span></p>\n<p>The approach used in the current tokenizer PR is to preserve exact indent info and let the parser use that however it wants to figure out nesting.</p>\n<p>The more-commonly-used alternative (e.g. in Python) would be to generate indent and dedent tokens. I believe this approach is viable for the current roc grammar, but it does force us to be a little bit more picky about indentation. When developing the parser that went along with this tokenizer, I found that trying to use only indent/dedent tokens resulted in very picky indentation that I found frustrating to get working.</p>\n<p>Thoughts?</p>",
        "id": 497284463,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738525119
    },
    {
        "content": "<p>I like it being more permissive - fits with the goal of having it be more error-tolerant</p>",
        "id": 497284661,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1738525278
    },
    {
        "content": "<p>so yeah, sounds like indent/dedent tokens aren't the way to go</p>",
        "id": 497284764,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1738525336
    },
    {
        "content": "<p>I have no thoughts besides making sure we document what we chose and why. I was just surprised that we are only counting spaces or tabs, that didn't feel like enough (but I don't work on the parser).</p>",
        "id": 497284799,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738525367
    },
    {
        "content": "<p>We're counting both spaces and tabs in the current PR (keeping the counts separate). That's just enough information to be agnostic to whatever the editor configuration for tab indent width is, and still parse correctly.</p>",
        "id": 497285023,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738525553
    },
    {
        "content": "<p>But like is <code>space space tab space</code> the same as <code>tab space space space</code>?</p>",
        "id": 497285106,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738525604
    },
    {
        "content": "<p>Technically, if we wanted to be very particular, we could record the exact indent string that's used. that would let us catch cases where the first line uses spaces then tabs and the second line uses tabs and spaces. However, it doesn't feel important to me to reject that case in particular.</p>",
        "id": 497285125,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738525618
    },
    {
        "content": "<p>Ha ha yeah exactly</p>",
        "id": 497285128,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738525622
    },
    {
        "content": "<p>It is not perfectly the same, but would lead to the same indent, given typical editor configurations.</p>",
        "id": 497285154,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738525646
    },
    {
        "content": "<p>A user might be forgiven for mistaking those as the same</p>",
        "id": 497285166,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738525662
    },
    {
        "content": "<p>I guess it would depend on how many spaces a tab is for how it appears in a given editor and if it looks like the same indent level or not.</p>",
        "id": 497285255,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738525702
    },
    {
        "content": "<p>Yeah, if an editor is using tabs to align to e.g. 8 char intervals, then those aren't identical.</p>",
        "id": 497285766,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738526104
    },
    {
        "content": "<p>Yeah, but I guess I don't know what roc is supposed to do with that. So just counting tabs and spaces is probably fine.</p>",
        "id": 497285862,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738526173
    },
    {
        "content": "<p>By that you mean tabs+spaces?</p>",
        "id": 497285877,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738526193
    },
    {
        "content": "<p>(as a single number)</p>",
        "id": 497285885,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738526203
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"453336\">Joshua Warner</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20indent.20handling/near/497285154\">said</a>:</p>\n<blockquote>\n<p>It is not perfectly the same, but would lead to the same indent, given typical editor configurations.</p>\n</blockquote>\n<p>hm is that true? I think that's only true if the editor is replacing tabs with some fixed number of spaces, as opposed to doing tab stops</p>",
        "id": 497285892,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1738526211
    },
    {
        "content": "<p>Err yeah for that example you're right</p>",
        "id": 497285920,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738526241
    },
    {
        "content": "<blockquote>\n<p>By that you mean tabs+spaces?<br>\n(as a single number)</p>\n</blockquote>\n<p>No, sorry, I meant doing what you are currently during in the PR with two different counts. That sounds reasonable cause we don't know what the users tab width is. So we can't really do better.</p>\n<p>There is a chance that <code>space space space tab</code> is 2 indents in the users editor (tab rounds to 2 spaces). As such they see <code>space space tab space</code> as 2.5 indents and maybe accidentally use it as 3 indents, but I'm not sure how roc would derive any of that info.</p>",
        "id": 497286030,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738526342
    },
    {
        "content": "<p>For any case where you have a sequence of: <code>((tab|space{n})*space*)</code> (forgive my relaxed, regular expressions syntax), keeping the count of tabs and count of spaces is sufficient to infer the correct indent level, regardless of if the user has an improper tabs versus spaces setting.</p>",
        "id": 497286135,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738526410
    },
    {
        "content": "<p>The conservative alternative here is going back to what the current parser does - only allows spaces. That avoids all of these problems.</p>",
        "id": 497286386,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738526627
    },
    {
        "content": "<p>The expressive alternative is to track the exact order of tabs and spaces and only allow indents that have the previous line's indent string as a prefix</p>",
        "id": 497286487,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738526693
    },
    {
        "content": "<p>I think any other alternative here necessarily involves tracking the count of spaces and tabs. Given that, for example, we could give an error if the user is not consistently using either tabs or spaces with no mixing.</p>",
        "id": 497286536,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738526749
    },
    {
        "content": "<p>Just out of curiosity, what do we do if one line is all spaces and the next is all tabs (this accidentally happens to me sometimes when I edit a file before saving it as a <code>.roc</code> file). I think the editor defaults to tabs, but my roc config and roc in general uses spaces. So sometimes have one line with 4 spaces and then the next with 2 tabs. Really irks me to fix this and last time I checked, the formatter fails to do so.</p>",
        "id": 497286630,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738526819
    },
    {
        "content": "<p>fwiw I'd like to report a warning for using anything other than tabs for indentation</p>",
        "id": 497286667,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1738526856
    },
    {
        "content": "<p>so all of this is just for trying to recover if the user makes a mistake</p>",
        "id": 497286694,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1738526878
    },
    {
        "content": "<p>(including having the formatter translate all of these things into the appropriate number of tabs for you)</p>",
        "id": 497286745,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1738526901
    },
    {
        "content": "<blockquote>\n<p>what do we do if one line is all spaces and the next is all tabs</p>\n</blockquote>\n<p>The parser would report an error, since we can't disambiguate that.</p>",
        "id": 497286893,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738527040
    },
    {
        "content": "<p><span aria-label=\"cry\" class=\"emoji emoji-1f622\" role=\"img\" title=\"cry\">:cry:</span></p>",
        "id": 497286930,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738527078
    },
    {
        "content": "<p>Are we switching to tabs? There was a lot of enthusiasm for using tabs for indentation <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 497287028,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1738527141
    },
    {
        "content": "<p>FWIW this scheme comes directly from python</p>",
        "id": 497287097,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738527214
    },
    {
        "content": "<p>I think it is probably a totally reasonable scheme. It just doesn't solve my essentially only issue with tabs/spaces that I currently hit (though still pretty rare).</p>",
        "id": 497287208,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738527308
    },
    {
        "content": "<p>I don't think that's deterministically solvable, is it?</p>",
        "id": 497288096,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1738528025
    },
    {
        "content": "<p>like how could the compiler infer what indentation level you intended without knowing what tab width you have configured?</p>",
        "id": 497288137,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1738528065
    },
    {
        "content": "<p>oh I forgot to mention earlier - I think tabs being used for anything other than indentation should also be a warning (and the formatter should change them to spaces)</p>",
        "id": 497288207,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1738528103
    },
    {
        "content": "<p>If we really wanted to be fancy, we could retry the parse assuming different values of tab width, and see which parse makes the most sense</p>",
        "id": 497288235,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738528133
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"343810\">@Brendan Hansknecht</span> can you give a concrete example of the issue you typically hit?</p>",
        "id": 497288369,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738528225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20indent.20handling/near/497288207\">said</a>:</p>\n<blockquote>\n<p>oh I forgot to mention earlier - I think tabs being used for anything other than indentation should also be a warning (and the formatter should change them to spaces)</p>\n</blockquote>\n<p>hrm, I just realized we'd have to make an exception for this inside doc comments in which you have code blocks.</p>",
        "id": 497288676,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1738528485
    },
    {
        "content": "<p>also, those could be really annoying to edit actually, because a number of editors (most notably Cursor, but Zed is about to start doing this too) are binding the Tab button to mean \"accept LLM-generated suggestion\"</p>",
        "id": 497288799,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1738528575
    },
    {
        "content": "<p>it's fine outside a doc comment bc the editor generally understands where indentation should happen and inserts indents for you, but inside doc comment code blocks they usually don't realize you're in code mode and they don't indent for you</p>",
        "id": 497288903,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1738528652
    },
    {
        "content": "<p>I wouldn’t expect an editor to reliably insert tab characters in that position?</p>",
        "id": 497288904,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738528652
    },
    {
        "content": "<p>We could always make the formatter parse markdown code blocks inside doc comments and format those.</p>",
        "id": 497288979,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738528705
    },
    {
        "content": "<p>that would be good! <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 497288990,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1738528714
    },
    {
        "content": "<p>also maybe we can get the editor grammars able to understand that aspect of markdown and do the indentation</p>",
        "id": 497289030,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1738528755
    },
    {
        "content": "<p>I wonder how Go deals with that <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 497289037,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1738528766
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"453336\">Joshua Warner</span> <a href=\"#narrow/channel/395097-compiler-development/topic/zig.20compiler.20-.20indent.20handling/near/497288369\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> can you give a concrete example of the issue you typically hit?</p>\n</blockquote>\n<p>Here is what normally happens. Copy some code from github that is a repro or something. Paste it into my editor. Edit the file before saving (leads to inserting tabs instead of spaces). Save and now have some lines with tabs and some with spaces.</p>\n<p>Just did a small edit of basic cli hello world and got this:</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"n\">app</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">main!</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"ss\">pf</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">platform</span><span class=\"w\"> </span><span class=\"s2\">\"../platform/main.roc\"</span><span class=\"w\"> </span><span class=\"p\">}</span>\n\n<span class=\"c1\"># To run this example: check the README.md in this folder</span>\n\n<span class=\"n\">import</span><span class=\"w\"> </span><span class=\"n\">pf</span><span class=\"o\">.</span><span class=\"n\">Stdout</span>\n\n<span class=\"n\">main!</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">\\</span><span class=\"n\">_args</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s2\">\"Hello, World!\"</span>\n<span class=\"w\">    </span><span class=\"no\">Stdout</span><span class=\"o\">.</span><span class=\"n\">line!</span><span class=\"w\"> </span><span class=\"n\">x</span>\n\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"no\">Str</span><span class=\"o\">.</span><span class=\"n\">countUtf8Bytes</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"k\">then</span>\n<span class=\"w\">        </span><span class=\"no\">Stdout</span><span class=\"o\">.</span><span class=\"n\">line!</span><span class=\"w\"> </span><span class=\"s2\">\"large\"</span>\n<span class=\"w\">    </span><span class=\"k\">else</span>\n<span class=\"w\">        </span><span class=\"no\">Stdout</span><span class=\"o\">.</span><span class=\"n\">line!</span><span class=\"w\"> </span><span class=\"s2\">\"small\"</span>\n</code></pre></div>\n<p>The original indented line from hello world (<code>Stdout.line! x</code>) is now the only line indented with spaces. With large code snippets, this becomes a mess of tabs and spaces and I have to manually do a bunch of character replacing.</p>",
        "id": 497289056,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738528788
    },
    {
        "content": "<p>This happens cause I edit the file before saving it. Once I save it with a <code>.roc</code> extension, the editor figures it out.</p>",
        "id": 497289128,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738528828
    },
    {
        "content": "<p>But at that point the damage is done.</p>",
        "id": 497289177,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738528879
    },
    {
        "content": "<p>This sounds like the right approach would be to detect there’s a mix of spaces and tabs, issue a warning, and retry parsing with different tab width configs</p>",
        "id": 497289190,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738528900
    },
    {
        "content": "<p>The pick the one with the fewest parse errors/warnings</p>",
        "id": 497289248,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738528923
    },
    {
        "content": "<p><a href=\"https://forum.cursor.com/t/ambiguity-with-the-tab-key-in-cursor/7663/12?utm_source=chatgpt.com\">https://forum.cursor.com/t/ambiguity-with-the-tab-key-in-cursor/7663/12?utm_source=chatgpt.com</a></p>\n<p>ah, apparently a common workaround for indentation specifically is to use an \"increase indentation level\" keybinding</p>",
        "id": 497289332,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1738529036
    },
    {
        "content": "<p>I don't think that would work in doc comments though</p>",
        "id": 497289414,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1738529091
    },
    {
        "content": "<p>it would just indent the comment <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 497289429,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1738529101
    },
    {
        "content": "<p>I would tend to uncomment, edit normally, then recomment</p>",
        "id": 497289454,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738529127
    },
    {
        "content": "<p>Sorry everyone - had a number of Lunar New Years parties this weekend and have mostly been out.</p>",
        "id": 497289705,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738529379
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"453336\">@Joshua Warner</span> I think that indent ambiguity is a really messy thing for both the parser and the user to deal with.  I personally think the consistency we could apply with INDENT and DEDENT tokens far outweighs the permissiveness of the alternative plan</p>",
        "id": 497289809,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738529473
    },
    {
        "content": "<p>But I think regardless of what we decide to do with the specifics there, I think the current design of the token output is hard to work with.</p>",
        "id": 497289892,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738529553
    },
    {
        "content": "<p>Specifically we have an SoA over the tokens but in the same struct a fourth array for lines where it's not exactly straightforward with how the parser is supposed to interact with it (its length has no relation to the rest)</p>",
        "id": 497289942,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738529625
    },
    {
        "content": "<p>It’s actually not bad to work with. Logic for that is kept in a very thin layer around the tokenizer, and most of the parser doesn’t have to care.</p>",
        "id": 497289955,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738529640
    },
    {
        "content": "<p>That layer tracks a current line index, incrementing that as appropriate in the parsers advance method</p>",
        "id": 497290018,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738529671
    },
    {
        "content": "<p>Maybe I should stop what I'm working on because it sounds like you have already designed a parser around this tokenizer</p>",
        "id": 497290061,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738529717
    },
    {
        "content": "<p>And the \"thin layer\" that you are speaking of doesn't jump off the page to me at all</p>",
        "id": 497290148,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738529794
    },
    {
        "content": "<p>But I've only had about an hour or two and I've spent most of that exploring some different designs of the AST</p>",
        "id": 497290175,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738529823
    },
    {
        "content": "<p>This is literally the tokenizer from the parser I linked in the other thread, translated to zig. So yeah there is a parser that goes with. But I wasn’t thinking of reusing that wholesale - just select parts.</p>",
        "id": 497290199,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738529856
    },
    {
        "content": "<p>Oh, the one with the linear tree structure?</p>",
        "id": 497290272,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738529899
    },
    {
        "content": "<p>Yeah</p>",
        "id": 497290278,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738529906
    },
    {
        "content": "<p>I spent quite a lot of time trying out the indent and dedent token idea, and it was quite fragile</p>",
        "id": 497290295,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738529925
    },
    {
        "content": "<p>Ok, I thought that was more of a thought experiment since we seemed to be aiming for simplicity</p>",
        "id": 497290299,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738529932
    },
    {
        "content": "<p>Yeah, the linear tree parts of that I want to throw away</p>",
        "id": 497290320,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738529952
    },
    {
        "content": "<p>That's interesting, usually with RD with a WSS language IDENT/DEDENT tokens are very straightforward</p>",
        "id": 497290337,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738529975
    },
    {
        "content": "<p>But maybe it's different with Roc's philosophy of maximal flexibility in the parser</p>",
        "id": 497290408,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738530016
    },
    {
        "content": "<p>The problem with indent/dedent in roc is there’s a long list of tokens that might jntroduce a block. Python only allow : to do that.</p>",
        "id": 497290434,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738530033
    },
    {
        "content": "<p>Don’t get me wrong; indent/dedent can be made to work. But it gets messy.</p>",
        "id": 497290554,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738530127
    },
    {
        "content": "<p>I think there would be two main helpers for that, say <code>parse_block (parses newline-delimited statements at same level of indentation)</code>, and <code>parse_collection</code>(parses a comma-delimited sequence that can dedent).</p>",
        "id": 497290555,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738530129
    },
    {
        "content": "<p>Ok, I'd love to see the difference between the two as I can't imagine the other being simpler (but I'm probably just a dolt).</p>",
        "id": 497290660,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738530226
    },
    {
        "content": "<p>You have to be careful because you don’t want the ￼tokenizer to insert indent tokens in the middle of an expression</p>",
        "id": 497290744,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738530303
    },
    {
        "content": "<p>You also kinda want indent tokens inside parens (so that can allow stmts), but you also… don’t, because folks are used to eg python where indentation is relaxed inside parens</p>",
        "id": 497290852,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738530376
    },
    {
        "content": "<p>Why not?  In Python:</p>\n<div class=\"codehilite\"><pre><span></span><code>some_func(\n    a,\n    b,\n)\n</code></pre></div>\n<p>Would be a ID, PAREN_O, IDENT, ID, COMMA, NEWLINE, ID, COMMA, DEDENT, PAREN_C no?  Don't see why it wouldn't be the same in Roc</p>",
        "id": 497290863,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738530395
    },
    {
        "content": "<p>(I don't remember the exact token names)</p>",
        "id": 497290891,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738530430
    },
    {
        "content": "<p>What if b is dedented there? I’d like that to parse properly too since it’s completely unambiguous</p>",
        "id": 497290897,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738530436
    },
    {
        "content": "<p>Similarly, maybe a is dedented but b is indented.</p>",
        "id": 497290931,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738530479
    },
    {
        "content": "<p>Hmm....I would just expect us to push a parse error and fast forward to the closing paren and move on</p>",
        "id": 497291020,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738530529
    },
    {
        "content": "<p>That’s a valid answer, yeah. But I want to be more forgiving than that.</p>",
        "id": 497291052,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738530564
    },
    {
        "content": "<p>I’d like to have fewer annoyances than an indentation sensitive lang like python, not more</p>",
        "id": 497291146,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738530620
    },
    {
        "content": "<p>Couldn't you just say in a collection \"use INDENT and DEDENT to track current, and ensure that if we encounter a newline that the indentation is the same as the start?\"</p>",
        "id": 497291150,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738530630
    },
    {
        "content": "<p>And an apply as well?</p>",
        "id": 497291157,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738530638
    },
    {
        "content": "<p>I don’t quite follow</p>",
        "id": 497291171,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738530654
    },
    {
        "content": "<p>Ok, let me try an example</p>",
        "id": 497291185,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738530666
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code><span class=\"n\">foo</span><span class=\"p\">(</span> <span class=\"c1\"># start_indent=0, current_indent=0</span>\n    <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"c1\"># INDENT = current_indent = current_indent + 1 (1)</span>\n<span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"c1\"># DEDENT = current_indent = current+indent - 1 (0)</span>\n<span class=\"p\">)</span> <span class=\"c1\"># NEWLINE doesn't change indent</span>\n</code></pre></div>\n<p>This can parse because the apply (an args container), was satisfied because we ended with the current_indent the same as start_indent</p>",
        "id": 497291335,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738530834
    },
    {
        "content": "<p>Or you just throw away the INDENTs and DEDENTs inside the container completely, and only monitor indent at the statement level</p>",
        "id": 497291460,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738530959
    },
    {
        "content": "<p>But at <em>some point</em> I feel like you have to make the whitespace significant in a whitespace significant language.</p>",
        "id": 497291544,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531030
    },
    {
        "content": "<p>Hmm so I was definitely assuming indent/dedent would properly nest with other braces. I don’t think that would work with your design?</p>",
        "id": 497291570,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738531066
    },
    {
        "content": "<p>In Python IDENT/DEDENT are braces - because its a militantly WSS language</p>",
        "id": 497291655,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531107
    },
    {
        "content": "<p>But they don't have to be, they can just be state-change tokens</p>",
        "id": 497291667,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531120
    },
    {
        "content": "<p>Hmm</p>",
        "id": 497291672,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738531129
    },
    {
        "content": "<p>At that level, I think these two representations are approximately equivalent</p>",
        "id": 497291705,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738531163
    },
    {
        "content": "<p>Or we can take a page from Lua and require blocks have an explicitly textual end delimiter.  (Don't kill me , I know I suggested this before)</p>",
        "id": 497291726,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531189
    },
    {
        "content": "<p>Ehhhh</p>",
        "id": 497291779,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738531204
    },
    {
        "content": "<p>Yeah, it just pushes the logic for \"what's an indent or dedent or just a newline?\" to the tokenizer</p>",
        "id": 497291807,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531231
    },
    {
        "content": "<p>No, that logic has to cross both the parser and tokenizer. The parser has to know to ignore some of these indent/dedents where it doesn’t care about them.</p>",
        "id": 497291887,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738531302
    },
    {
        "content": "<p>Let me ask you this, if</p>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code><span class=\"n\">foo</span><span class=\"p\">(</span>\n    <span class=\"n\">a</span><span class=\"p\">,</span>\n<span class=\"n\">b</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n</code></pre></div>\n<p>Should parse, what about:</p>\n<div class=\"codehilite\" data-code-language=\"Elm\"><pre><span></span><code><span class=\"nv\">when</span><span class=\"w\"> </span><span class=\"nv\">foo</span><span class=\"w\"> </span><span class=\"nv\">is</span>\n<span class=\"w\">    </span><span class=\"kt\">Ok</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nv\">something</span>\n<span class=\"kt\">Err</span><span class=\"p\">(</span><span class=\"nv\">e</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"nv\">something_else</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nv\">func</span><span class=\"p\">(</span><span class=\"nv\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">b</span><span class=\"p\">)</span>\n<span class=\"nv\">something_else</span>\n</code></pre></div>\n<p>?</p>",
        "id": 497291961,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531340
    },
    {
        "content": "<p>That should not parse</p>",
        "id": 497292004,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738531378
    },
    {
        "content": "<p>And doesn’t, currently</p>",
        "id": 497292020,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738531388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"453336\">Joshua Warner</span> <a href=\"#narrow/channel/395097-compiler-development/topic/zig.20compiler.20-.20indent.20handling/near/497291887\">said</a>:</p>\n<blockquote>\n<p>No, that logic has to cross both the parser and tokenizer. The parser has to know to ignore some of these indent/dedents where it doesn’t care about them.</p>\n</blockquote>\n<p>Yes, but it doesn't have to decide what <strong>is</strong> a indent/dedent in terms of raw character bytes (1 space, 4 spaces, tab, etc)</p>",
        "id": 497292025,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531391
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"453336\">Joshua Warner</span> <a href=\"#narrow/channel/395097-compiler-development/topic/zig.20compiler.20-.20indent.20handling/near/497292004\">said</a>:</p>\n<blockquote>\n<p>That should not parse</p>\n</blockquote>\n<p>But why not?  It's just as unambiguous to me.  Or is it because the former has an explicit bounding pair around it?</p>",
        "id": 497292131,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531468
    },
    {
        "content": "<p>It’s only unambiguous if the input ends there</p>",
        "id": 497292160,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738531489
    },
    {
        "content": "<p>And then</p>\n<div class=\"codehilite\" data-code-language=\"Elm\"><pre><span></span><code><span class=\"nv\">when</span><span class=\"w\"> </span><span class=\"nv\">foo</span><span class=\"w\"> </span><span class=\"nv\">is</span>\n<span class=\"w\">    </span><span class=\"kt\">Ok</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nv\">something</span>\n<span class=\"kt\">Err</span><span class=\"p\">(</span><span class=\"nv\">e</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span>\n<span class=\"nv\">something_else</span><span class=\"w\"> </span><span class=\"nf\">=</span><span class=\"w\"> </span><span class=\"nv\">func</span><span class=\"p\">(</span><span class=\"nv\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nv\">b</span><span class=\"p\">)</span>\n<span class=\"nv\">something_else</span>\n<span class=\"nv\">end</span>\n</code></pre></div>\n<p>would be unambiguous if that syntax existed?</p>",
        "id": 497292203,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531515
    },
    {
        "content": "<p>Yeah but it doesn’t</p>",
        "id": 497292218,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738531528
    },
    {
        "content": "<p>Cool, on the same page</p>",
        "id": 497292229,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531535
    },
    {
        "content": "<p>I'm trying to think of how we would <em>describe</em> the grammar of Roc, in say EBNF</p>",
        "id": 497292315,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531571
    },
    {
        "content": "<p>That’s a gnarly road to go down</p>",
        "id": 497292353,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738531598
    },
    {
        "content": "<p>As opposed to thinking about the logic we'll implement in Zig</p>",
        "id": 497292354,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531599
    },
    {
        "content": "<p>But maybe it's just me, but I want things to be consistent</p>",
        "id": 497292376,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531618
    },
    {
        "content": "<p>Roc is not well designed to have a simple-ish ebnf</p>",
        "id": 497292405,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738531635
    },
    {
        "content": "<p>I think that's what people like about C-syntax languages</p>",
        "id": 497292407,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531637
    },
    {
        "content": "<p>I don’t disagree with you</p>",
        "id": 497292423,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738531651
    },
    {
        "content": "<p>Is that a block is _always_ in squirlies</p>",
        "id": 497292426,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531652
    },
    {
        "content": "<p>But that’s not what roc is right now</p>",
        "id": 497292441,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738531667
    },
    {
        "content": "<p>(I would be open to changing that - and TBH that’s a direction I like, but that seems like a separate convo)</p>",
        "id": 497292519,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738531700
    },
    {
        "content": "<p>What I'm saying is is that \"Whitespace matters for a when expression, but not for a multi-line list or application\" feels inconsistent to me</p>",
        "id": 497292533,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531717
    },
    {
        "content": "<p>I want to have a parser that’s not annoying to work with as a user</p>",
        "id": 497292566,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738531750
    },
    {
        "content": "<p>It feels forgiving yes, but inconsistent</p>",
        "id": 497292573,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531756
    },
    {
        "content": "<p>We can issue a warning if we want</p>",
        "id": 497292587,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738531768
    },
    {
        "content": "<p>Oh, so that's why it seems like you are saying to get rid of WSS :-)</p>",
        "id": 497292590,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531772
    },
    {
        "content": "<p>Or at least suggesting it</p>",
        "id": 497292601,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531784
    },
    {
        "content": "<p>Because it is fiddly</p>",
        "id": 497292607,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531794
    },
    {
        "content": "<p>No. Only relaxing it where it’s unambiguous</p>",
        "id": 497292608,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738531794
    },
    {
        "content": "<p>I’m just describing how the current parser/language work. I want to keep that same behavior.</p>",
        "id": 497292700,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738531824
    },
    {
        "content": "<p>That makes sense, but this new compiler is probably the best time to write down the principles we want for the parser and kind of move away from the past.  That's kind of what we are doing in every other phase (within reason).</p>\n<p>Like, what would you change if the starting part for the grammar was properly formatted code from the current compiler?</p>",
        "id": 497292916,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531964
    },
    {
        "content": "<p>And then say \"what should we be more forgiving on from this point?\"</p>",
        "id": 497292946,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738531995
    },
    {
        "content": "<p>You obviously don't want to require the user to write perfectly formatted code -  humans aren't structural editors</p>",
        "id": 497292971,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738532020
    },
    {
        "content": "<p>Roc is not well designed to have a clean and simple grammar</p>",
        "id": 497293045,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738532047
    },
    {
        "content": "<p>But what version of that grammar parses very fast, is very consistent, and not a pain to work with?</p>",
        "id": 497293061,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738532060
    },
    {
        "content": "<p>Languages with significant white space are simply not encodable in context free grammars. You always need an adapter layer, and that can get ugly.</p>",
        "id": 497293138,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738532142
    },
    {
        "content": "<p>If we want a language that has a simple grammar, that’ll require making some significant changes.</p>",
        "id": 497293208,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738532173
    },
    {
        "content": "<p>Yes, I know.  That's why when I created my language I did one trick to make it neither require braces, nor be WSS: All blocks _must_ end in an expression.  But that requires a specific design of language that is not like Roc today and definitely not Roc of tomorrow</p>",
        "id": 497293269,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738532231
    },
    {
        "content": "<p>Roc used to be like that</p>",
        "id": 497293322,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738532281
    },
    {
        "content": "<p>It could technically be written in a single line and parse correctly (until I added that all blocks end in an expression followed by a newline)</p>",
        "id": 497293362,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738532290
    },
    {
        "content": "<p>Presumably you need substitute line separators? Or were expressions always self-delimiting?</p>",
        "id": 497293401,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738532339
    },
    {
        "content": "<p>Yeah, we seem to be much closer to a Ruby-style syntax</p>",
        "id": 497293406,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738532343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"453336\">Joshua Warner</span> <a href=\"#narrow/channel/395097-compiler-development/topic/zig.20compiler.20-.20indent.20handling/near/497293401\">said</a>:</p>\n<blockquote>\n<p>Presumably you need substitute line separators? Or were expressions always self-delimiting?</p>\n</blockquote>\n<p>Every expression was self-delimiting.  There were only literals for Strings, Numbers, Lists, Tuples, Records, Tuples, Lambdas and then Tags and a Match expression.  Lambas delimited with {} (only the anonymous kind, not top-level), and match required branches to be introduced with \"|\" so the last branch would delimit the whole expression</p>",
        "id": 497293591,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738532475
    },
    {
        "content": "<p>Aha yep makes sense</p>",
        "id": 497293625,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738532507
    },
    {
        "content": "<p>Cool</p>",
        "id": 497293633,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738532511
    },
    {
        "content": "<p>It wasn't the most efficient, but parsed reasonably fast for being written in F#</p>",
        "id": 497293684,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738532529
    },
    {
        "content": "<p>Hand rolled the RD parser at first, and then moved to FParsec which was 95% API compatible</p>",
        "id": 497293709,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738532552
    },
    {
        "content": "<p>I’d like to keep the set of syntax changes we’re making with this rewrite as minimal as possible</p>",
        "id": 497293770,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738532609
    },
    {
        "content": "<p>(Thank you Scott Wlaschin of <a href=\"https://fsharpforfunandprofit.com/\">F# For Fun And Profit Fame</a> for giving me inspiration)</p>",
        "id": 497293780,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738532617
    },
    {
        "content": "<p>Yeah I'd like to make zero</p>",
        "id": 497293792,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738532628
    },
    {
        "content": "<p>So that leads us back to the initial discussion</p>",
        "id": 497293851,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738532650
    },
    {
        "content": "<p>Cool, sounds like we’re aligned then</p>",
        "id": 497293857,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738532656
    },
    {
        "content": "<p>I think I'll just wait and see what the skeleton of the parser you put up looks like on top of your tokenizer</p>",
        "id": 497293894,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738532696
    },
    {
        "content": "<p>You are the parser guru, so I'll do my best to row the boat in the same direction</p>",
        "id": 497293950,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738532728
    },
    {
        "content": "<p>Just wanted to say my piece and learn a few things along the way</p>",
        "id": 497293970,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738532745
    },
    {
        "content": "<p>I appreciate the back pressure</p>",
        "id": 497294006,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738532763
    },
    {
        "content": "<p>You’re asking reasonable questions</p>",
        "id": 497294036,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738532771
    },
    {
        "content": "<p>As a young padawan, I still think of a parser as \"enforcer of a described, mechanical grammar\"</p>",
        "id": 497294055,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738532787
    },
    {
        "content": "<p>Haha</p>",
        "id": 497294078,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738532811
    },
    {
        "content": "<p>One that reliably generates AST Nodes when the user is being faithful to that grammar</p>",
        "id": 497294090,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738532818
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"781658\">@Anthony Bullard</span> Added a skeleton parser to <a href=\"https://github.com/roc-lang/roc/pull/7569\">https://github.com/roc-lang/roc/pull/7569</a>, that shows the intended way of interoperating with the lines</p>",
        "id": 497331983,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738559802
    },
    {
        "content": "<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> Now that I think about this tho... I wonder if I could just have a <code>Newline</code> token, and subvert either the offset or the length field to sneak in the indent level...</p>",
        "id": 497332053,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738559843
    },
    {
        "content": "<p>That may be a bit easier to integrate, and have lower cognitive overhead on the parser side</p>",
        "id": 497332116,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738559870
    },
    {
        "content": "<p>Yep that seems cleaner; pushed that</p>",
        "id": 497336320,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738562244
    },
    {
        "content": "<p>Sweet that sounds like a good compromise</p>",
        "id": 497399840,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738580515
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"781658\">Anthony Bullard</span> <a href=\"#narrow/channel/395097-compiler-development/topic/zig.20compiler.20-.20indent.20handling/near/497290408\">said</a>:</p>\n<blockquote>\n<p>But maybe it's different with Roc's philosophy of maximal flexibility in the parser</p>\n</blockquote>\n<p>Just a comment: I believe the value of parser flexibility has dropped significantly. Beginners were likely to produce strange code, but beginners with LLMs are not. It is my understanding that flexibility comes with significant complexity.</p>",
        "id": 497438043,
        "sender_full_name": "Anton",
        "timestamp": 1738590030
    },
    {
        "content": "<p>I think the main value is actually when you're temporarily in a strange editor state, e.g. because you've copy/pasted something in from somewhere else and the indentation is different</p>",
        "id": 497471047,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1738597611
    },
    {
        "content": "<blockquote>\n<p>because you've copy/pasted something in from somewhere else and the indentation is different</p>\n</blockquote>\n<p>Can you explain more? Would you want the parser to able to fully parse everything with mixed indentation?</p>",
        "id": 497480629,
        "sender_full_name": "Anton",
        "timestamp": 1738599795
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20indent.20handling/near/497471047\">said</a>:</p>\n<blockquote>\n<p>I think the main value is actually when you're temporarily in a strange editor state, e.g. because you've copy/pasted something in from somewhere else and the indentation is different</p>\n</blockquote>\n<p>Except roc doesn't fix this with the current plans. That is exactly the case I mentioned above that breaks and is really hard to fix deterministically. It requires having to guess the tab width.</p>",
        "id": 497485092,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738601013
    },
    {
        "content": "<p>But that’s just WSS</p>",
        "id": 497487692,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738601694
    },
    {
        "content": "<p>That’s only solved by only accepting tabs for indentation (or some other more draconian measure like “only four spaces”)</p>",
        "id": 497488055,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738601780
    },
    {
        "content": "<p>WSS?</p>",
        "id": 497489536,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738602148
    },
    {
        "content": "<p>White space significance</p>",
        "id": 497489943,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738602253
    },
    {
        "content": "<p>If you have 100% bounded expressions and statements this isn’t an issue</p>",
        "id": 497490111,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738602305
    },
    {
        "content": "<p>Otherwise you need a deterministic indentation to act like “braces”</p>",
        "id": 497490204,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738602332
    },
    {
        "content": "<p>Oh sure, but it is really frustrating nevertheless.</p>\n<p>Theoretically roc could try and figure this out or at least the formatter could convert tabs to space or vice versa (even with broken code) such that I can notice why the file is broken.</p>",
        "id": 497491208,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738602608
    },
    {
        "content": "<p>Just a very frustrating user experience that is hard to debug. Given everything lines up in my editor, roc could theoretically figure this out by guessing tab widths.</p>",
        "id": 497491374,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738602668
    },
    {
        "content": "<p>Not saying it is worth doing, but I don't think it is unsolvable or innate as an edge case</p>",
        "id": 497491450,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738602691
    },
    {
        "content": "<p>I would be fine with a bad indentation error. In an editor I would then use the \"llm autofix error\" button (zed already has this I believe). I bet llms are great at fixing indentation.</p>",
        "id": 497495006,
        "sender_full_name": "Anton",
        "timestamp": 1738603788
    },
    {
        "content": "<p>I'm not a fan of that solution cause I don't use llms generally (and I'm sure many others are in this boat). So it really isn't a fix in my mind. Also, it isn't hard to manually fix, just the kind of thing where being permissive would be amazing.</p>",
        "id": 497501199,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738605827
    },
    {
        "content": "<p>Note: I totally also recognize that it may be infeasible/unreasonable to implement.</p>",
        "id": 497515565,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738610745
    },
    {
        "content": "<p>So the best we may get is a good error message</p>",
        "id": 497515589,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738610757
    },
    {
        "content": "<p>Was there ever a discussion about WSS? especially with regards to the parencomma restructuring. i could not find anything</p>",
        "id": 497522433,
        "sender_full_name": "kris",
        "timestamp": 1738613419
    },
    {
        "content": "<p>Nope</p>",
        "id": 497522957,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738613637
    },
    {
        "content": "<p>You could start a <a class=\"stream\" data-stream-id=\"304641\" href=\"/#narrow/channel/304641-ideas\">#ideas</a> thread, but I would not expect it to see traction.</p>",
        "id": 497523093,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1738613681
    },
    {
        "content": "<p>I’ve started such a thread in the past and it did not go well <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 497528095,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1738615607
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20indent.20handling/near/497515565\">said</a>:</p>\n<blockquote>\n<p>Note: I totally also recognize that it may be infeasible/unreasonable to implement.</p>\n</blockquote>\n<p>I think it is actually within reason to implement. Or at least improve the situation.</p>",
        "id": 497567873,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1738634900
    }
]