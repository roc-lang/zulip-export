[
    {
        "content": "<p>ok, while working on the epic <a href=\"https://github.com/roc-lang/roc/pull/8368\">https://github.com/roc-lang/roc/pull/8368</a> I have learned some things - I want to do a quick note of them here:</p>",
        "id": 556711255,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763323461
    },
    {
        "content": "<h1>number primitive types</h1>\n<p>we have the <code>num_compact</code>, <code>num_unbound</code> etc. behind-the-scenes types, which were a nice performance optimization for the old <code>Num</code> system (while also being a shortcut to getting <em>something</em> working for number literals and basic arithmetic ops), but which are now mostly in the way now that we have actual nominal types and no longer want to represent numbers as opaque <code>Num</code> types with nested phantom types.</p>\n<p>I think we can do something similar in the static dispatch world, but trying to transition it at the same time as transitioning number literals over to the new design has made it extremely difficult. I think based on my experience so far, it will be better to just take out the number primitves from the type system, use only the actual nominal types we now have in <code>Builtin.roc</code>, and then revisit the primitives (strictly as a performance optimization) in the future once we have all of this working.</p>",
        "id": 556711482,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763323691
    },
    {
        "content": "<h2>methods for converting literals</h2>\n<p>the way to make numbers be ordinary opaque types is to have the type of number literals be polymorphic:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">my_integer</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">num</span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">from_int_digits</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">List</span><span class=\"p\">(</span><span class=\"n\">U8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">Try</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">OutOfRange</span><span class=\"p\">])</span>\n<span class=\"n\">my_integer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span>\n\n<span class=\"n\">my_fraction</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">num</span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">from_dec_digits</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">List</span><span class=\"p\">(</span><span class=\"n\">U8</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"p\">(</span><span class=\"n\">U8</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">Try</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">OutOfRange</span><span class=\"p\">])</span>\n<span class=\"n\">my_fraction</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mf\">4.2</span>\n</code></pre></div>",
        "id": 556711719,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763323942
    },
    {
        "content": "<p>so basically, if you make a custom type which defines <code>from_int_digits</code> then you can define it using integer literals like <code>5</code>, and if you make a custom type which defines <code>from_dec_digits</code> then you can define it using decimal literals like <code>4.2</code></p>",
        "id": 556711811,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763324053
    },
    {
        "content": "<p>this creates a slightly weird situation where you can define a custom number type that defines <code>from_dec_digits</code> but not <code>from_int_digits</code>, and then you can create one using <code>3.0</code> but not <code>3</code>.</p>",
        "id": 556711846,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763324096
    },
    {
        "content": "<p>I'd prefer if the API were such that you essentially had to specify which you wanted</p>",
        "id": 556711878,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763324140
    },
    {
        "content": "<p>instead of being able to forget to handle one case</p>",
        "id": 556711883,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763324151
    },
    {
        "content": "<p>there's another problem, which is that in the future I'd like to do the same thing with string literals, which will mean that we can still have stuff like <code>File.read! : Path =&gt; ...</code> and yet you can give it a string literal like <code>File.read!(\"foo.txt\")</code> because <code>Path</code> has a <code>from_str_literal</code> method (or similar) that does the same thing as <code>from_int_digits</code> etc.</p>",
        "id": 556711926,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763324215
    },
    {
        "content": "<p>the reason this is a problem is that if these are all just polymorphic method constraints, then this code...</p>\n<div class=\"codehilite\"><pre><span></span><code>x = 4.7 / &quot;cheese&quot;\n</code></pre></div>\n<p>...will type-check, and in fact if <code>x</code> is a custom type which (for whatever reason) defines all of <code>from_dec_digits</code> and <code>from_str_literal</code> and <code>div</code> then it will do...something <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 556711999,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763324305
    },
    {
        "content": "<p>you could look at it as a feature that this can work, but there's a nonobvious downside: if <code>4.7 / \"cheese\"</code> happily type-checks, then the same is true if you are giving them names in a quick script where you're not annotating types because it's a quick script:</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">.</span><span class=\"mi\">7</span>\n<span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s2\">\"cheese\"</span>\n\n<span class=\"c1\"># ...somewhere later in the code</span>\n\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">/</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">...</span><span class=\"w\"> </span><span class=\"p\">}</span>\n</code></pre></div>\n<p>this will give a compile-time error, but I don't think it'll be a nice one - because according to these rules, everything in that code type-checks!</p>",
        "id": 556712324,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763324709
    },
    {
        "content": "<p>i really like removing the number types from the type system. it made sense for the polymorphic types, but agree they felt error proned with a less clear perf gain in the static dispatch world</p>",
        "id": 556712328,
        "sender_full_name": "Jared Ramirez",
        "timestamp": 1763324715
    },
    {
        "content": "<p>the type of <code>x / y &gt; 0</code> here is totally valid and internally consistent; it's something like:</p>\n<ul>\n<li><code>y</code> has <code>from_str_literal</code></li>\n<li><code>x</code> has <code>from_dec_digits</code> and <code>div</code></li>\n<li><code>x</code>'s <code>div</code> takes something compatible with <code>y</code> and returns something with <code>is_gt</code></li>\n<li>that <code>is_gt</code> takes something that has <code>from_int_digits</code> (from the <code>0</code>) and returns <code>Bool</code> (because <code>if</code> requires <code>Bool</code>)</li>\n</ul>",
        "id": 556712497,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763324911
    },
    {
        "content": "<p>yeah that is throrny, on the one hand that flexibility is really cool. on the other, it hurts the beginner experience and error message quality</p>",
        "id": 556712644,
        "sender_full_name": "Jared Ramirez",
        "timestamp": 1763325060
    },
    {
        "content": "<p>potentially, the latest point at which you'd actually get a compiler error would be that we make it to compile-time evaluation of constants, resolve <code>x = 4.7</code> to be an <code>I128</code> by default (because it didn't get a more specific number type by the end of type-checking), and similarly <code>y</code> becomes a concrete <code>Str</code>) - so then at that point when we go to evaluate <code>x / y</code>we get an error saying that <code>x</code> defaulted to <code>I128</code> and <code>y</code> defaulted to <code>Str</code> and <code>I128.div</code> only accepts another <code>I128</code>, not a <code>Str</code></p>",
        "id": 556712662,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763325085
    },
    {
        "content": "<p>an idea for how to catch this earlier during type-checking: change all of them to have a <code>from_literal</code> method, which takes a different nominal type for its first argument so that the incompatibility comes up right away</p>",
        "id": 556712698,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763325128
    },
    {
        "content": "<p>so we'd have:</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"no\">I128</span><span class=\"o\">.</span><span class=\"n\">from_literal</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Num</span><span class=\"o\">.</span><span class=\"n\">Literal</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"no\">Try</span><span class=\"p\">(</span><span class=\"no\">I128</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"no\">Unsupported</span><span class=\"o\">]</span><span class=\"p\">)</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"no\">Str</span><span class=\"o\">.</span><span class=\"n\">from_literal</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Str</span><span class=\"o\">.</span><span class=\"n\">Literal</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"no\">Try</span><span class=\"p\">(</span><span class=\"no\">Str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"no\">Unsupported</span><span class=\"o\">]</span><span class=\"p\">)</span>\n</code></pre></div>",
        "id": 556712745,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763325173
    },
    {
        "content": "<p>then:</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">num</span><span class=\"w\"> </span><span class=\"n\">where</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">num</span><span class=\"o\">.</span><span class=\"n\">from_literal</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Num</span><span class=\"o\">.</span><span class=\"n\">Literal</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"no\">Try</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"no\">Unsupported</span><span class=\"o\">]</span><span class=\"p\">)</span>\n<span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">.</span><span class=\"mi\">7</span>\n\n<span class=\"n\">y</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"n\">where</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">str</span><span class=\"o\">.</span><span class=\"n\">from_literal</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Str</span><span class=\"o\">.</span><span class=\"n\">Literal</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"no\">Try</span><span class=\"p\">(</span><span class=\"n\">str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"no\">Unsupported</span><span class=\"o\">]</span><span class=\"p\">)</span>\n<span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s2\">\"cheese\"</span>\n</code></pre></div>",
        "id": 556712807,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763325223
    },
    {
        "content": "<p>so now it's impossible to have a custom type that can be represented as both a string literal and as a number literal</p>",
        "id": 556712873,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763325289
    },
    {
        "content": "<p>because you have to pick one to use with your <code>from_literal</code> method; <code>Num.Literal</code> and <code>Str.Literal</code> would be different nominal types</p>",
        "id": 556712908,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763325319
    },
    {
        "content": "<p>then <code>Num.Literal</code> would have both integer and decimal digits, and for integer types (like <code>I128</code>) you'd just return <code>Err</code> if given a nonzero decimal - basically the same as if you give an <code>U8</code> something over 255</p>",
        "id": 556713094,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763325481
    },
    {
        "content": "<p>all that said, I don't have much intuition for how much this will come up in practice. It might turn out that it's fine, and maybe even nice, to support that level of flexibility</p>",
        "id": 556713244,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763325593
    },
    {
        "content": "<p>one concrete example I just thought of is UI elements</p>",
        "id": 556713265,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763325603
    },
    {
        "content": "<p>e.g. in Elm, when you look at the classic UI example of a <a href=\"https://guide.elm-lang.org/architecture/buttons\">counter that increases or decreases a number example</a>, part of it is:</p>\n<div class=\"codehilite\"><pre><span></span><code>div [] [ text (String.fromInt model) ]\n</code></pre></div>\n<p>so you need to take a number and convert it to a string and then pass that string to a <code>text</code> to display it</p>",
        "id": 556713351,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763325680
    },
    {
        "content": "<p>but with the string literal design mentioned above, you could give your UI element type a <code>from_str_literal</code> method, allowing you to just go <code>[button1, button2, \"some text!\"]</code> without having to call <code>text</code> on it to convert it to a UI element type</p>",
        "id": 556713396,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763325719
    },
    {
        "content": "<p>and then if we supported converting from numbers too, then you could also display numbers in the same way without having to convert them to strings first, e.g. <code>[button1, button2, current_count]</code> could Just Work too</p>",
        "id": 556713440,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763325747
    },
    {
        "content": "<p>but that would require UI elements being able to define both <code>from_str_literal</code> and <code>from_num_literal</code> at the same time</p>",
        "id": 556713473,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763325772
    },
    {
        "content": "<p>so it's probably worth doing the experiment and seeing what actual concrete error messages turn out to be annoying in the wild (or not - maybe they're all fine in practice!)</p>",
        "id": 556713516,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763325807
    },
    {
        "content": "<p>rather than ruling that out before we've even tried it</p>",
        "id": 556713537,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763325821
    },
    {
        "content": "<p>so my conclusion here is mostly that I want to note all of this, as something I've learned while working on that PR, in case we encounter a problem in practice and need to revisit potential solutions later <span aria-label=\"smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 556713573,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763325854
    },
    {
        "content": "<h2>evaluating default numbers</h2>\n<p><code>1 + 2</code> desugars into <code>1.plus(2)</code>, which currently has this type:</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"n\">ret</span><span class=\"w\"> </span><span class=\"n\">where</span><span class=\"w\"> </span><span class=\"o\">[</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">plus</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">ret</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">from_int_digits</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">List</span><span class=\"p\">(</span><span class=\"no\">U8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"no\">Try</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"no\">OutOfBounds</span><span class=\"o\">]</span><span class=\"p\">),</span>\n<span class=\"w\">    </span><span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">from_int_digits</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">List</span><span class=\"p\">(</span><span class=\"no\">U8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"no\">Try</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"no\">OutOfBounds</span><span class=\"o\">]</span><span class=\"p\">),</span>\n<span class=\"o\">]</span>\n</code></pre></div>",
        "id": 556713623,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763325905
    },
    {
        "content": "<p>we have the rule that integers default to <code>I128</code> if not otherwise specified, so that for example beginners can put <code>1 + 1</code> into the repl and get an answer instead of an error saying in this language you need to be more specific about what type of number you want <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 556713701,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763325990
    },
    {
        "content": "<p>(and similar for decimal literals and <code>Dec</code>)</p>",
        "id": 556713707,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763326002
    },
    {
        "content": "<p>now, the trouble is - both the interpreter and the future optimizing compiler need to know <em>at compile time</em> the size in bytes of return types <em>before</em> they call a function</p>",
        "id": 556713778,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763326055
    },
    {
        "content": "<p>this is necessary so they can know how much space to allocate in the caller for the return type</p>",
        "id": 556713799,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763326072
    },
    {
        "content": "<p>(note that even if we somehow changed the interpreter to not need this, which I don't think would be the right choice for reasons that are out of scope here, the optimizing compiler would still need it - so we should assume that we need to preserve this property)</p>",
        "id": 556713826,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763326108
    },
    {
        "content": "<p>the problem here is that the inferred type (<code>ret where ...</code>) doesn't actually capture that this is \"a number\"</p>",
        "id": 556713858,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763326138
    },
    {
        "content": "<p>so even if we know that \"numbers default to <code>I128</code>\", when we try to evaluate the expression <code>1 + 2</code>, we don't know after type checking that the return type is a number - and therefore we don't know how much space to allocate</p>",
        "id": 556713944,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763326221
    },
    {
        "content": "<p>now one thing we could theoretically do here is to try to unify <code>I128</code> with <code>ret where [...]</code> and see that it succeeds, and therefore conclude that this is <em>compatible</em> with <code>I128</code>, and so <code>I128</code> is a reasonable default, and therefore we should use it</p>",
        "id": 556714006,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763326286
    },
    {
        "content": "<p>however, even if that did seem like a good approach for this scenario, it falls apart in this example:</p>\n<div class=\"codehilite\"><pre><span></span><code>(|a, b| a + b)(1, 2)\n</code></pre></div>",
        "id": 556714031,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763326310
    },
    {
        "content": "<p>this should, of course, do the same thing as just running <code>1 + 2</code></p>",
        "id": 556714050,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763326329
    },
    {
        "content": "<p>it would be very strange if <code>1 + 2</code> worked but <code>(|a, b| a + b)(1, 2)</code> didn't, or if they got different answers!</p>",
        "id": 556714070,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763326348
    },
    {
        "content": "<p>the problem is that the type of <code>1 + 2</code> is:</p>\n<div class=\"codehilite\"><pre><span></span><code>ret where [\n    a.plus : a, b -&gt; ret,\n    a.from_int_digits : List(U8) -&gt; Try(a, [OutOfBounds]),\n    b.from_int_digits : List(U8) -&gt; Try(a, [OutOfBounds]),\n]\n</code></pre></div>",
        "id": 556714146,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763326419
    },
    {
        "content": "<p>...and the type of <code>(|a, b| a + b)</code> is the same, but instead of <code>ret</code> at the start it's <code>a, b -&gt; ret</code></p>\n<div class=\"codehilite\"><pre><span></span><code>a, b -&gt; ret where [\n    a.plus : a, b -&gt; ret,\n    a.from_int_digits : List(U8) -&gt; Try(a, [OutOfBounds]),\n    b.from_int_digits : List(U8) -&gt; Try(a, [OutOfBounds]),\n]\n</code></pre></div>",
        "id": 556714196,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763326462
    },
    {
        "content": "<p>so if we try to call this with <code>1</code> - which has the type <code>a where a.from_int_digits : List(U8) -&gt; Try(a, [OutOfBounds])</code> - then what we'd like to have happen is that the literal <code>1</code> would pick up the <code>plus</code> constraint too, and now be required to have both <code>from_int_digits</code> (which it has by default because it's a number literal) as well as <code>plus</code> (because it unified with <code>a</code> in <code>a, b -&gt; ret</code> and <code>a</code> is required to have <code>plus</code>)</p>",
        "id": 556714436,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763326710
    },
    {
        "content": "<p>I'm pretty sure this is what should already happen, although I haven't tried it</p>",
        "id": 556714464,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763326738
    },
    {
        "content": "<p>anyway, despite being more convoluted than the non-lambda version, I think this example should work out just like <code>1 + 2</code> in that if we were to try unifying <code>I128</code> with the unbound value, it should work</p>",
        "id": 556714582,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763326842
    },
    {
        "content": "<p>but there's something that does feel concerning about all of those examples, namely that it basically means anytime we try to eval an unresolved polymorphic type, or a function that's returning one, we have to basically assume it's a number (and try to unify it accordingly) even though we don't really have a reason to assume that <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 556714725,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763326993
    },
    {
        "content": "<p>and in the world where we're doing it with strings too, we'd probably have to just try both (perhaps after looking for the obvious <code>form_num_literal</code>/<code>from_str_literal</code> in the constraints as a heuristic for which to try first) - probably not a big deal in practice, given that these defaults basically only ever come up in practice in the repl, or maybe in very quick scripts</p>",
        "id": 556714810,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763327078
    },
    {
        "content": "<p>anyway, my conclusion from all of this is that:</p>\n<ul>\n<li>when the interpreter (or in the future the optimizing compiler) encounters an unbound polymorphic type whose layout must be known, it should try to <em>unify</em> that type with the default number type, and not just \"assume\" it like before (because we don't have any information to go on as to whether that's a safe assumption or not)</li>\n<li>in the future where we're doing this for strings too, we can try unifying both, and use the presence of a <code>from_whichever_literal</code> as a heuristic to only bother unifying with the one that's more likely to succeed</li>\n</ul>",
        "id": 556714904,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763327178
    },
    {
        "content": "<h2>one default number type</h2>\n<p>based on all of the above, I think we actually want to just have one default number type: <code>Dec</code></p>",
        "id": 556714923,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763327202
    },
    {
        "content": "<p>like, no more \"integers default to <code>I128</code> and non-integers default to <code>Dec</code>\"</p>",
        "id": 556714932,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763327216
    },
    {
        "content": "<p>it's just \"if you have a number literal, regardless of whether there's a decimal point in it, if it doesn't resolve to any other type, we just resolve it to <code>Dec</code>\"</p>",
        "id": 556714956,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763327235
    },
    {
        "content": "<p>this obviously works fine from a runtime perspective, since <code>Dec</code> (unlike floats) is perfectly capable of performing both precise base-10 integer arithmetic as well as precise base-10 decimal arithmetic</p>",
        "id": 556715010,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763327304
    },
    {
        "content": "<p>but it means that we can have just one <code>from_num_literal</code> method which uses the returned value being either <code>Ok</code> or <code>Err</code> (when being evaluated at compile time) to handle <em>both</em> the error case of the literal being out of bounds (e.g. negative number literals being used with unsigned integers, or the number literal being too big to fit in the number - and now additionally, integers being given decimals would be reported the same way)</p>",
        "id": 556715048,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763327367
    },
    {
        "content": "<p>and then at that point, when trying to figure out the runtime type of an unbound number literal, we just unify it with <code>Dec</code> and we're all set</p>",
        "id": 556715084,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763327410
    },
    {
        "content": "<h2>summary</h2>\n<p>I think based on all these learnings, I want to:</p>\n<ul>\n<li>get rid of the <code>num_compact</code>, <code>num_unbound</code>, <code>num_poly</code> etc. system and revisit it after we get all the new stuff working</li>\n<li>change the type of all number literals (whether they have a decimal component or not) to: <code>from_num_literal : NumLiteral -&gt; Try(MyNumberType, [Unsupported(Str)])</code></li>\n<li>define <code>Num.NumLiteral</code> to have methods like <code>is_negative</code>, <code>digits_before_decimal</code>, <code>digits_after_decimal</code>, etc.</li>\n<li>plan to do a similar <code>from_str_literal</code> in the future for strings</li>\n<li>change the default number type to always be <code>Dec</code>, never <code>I128</code></li>\n<li>when the interpreter needs to get the runtime layout of an unresolved polymorphic type, it should first unify it with <code>Dec</code> (and if that unification fails, then evaluate it to a <code>crash</code>)</li>\n</ul>",
        "id": 556715492,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763327841
    },
    {
        "content": "<p>any thoughts on all of that welcome!</p>",
        "id": 556716070,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763328479
    },
    {
        "content": "<p>This sounds like great progress. I like the simplification to just use Dec as default, and it sounds like the type system implementation will be simpler and easier to get right.</p>",
        "id": 556717685,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1763330060
    },
    {
        "content": "<p>yeah, these are all things I wish I'd known earlier, but as usual, actually implementing things is often the fastest way to learn them <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 556718635,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763330841
    },
    {
        "content": "<p>all sounds good to me! the simpler type system, the easier to ensure correctness â€” so big fan of removing hardcoded variants!</p>",
        "id": 556718991,
        "sender_full_name": "Jared Ramirez",
        "timestamp": 1763331268
    },
    {
        "content": "<p>ok cool! Unfortunately this means we can't do more number builtin stuff until all of this lands <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 556719645,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763332167
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/channel/395097-compiler-development/topic/number.20type.20inference/near/556712873\">said</a>:</p>\n<blockquote>\n<p>so now it's impossible to have a custom type that can be represented as both a string literal and as a number literal</p>\n</blockquote>\n<p>Not sure if completely related but this reminded me of your convo with Chris Lattner re: swift's type checker and how a lot of complexity/combinatorial explosions came from all the <code>ExpressibleBy...Literal</code> protocols (traits)</p>",
        "id": 556872994,
        "sender_full_name": "Mike",
        "timestamp": 1763396007
    },
    {
        "content": "<p>I don't think this is related</p>",
        "id": 556888530,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763399697
    },
    {
        "content": "<p>we don't try multiple options the way Swift does</p>",
        "id": 556888591,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763399711
    },
    {
        "content": "<p>merging method constraints is basically the same as merging record field constraints</p>",
        "id": 556888681,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1763399734
    }
]