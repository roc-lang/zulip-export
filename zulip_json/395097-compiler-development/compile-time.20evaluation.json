[
    {
        "content": "<p>regarding <span class=\"user-mention\" data-user-id=\"281543\">@Folkert de Vries</span>'s comment in the meetup about compile-time floating-point answers differing depending on what hardware they happened to be run on: here are a couple of C floating-point software emulation libraries that could be used for emulation</p>\n<ul>\n<li><a href=\"https://github.com/ucb-bar/berkeley-softfloat-3\">Berkeley SoftFloat</a> - <a href=\"https://github.com/ucb-bar/berkeley-softfloat-3/blob/5c06db33fc1e2130f67c045327b0ec949032df1d/COPYING.txt\">BSD licensed</a></li>\n<li><a href=\"https://www.mpfr.org/\">GNU MFPR</a> - LGPL licensed</li>\n</ul>",
        "id": 387456424,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1693082187
    },
    {
        "content": "<p>Weird part about that is it may still lead to unexpected results for end users. Cause even though you now have consistently defined results, you no longer are doing what is expected of hardware. So a user who only runs on one hardware and expects hardware results may not get what they expect.</p>",
        "id": 387465182,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1693091062
    },
    {
        "content": "<p>On top of that, what do we do about the extra flags you can set around rounding and such.</p>",
        "id": 387465201,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1693091098
    },
    {
        "content": "<p>so my overall thought is:</p>\n<ul>\n<li>if you're using floats, it's because you need the runtime performance. Otherwise, use <code>Dec</code>.</li>\n<li>an unfortunate cost of this runtime performance is that you get inconsistent results; answers may differ by system because different CPUs implement the standard slightly differently, and/or may have extra instructions that make certain operations go faster but which give slightly different answers (and aren't available on other CPUs). As far as I can tell, this is an unavoidable cost of doing business with floats; there's no way to get the performance without those inconsistencies.</li>\n<li>with that in mind, \"I got a slightly different answer than I expected\" seems like it should be acceptable. If you need precision, floats are not acceptable for your use case.</li>\n<li>that said, it should be an ironclad guarantee of the language that if you take the same source bytes and compile them on any Roc system with the same <code>roc</code> flags (e.g. <code>--target</code>), you should get the exact same bytes out the other side, <em>maybe</em> give or take metadata like the timestamp of when it was built or something like that.</li>\n</ul>",
        "id": 387551222,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1693161286
    },
    {
        "content": "<p>so the problem I'm interested in solving is reproducibility - I wouldn't want compile-time floats to give a different binary on my local machine vs on CI (again, maybe give or take metadata like timestamps, but I think it's possible we end up wanting to eschew timestamps like that because bit-for-bit reproducible binaries might be more valuable than those) even if my local machine has a different CPU architecture than my CI does</p>",
        "id": 387551319,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1693161370
    },
    {
        "content": "<p>Sounds good. Just wanted to check if the slowness of software floats was worth it. Maybe we can make it so software floats are only needed if you cross compile. If you compile for the host target, you can just set the flags to the hardware mode we want and use hardware floats?</p>",
        "id": 387562660,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1693173286
    },
    {
        "content": "<p>So consistent and often able to be fast at least for targets with the same float unit(though I don't know all of the hardware intricacies)</p>",
        "id": 387562681,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1693173317
    },
    {
        "content": "<p>I think it may be running on all assignments?</p>\n<p>This is inside of a function</p>\n<div class=\"codehilite\"><pre><span></span><code>-- COMPTIME EVAL ERROR ---------------------------\n\nThis definition could not be evaluated at compile time:\n    ┌─ chip8_test_rom.roc:332:20\n    │\n332 │             xIdx = opcode.bitwiseAnd(0x0F00).shiftRightBy(8)\n    │                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe evaluation failed with error:\n    TypeMismatch\n</code></pre></div>\n<p>This is top level and just a surprising failure.</p>\n<div class=\"codehilite\"><pre><span></span><code>-- COMPTIME EVAL ERROR ---------------------------\n\nThis definition could not be evaluated at compile time:\n  ┌─ chip8_test_rom.roc:3:9\n  │\n3 │ width = 64\n  │         ^^\n\nThe evaluation failed with error:\n    TypeMismatch\n</code></pre></div>",
        "id": 546310567,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1761074151
    },
    {
        "content": "<p>Given <code>roc check</code> passes, I'm pretty sure tat TypeMismatch is impossible. So kinda a funny error to see roc spit out.</p>",
        "id": 546310652,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1761074182
    },
    {
        "content": "<p>yeah it's supposed to evaluate inside functions too</p>",
        "id": 546322328,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1761078644
    },
    {
        "content": "<p>basically everything that can be evaluated at compile time (which means it doesn't have any dependencies on fn args that are only known at runtime) is supposed to be evaluated at compile time</p>",
        "id": 546322564,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1761078723
    },
    {
        "content": "<p>otherwise moving the same definition from top-level to an inner scope could degrade performance, which in turn would mean deciding which scope to put constants in would have performance implications instead of just scope visibility implications, which would be really undesirable <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 546322775,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1761078804
    },
    {
        "content": "<p>all that said, this seems like a bug (or at least a confusing error message) - any chance you could get a test reproducing it?</p>",
        "id": 546322867,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1761078840
    },
    {
        "content": "<p>doesn't even have to be super minimal, just something I can try out</p>",
        "id": 546322886,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1761078847
    },
    {
        "content": "<p>This is just roc test on the chip8 file from the other thread</p>",
        "id": 546327425,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1761080563
    },
    {
        "content": "<p>File here: <a href=\"https://github.com/bhansconnect/chip8_op_test/blob/main/chip8_test_rom.roc\">https://github.com/bhansconnect/chip8_op_test/blob/main/chip8_test_rom.roc</a></p>",
        "id": 546327498,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1761080601
    },
    {
        "content": "<p>Also, I guess given this is part of roc test, technically the entire thing is known at compile time. But generally, most of the errors here would not be know at compile time.</p>",
        "id": 546327731,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1761080708
    }
]