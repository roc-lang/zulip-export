[
    {
        "content": "<p>Hi! I'm starting on function specialization. I'd like to create a test that has the correct input data in it. Since I'm at the veeery beginning of learning, can someone give me an example how I could build up an IR in zig manually (with module Env all that)? Just for example this code:</p>\n<div class=\"codehilite\"><pre><span></span><code>increment = |num| num + 1\n\nmain = || {\n    x = 2\n    increment(x)\n}\n</code></pre></div>\n<p>I will be available after the usual Sunday family dinner :)</p>",
        "id": 499994188,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1739696907
    },
    {
        "content": "<p>The best approach seems to be creating an S-expr parser and printer for each IR</p>",
        "id": 499995222,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739697938
    },
    {
        "content": "<p>We could manually create nodes, but that's probably more trouble than it's worth</p>",
        "id": 499995471,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739698182
    },
    {
        "content": "<p>If you really want to go that way, let me know and I can make a branch with an example</p>",
        "id": 499995692,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739698383
    },
    {
        "content": "<p>I agree a serializable format would be better. I guess there's no need for me to rush straight to tackling specialization, if there are things that would make it easier.</p>",
        "id": 500011710,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1739713156
    },
    {
        "content": "<p>Any chance we can share one printer/parser?</p>",
        "id": 500022213,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739722246
    },
    {
        "content": "<p>Are the IRs similar enough?</p>",
        "id": 500022230,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739722265
    },
    {
        "content": "<p>From a quick look, yes, they seem pretty similar. At least from what I have seen, in function lift and  function solve IR. But after reading Ayas' document, they should be the same as they are just more and more simplified versions of one-another.</p>",
        "id": 500022391,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1739722418
    },
    {
        "content": "<p>I more meant in datastructure form such that a tiny bit of zig comptime could deal with any of them for printing and parsing. And I know they all should have similar datastrtutures. Just not sure if they are close enough in practice.</p>",
        "id": 500022679,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739722674
    },
    {
        "content": "<p>You mean creating a general IRPrinter that can take any of the IR's and spit out the correct strings? (Same for the parse)</p>",
        "id": 500023040,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1739722980
    },
    {
        "content": "<p>Yeah</p>",
        "id": 500023092,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739723038
    },
    {
        "content": "<p>Given we have so many IRs and they are all laid out very similar, sounds doable</p>",
        "id": 500023224,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739723145
    },
    {
        "content": "<p>I see. Would be cool and should strive for it I think! I just started to work on a printer. I'm still in the Zig phase of \"What.. a file is a struct?\", so I don't know when that will be usable. Right now my plan is to create 'serialize' functions on all the base.zig types. They would take a std.io.AnyWriter as argument. Once I can print those, I can widen my horizon.</p>",
        "id": 500023504,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1739723393
    },
    {
        "content": "<p>Sure</p>",
        "id": 500024945,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739724519
    },
    {
        "content": "<p>Exploration is good right now in general</p>",
        "id": 500024952,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739724527
    },
    {
        "content": "<p>My thinking was to create a generic sexpr parser, and have each IR be constructable from that sexpr representation. Similarly for printing - irs only need to know how to output sexpr nodes.</p>",
        "id": 500029687,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1739727956
    },
    {
        "content": "<p>Do I understand it correctly that Sexpr would be an Intermediate representation for all the intermadiate representations during serialization / deserialization <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span> ? So we would go from {check_IR, lift_IR, ...}-&gt;Sexpr-&gt;String and similarly backwards</p>",
        "id": 500030355,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1739728505
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"395097\" href=\"/#narrow/channel/395097-compiler-development/topic/help.20creating.20a.20basic.20IR\">#compiler development &gt; help creating a basic IR</a> by <span class=\"user-mention silent\" data-user-id=\"577599\">Norbert Hajagos</span>.</p>",
        "id": 500030620,
        "sender_full_name": "Notification Bot",
        "timestamp": 1739728705
    },
    {
        "content": "<p>Yep, that was my thought</p>",
        "id": 500030839,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1739728876
    },
    {
        "content": "<p>I like that</p>",
        "id": 500030851,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1739728887
    },
    {
        "content": "<p>That'll let us have one parser and one pretty-printer</p>",
        "id": 500030888,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1739728907
    },
    {
        "content": "<p>How do you think a common printer and parser would be implemented in Zig? I donâ€™t have a clear idea how that would work</p>",
        "id": 500035833,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1739732942
    },
    {
        "content": "<p>Sounds like they were thinking just making a generic intermediate IR. Then having everything go to/from that data structure.</p>",
        "id": 500036194,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739733227
    },
    {
        "content": "<p>Otherwise, you can do interfaces by doing what allocators do with essentially a vtable. Could make one that every ir implements that is used for printing/parsing</p>",
        "id": 500036325,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739733325
    },
    {
        "content": "<p>Lastly, by making comptime interfaces, you essentially have traits from rust</p>",
        "id": 500036355,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739733354
    },
    {
        "content": "<p>When we are spinning this up, if anyone needs help with zig interfaces and what not, let me know. I think if you design the interface as you see fit ignoring zig, I can help translate to zig.</p>",
        "id": 500040106,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739735836
    },
    {
        "content": "<p>I'll be cooking up something then and put progress updates in this thread.</p>",
        "id": 500040622,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1739736237
    },
    {
        "content": "<p>I already have a zig question <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span> <br>\nThe type of base.Literal.String is of collections.interner.StringLiteral <br>\nI wanted to experiment with printing each kind of literal, but the StringLiteral type doesn't seem to hold any value. It's only a namespace for the Idx and the Interner type. I undestand that with the combination of an interner and an index, i can query the string value, but does the current representation of base.Literal.String doesn't have either, so it holds 0 information. </p>\n<p>Should the base.Literal.String be of type collections.interner.StringLiteral.Idx, or am I missing something?</p>",
        "id": 500042083,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1739737505
    },
    {
        "content": "<p>The IRs in those later build stages are mostly a placeholder. It's possible it just doesn't make sense. Im afk rn but can help poke at it in a couple of hours.</p>",
        "id": 500042490,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1739737812
    },
    {
        "content": "<p>Thanks, but in a couple of hours, I'll already be sleeping <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>. Think I'll just change it to Idx, see how things will puzzle out.</p>",
        "id": 500042739,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1739738017
    },
    {
        "content": "<p>Yes, it should be Idx</p>",
        "id": 500042800,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739738051
    },
    {
        "content": "<p>The lazy compilation thing has been pretty tricky for starting this project, though I'm sure it'll not be as annoying in a couple weeks</p>",
        "id": 500042858,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739738109
    },
    {
        "content": "<p>It feels so good to slowly get a hold on what's happening!</p>\n<p>You mean the modules not being connected and thus not checked?</p>",
        "id": 500043009,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1739738224
    },
    {
        "content": "<p>Yep</p>",
        "id": 500043281,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739738432
    },
    {
        "content": "<p>As I was exploring, I stumbled upon a memory leak in the string interner. Fixed it on <a href=\"https://github.com/roc-lang/roc/commit/7672bd7d64fdc45518d6f2fc8cbb1e0e7c23ade9#diff-a6612772b67c70357d50a4668fe4b9eddc1f4b22752213bba61cf4ef2262062b\">my branch</a> (testing allocator is so good, just running <code>zig build test</code> does the job).<br>\nBut... it just feels wrong to loop through strings and free them one-by-one. After all these times of hearing about them, I'm pretty sure this is where I'd need an arena. I tried to wrap the interner's allocator in one, but it kept leaking anyways, so I'm asking if any one of you could guide me here. </p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Faild attempt at using arena:</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">Interner</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">strings</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">.</span><span class=\"n\">ArrayList</span><span class=\"p\">([]</span><span class=\"kt\">u8</span><span class=\"p\">),</span>\n<span class=\"w\">    </span><span class=\"n\">arena</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">.</span><span class=\"n\">heap</span><span class=\"p\">.</span><span class=\"n\">ArenaAllocator</span><span class=\"p\">,</span>\n\n<span class=\"w\">    </span><span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">init</span><span class=\"p\">(</span><span class=\"n\">allocator</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">.</span><span class=\"n\">mem</span><span class=\"p\">.</span><span class=\"n\">Allocator</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">Interner</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"kr\">var</span><span class=\"w\"> </span><span class=\"n\">arena</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">.</span><span class=\"n\">heap</span><span class=\"p\">.</span><span class=\"n\">ArenaAllocator</span><span class=\"p\">.</span><span class=\"n\">init</span><span class=\"p\">(</span><span class=\"n\">allocator</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">Interner</span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"n\">strings</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">.</span><span class=\"n\">ArrayList</span><span class=\"p\">([]</span><span class=\"kt\">u8</span><span class=\"p\">).</span><span class=\"n\">init</span><span class=\"p\">(</span><span class=\"n\">arena</span><span class=\"p\">.</span><span class=\"n\">allocator</span><span class=\"p\">()),</span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"n\">arena</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">arena</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"p\">};</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n\n<span class=\"w\">    </span><span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">deinit</span><span class=\"p\">(</span><span class=\"n\">self</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">Interner</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">arena</span><span class=\"p\">.</span><span class=\"n\">deinit</span><span class=\"p\">();</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n\n<span class=\"w\">    </span><span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"n\">self</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">Interner</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">string</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[]</span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">Idx</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">strings</span><span class=\"p\">.</span><span class=\"n\">items</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">;</span>\n<span class=\"w\">        </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">copied_string</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">arena</span><span class=\"p\">.</span><span class=\"n\">allocator</span><span class=\"p\">().</span><span class=\"n\">alloc</span><span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">string</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">catch</span><span class=\"w\"> </span><span class=\"n\">exitOnOom</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"n\">std</span><span class=\"p\">.</span><span class=\"n\">mem</span><span class=\"p\">.</span><span class=\"n\">copyForwards</span><span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">copied_string</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">string</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">strings</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">copied_string</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">catch</span><span class=\"w\"> </span><span class=\"n\">exitOnOom</span><span class=\"p\">();</span>\n\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">@enumFromInt</span><span class=\"p\">(</span><span class=\"nb\">@as</span><span class=\"p\">(</span><span class=\"kt\">u32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">@intCast</span><span class=\"p\">(</span><span class=\"n\">len</span><span class=\"p\">)));</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n\n<span class=\"w\">    </span><span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">self</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">Interner</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">idx</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Idx</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">[]</span><span class=\"kt\">u8</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">strings</span><span class=\"p\">.</span><span class=\"n\">items</span><span class=\"p\">[</span><span class=\"nb\">@as</span><span class=\"p\">(</span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">@intFromEnum</span><span class=\"p\">(</span><span class=\"n\">idx</span><span class=\"p\">))];</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div>\n</div></div>\n<p>Was a fun weekend on the compiler, tomorrow I'll catch up. Bye!</p>",
        "id": 500051470,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1739745689
    },
    {
        "content": "<p>yeah I think we need arenas for everything, including string interning, so that we can serialize them <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 500051956,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739746091
    },
    {
        "content": "<p>I guess except like...scratch allocations that aren't going to end up being serialized maybe</p>",
        "id": 500051983,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739746133
    },
    {
        "content": "<p>Yep</p>",
        "id": 500051985,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739746138
    },
    {
        "content": "<p>I think having some naming pattern around <code>scratch_arena</code> vs. just <code>arena</code> could help there</p>",
        "id": 500051998,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739746158
    },
    {
        "content": "<p>Since Zig seems to lean into the <code>gpa</code> meaning \"use a general-purpose allocator here\" naming convention</p>",
        "id": 500052017,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739746183
    },
    {
        "content": "<p>yeah I'm not sure if we want gpa or not for those</p>",
        "id": 500052084,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739746210
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"406911\">@Andrew Kelley</span> pointed out that bump arenas are not conducive to arraylists that need to resize because they're super unlikely to be able to resize in-place</p>",
        "id": 500052119,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739746243
    },
    {
        "content": "<p>whereas I guess with a gpa it's more likely</p>",
        "id": 500052136,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739746259
    },
    {
        "content": "<p>I'm not sure how to think about the tradeoffs there <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 500052145,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739746267
    },
    {
        "content": "<p>We want gpa or c allocator for all the arraylists</p>",
        "id": 500055363,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739749130
    },
    {
        "content": "<p>We want arenas for basically everything else</p>",
        "id": 500055376,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739749141
    },
    {
        "content": "<p>For arraylists, the amortization of growing by 1.5 to 2x and reasonable capacity defaults will make it cheap</p>",
        "id": 500055424,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739749198
    },
    {
        "content": "<p>Likely arenas we just have to be careful minorly of lifetimes.</p>",
        "id": 500055515,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739749255
    },
    {
        "content": "<p>Yeah, and I think we should have a pattern of all allocators being named <code>arena</code> or <code>gpa</code>. I guess we could get more fine grain, but that is likely enough by context of the datastructure. Like the parsing arena won't out live the parsing IR.</p>",
        "id": 500055618,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739749325
    },
    {
        "content": "<p>well everything that's going to be serialized needs to use the arena</p>",
        "id": 500055797,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739749459
    },
    {
        "content": "<p>There will be one arena for that which <code>CanIR</code> will own, and it'll get provided to each module's <code>ModuleEnv</code> as their allocator. We should call the allocator for <code>ModuleEnv</code> \"arena\" to make that more obvious</p>",
        "id": 500055959,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739749614
    },
    {
        "content": "<p>And by <code>CanIR</code> owning the arena, then the serialization work just falls out of that for free</p>",
        "id": 500055978,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739749639
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20IR.20serde/near/500055797\">said</a>:</p>\n<blockquote>\n<p>well everything that's going to be serialized needs to use the arena</p>\n</blockquote>\n<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span>??? Why?</p>",
        "id": 500056084,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739749737
    },
    {
        "content": "<p>So <code>parse</code> will intern data into the <code>CanIR</code> arena but put its IR into a different allocator's memory, canonicalize will put its intern data (e.g. generated idents created during desugaring) into the arena</p>",
        "id": 500056087,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739749739
    },
    {
        "content": "<p>If everything is in a single arena, then we get (de)serialization for free</p>",
        "id": 500056108,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739749758
    },
    {
        "content": "<p>They just need to use indices instead or pointers</p>",
        "id": 500056113,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739749763
    },
    {
        "content": "<p>So if there's a single data structure, <code>CanIR</code>, in the arena, which includes the <code>ModuleEnv</code>, then we can just treat that arena as binary data that goes into/out of the cache</p>",
        "id": 500056222,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739749842
    },
    {
        "content": "<p>The ir needs to be in a gpa or you will hit big pains on growth. On top of that, if your arena has tons of gaps, you don't want to serialize it.</p>",
        "id": 500056266,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739749884
    },
    {
        "content": "<p>IR for everything besides canonicalization would be in a GPA</p>",
        "id": 500056287,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739749920
    },
    {
        "content": "<p>I think it is better to think of serialization as writing out a struct containing each of the core arrays of data. Each array only uses indices and not pointers and thus can just be copied to disk.</p>",
        "id": 500056330,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739749927
    },
    {
        "content": "<p>I would not consider serializing arenas. They will have tons of gaps and garbage data from intermediates.</p>",
        "id": 500056376,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739749975
    },
    {
        "content": "<p>Also, references to data in an arena are still pointers (thus not safe to just serialize)</p>",
        "id": 500056393,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739749997
    },
    {
        "content": "<p>There should be no references in the arena, I agree</p>",
        "id": 500056408,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739750024
    },
    {
        "content": "<p>All intermediates besides arraylist's backing arrays should be created within other allocators</p>",
        "id": 500056470,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739750048
    },
    {
        "content": "<p>So a perf question:</p>",
        "id": 500056478,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739750054
    },
    {
        "content": "<p>Which would be faster: creating an <code>mmap</code>ed arena that we don't have to serialize, or using a <code>gpa</code> to get a more compact memory backing for the serialized data and then manually copying to/from the cache?</p>",
        "id": 500056529,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739750114
    },
    {
        "content": "<p>Because I don't think we can just <code>mmap</code> a file in the second case</p>",
        "id": 500056556,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739750137
    },
    {
        "content": "<p>But if it's similar perf, then maybe the arena-based approach isn't worth the effort</p>",
        "id": 500056628,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739750183
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 500056632,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739750186
    },
    {
        "content": "<p>Wrong button clicked...</p>",
        "id": 500056657,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739750211
    },
    {
        "content": "<p>Since it would create a larger cache artifact to use the arena, as you say</p>",
        "id": 500056660,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739750214
    },
    {
        "content": "<p>Meant to edit not delete</p>",
        "id": 500056662,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739750218
    },
    {
        "content": "<p>How I see it working.</p>\n<ol>\n<li>Allocate with gpa for growing things and arenas for everything else. Everything should use indices not pointers.</li>\n<li>Writing out to cache will require moving data to disk and writing everything out flat. Should just be a couple of really big mem copies and quite cheap</li>\n<li>When reloading, growth will not be needed, so can just mmap and then get slices to the correct data for each array.</li>\n</ol>",
        "id": 500056843,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739750365
    },
    {
        "content": "<p>I for sure agree if this approach is about as performant as Richard's idea</p>",
        "id": 500056875,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739750402
    },
    {
        "content": "<p>I've been presuming Richard's way must be faster for us to consider it, but that may very well be wrong</p>",
        "id": 500056996,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739750459
    },
    {
        "content": "<p>so briefly, the whole goal of the serialization is that reading a cache into memory is 2 syscalls: open the file, and then read it into memory. That's it, there's no parsing step whatsoever - once it's in memory, it is already ready to use normally</p>",
        "id": 500057209,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739750552
    },
    {
        "content": "<p>Yes</p>",
        "id": 500057284,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739750632
    },
    {
        "content": "<p>I'm not sure how that works outside of an arena <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 500057361,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739750680
    },
    {
        "content": "<p>Well, you may want to do some minor range processing to get zig slices instead of raw offsets for some things, but that is derived from the raw mmap</p>",
        "id": 500057388,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739750706
    },
    {
        "content": "<p>the thing is, in bigger projects (where compile times are noticeable) reading from cache is going to be overwhelmingly how things get loaded into memory</p>",
        "id": 500057474,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739750764
    },
    {
        "content": "<p>I think you think arenas solve an issue they don't</p>",
        "id": 500057545,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739750799
    },
    {
        "content": "<p>An arena is an linked list of chunks of memory allocated from another allocator</p>",
        "id": 500057589,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739750828
    },
    {
        "content": "<p>Chunks are large and cheap to allocate.</p>",
        "id": 500057610,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739750846
    },
    {
        "content": "<p>oh 100% this doesn't work if the arena is backed by linked list haha</p>",
        "id": 500057614,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739750849
    },
    {
        "content": "<p>has to be big virtual allocations</p>",
        "id": 500057621,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739750854
    },
    {
        "content": "<p>that reallocate and copy if necessary (like an arraylist does), which is fine if everything is indices</p>",
        "id": 500057645,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739750871
    },
    {
        "content": "<p>I guess what I'm trying to say is separate initial construction from cache form.</p>",
        "id": 500057712,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739750891
    },
    {
        "content": "<p>Initial construction will be fastest and easiest to do with large gpa backed arraylists</p>",
        "id": 500057729,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739750910
    },
    {
        "content": "<p>After done, you have a set of slices all using indicies and no pointers.</p>",
        "id": 500057758,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739750944
    },
    {
        "content": "<p>a critical part of the \"2 syscalls\" idea is that the very beginning of the allocation (as in, index zero) has to be the header which holds all the other arraylists (and then from there everything can be indices into those)</p>",
        "id": 500057770,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739750954
    },
    {
        "content": "<p>hm, but I guess writev can guarantee that actually <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 500057784,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739750970
    },
    {
        "content": "<p>Yes, when serializing, you do so flat (header of slice info) then all those slices constructed above with the gpa.</p>\n<p>You serialize flat into a static sized file. This can be loaded with the two syscall approach</p>",
        "id": 500057858,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739751010
    },
    {
        "content": "<p>ok separate question though: if we're running this persistently, and we've loaded something from cache, we explicitly don't want to dealloc everything individually</p>",
        "id": 500057884,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739751039
    },
    {
        "content": "<p>whereas we must do that if it's long-running (e.g. for language server)</p>",
        "id": 500057895,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739751048
    },
    {
        "content": "<p>I guess we can just have a flag of like</p>",
        "id": 500057906,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739751058
    },
    {
        "content": "<p>\"this was loaded from cache, so dealloc it all at once\"</p>",
        "id": 500057923,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739751076
    },
    {
        "content": "<p>You can dealloc at the module level. Each module will have its own mmap or allocators</p>",
        "id": 500057924,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739751076
    },
    {
        "content": "<p>yeah that seems reasonable!</p>",
        "id": 500057935,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739751085
    },
    {
        "content": "<p>separately, I think we'll want to do some giant virtual alloc up front and then read all the cache entries into that</p>",
        "id": 500058023,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739751140
    },
    {
        "content": "<p>well, that's in a batch build I guess</p>",
        "id": 500058080,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739751194
    },
    {
        "content": "<p>prob not language server bc we might need to dealloc those</p>",
        "id": 500058085,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739751200
    },
    {
        "content": "<p>I don't think it will make a difference</p>",
        "id": 500058648,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739751660
    },
    {
        "content": "<p>MMaps are lazily loaded and page fault to load data. Force loading them into one big allocation would force being everything to be copied an extra time.</p>",
        "id": 500058776,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739751782
    },
    {
        "content": "<p>It might be beneficial to load everything into CPU cache early, but if so, we can just force non-lazy loading of the mmaps</p>",
        "id": 500058817,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739751832
    },
    {
        "content": "<p>And due to everything being handled at the page level anyway, doesn't really matter if we have \"scattered\" mmap pages or \"linear\" mmap pages. Both are totally up to the os virtual to physical page map to where they will actually be in memory</p>",
        "id": 500058933,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739751914
    },
    {
        "content": "<p>As a note, the string intern probably needs to be two gpa backed arraylists. One of starts and lengths for the interned strings. And one flat U8 arraylists of string content. That will make serialization easy.</p>\n<p>Aside, does string interning do deduplication if so, it probably also needs an hashmap of string to index it is inserted at. No need to serialize the hashmap cause the string intern will be finalized when serialized to disk.</p>",
        "id": 500059355,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739752273
    },
    {
        "content": "<p>ah interesting, I hadn't been thinking of mmap for these</p>",
        "id": 500059838,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739752726
    },
    {
        "content": "<p>that would change things <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 500059841,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739752733
    },
    {
        "content": "<p>Oh, I thought the point of making a flat serializable datastructure was to enable mmaping them</p>",
        "id": 500061868,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739754373
    },
    {
        "content": "<p>Oh, you mean the string interner specifically?</p>",
        "id": 500061889,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739754396
    },
    {
        "content": "<p>We would either need to serialize the interner or would need to reference the original source to reload the strings</p>",
        "id": 500061945,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739754453
    },
    {
        "content": "<p>I definitely figured we'd be serializing the interner, which would \"own\" the strings within the arena instead of referencing the source file or something</p>",
        "id": 500062037,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739754512
    },
    {
        "content": "<p>Yeah, I agree. Makes sense to do so when serializing can ir.</p>",
        "id": 500062082,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739754565
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20IR.20serde/near/500056843\">said</a>:</p>\n<blockquote>\n<ol start=\"2\">\n<li>Writing out to cache will require moving data to disk and writing everything out flat. Should just be a couple of really big mem copies and quite cheap</li>\n</ol>\n</blockquote>\n<p>btw this can be even cheaper than that! <code>writev</code> can let you skip the memcpys, and there's an equivalent on windows</p>",
        "id": 500062241,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739754682
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20IR.20serde/near/500061868\">said</a>:</p>\n<blockquote>\n<p>Oh, I thought the point of making a flat serializable datastructure was to enable mmaping them</p>\n</blockquote>\n<p>I was just thinking of doing one big <code>read</code> on the whole thing</p>",
        "id": 500062324,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739754728
    },
    {
        "content": "<p>Yeah, that sounds fine too (can test both and see which is faster, minor detail on how the data is loaded)</p>",
        "id": 500062358,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739754761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20IR.20serde/near/500062241\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20IR.20serde/near/500056843\">said</a>:</p>\n<blockquote>\n<ol start=\"2\">\n<li>Writing out to cache will require moving data to disk and writing everything out flat. Should just be a couple of really big mem copies and quite cheap</li>\n</ol>\n</blockquote>\n<p>btw this can be even cheaper than that! <code>writev</code> can let you skip the memcpys, and there's an equivalent on windows</p>\n</blockquote>\n<p>Yeah, I said memcpy, but I really meant a copy to disk. Which would be writeev or whatever system call.</p>",
        "id": 500062392,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739754803
    },
    {
        "content": "<p>mmap on anything not in a tempdir always makes me nervous that some other process is going to delete the file while the mmap is active and cause chaos</p>",
        "id": 500062405,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739754814
    },
    {
        "content": "<p>although wait, didn't you say there's a setting that can prevent that? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 500062425,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739754836
    },
    {
        "content": "<p>Someone deletes the roc cache while we are compiling</p>",
        "id": 500062435,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739754842
    },
    {
        "content": "<p>yeah</p>",
        "id": 500062473,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739754846
    },
    {
        "content": "<p>Yeah, if so, reading is fine. Then less chance for failure at the cost of eagerly loading everything (which could actually be a perf gain, really depends on usage pattern). Could be worse for memory use, but maybe not in any sort of meaningful way.</p>",
        "id": 500062584,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739754950
    },
    {
        "content": "<p>But yeah, read or mmap or etc all sound fine and we can figure out the tradeoffs later.</p>",
        "id": 500062657,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739754984
    },
    {
        "content": "<p>Sounds like mmap counts as an extra reference count on a file and it won't actually be deleted until the mmaps is closed (on Linux)</p>",
        "id": 500062869,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739755167
    },
    {
        "content": "<p><a href=\"https://stackoverflow.com/questions/42961339/mmap-after-deleting-the-file#50376124\">https://stackoverflow.com/questions/42961339/mmap-after-deleting-the-file#50376124</a></p>",
        "id": 500062870,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739755168
    },
    {
        "content": "<p>So deleting it will remove it from the file tree, but the lnode wont be deleted until the file is until it is safe</p>",
        "id": 500062937,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739755206
    },
    {
        "content": "<p>Would definitely want to test that behaviour to make sure or look it up in docs somewhere</p>",
        "id": 500062959,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739755223
    },
    {
        "content": "<p>Oh, though mutation on an mmaped file still may affect things, but if a user is mutating cache files, that is their own problem</p>",
        "id": 500063133,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739755361
    },
    {
        "content": "<p>yeah I agree</p>",
        "id": 500063158,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739755385
    },
    {
        "content": "<p>mutating cache files is UB anyway</p>",
        "id": 500063198,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739755427
    },
    {
        "content": "<p>regardless of when you do it</p>",
        "id": 500063210,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739755435
    },
    {
        "content": "<p>(in this case)</p>",
        "id": 500063217,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739755440
    },
    {
        "content": "<p>but deleting cache files should always be safe</p>",
        "id": 500063263,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739755451
    },
    {
        "content": "<p>so that sounds like a great option to me!</p>",
        "id": 500063276,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739755461
    },
    {
        "content": "<p>in that design the 2 syscalls are <code>open</code> and <code>mmap</code>, and then afterwards we can <code>munmap</code> if we're a language server and want to selectively clean up</p>",
        "id": 500063365,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739755542
    },
    {
        "content": "<p>this sounds awesome <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 500063370,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739755548
    },
    {
        "content": "<p>Yep</p>",
        "id": 500063605,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739755700
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/channel/395097-compiler-development/topic/zig.20compiler.20-.20IR.20serde/near/500055515\">said</a>:</p>\n<blockquote>\n<p>Likely arenas we just have to be careful minorly of lifetimes.</p>\n</blockquote>\n<p>ArrayList didn't grow this debug feature yet but some of the data structures such as hash maps have \"pointer locks\", so if you want to keep element pointers alive for a nontrivial amount of function call graph, you can do something like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>map.lockPointers();\ndefer map.unlockPointers();\n</code></pre></div>\n<p>and it will crash if you called any of the non \"assume capacity\" methods. i.e. you get a crash instead of potential Use-After-Free</p>\n<p>in release fast mode those are no-ops.</p>",
        "id": 500073840,
        "sender_full_name": "Andrew Kelley",
        "timestamp": 1739762960
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/channel/395097-compiler-development/topic/zig.20compiler.20-.20IR.20serde/near/500057361\">said</a>:</p>\n<blockquote>\n<p>I'm not sure how that works outside of an arena <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n</blockquote>\n<p><a href=\"https://codeberg.org/andrewrk/groovebasin/src/commit/9022521c445c2ba398f2f646aa24241ecd1a715a/shared/Db.zig#L576-L634\">like this</a></p>",
        "id": 500074000,
        "sender_full_name": "Andrew Kelley",
        "timestamp": 1739763064
    },
    {
        "content": "<p>Thanks</p>",
        "id": 500074549,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739763553
    },
    {
        "content": "<p>Yeah, that matches what I expected</p>",
        "id": 500074554,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739763559
    },
    {
        "content": "<p>Also, cool debug feature</p>",
        "id": 500074558,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739763565
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/channel/395097-compiler-development/topic/zig.20compiler.20-.20IR.20serde/near/500059355\">said</a>:</p>\n<blockquote>\n<p>As a note, the string intern probably needs to be two gpa backed arraylists. One of starts and lengths for the interned strings. And one flat U8 arraylists of string content. That will make serialization easy.</p>\n<p>Aside, does string interning do deduplication if so, it probably also needs an hashmap of string to index it is inserted at. No need to serialize the hashmap cause the string intern will be finalized when serialized to disk.</p>\n</blockquote>\n<p>This is the comment above the StringLiteral.Interner:</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"c1\">/// As opposed to the [IdentName.Interner], this interner does not</span>\n<span class=\"c1\">/// deduplicate its values because they are expected to be almost all unique,</span>\n<span class=\"c1\">/// and also larger, meaning more expensive to do equality checking on.</span>\n</code></pre></div>\n<p>I also thought of something similar, since the strings won't be changing in the buffer. How do you feel about a design like this?</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"c1\">// just after inicialization</span>\n<span class=\"n\">expect</span><span class=\"w\"> </span><span class=\"n\">interner</span><span class=\"p\">.</span><span class=\"n\">buff</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"s\">\"\"</span>\n<span class=\"n\">expect</span><span class=\"w\"> </span><span class=\"n\">interner</span><span class=\"p\">.</span><span class=\"n\">start_positions</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n\n<span class=\"c1\">//inserting 2 strings</span>\n<span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">hi_idx</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">interner</span><span class=\"p\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s\">\"hi\"</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// 0</span>\n<span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">there_idx</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">interner</span><span class=\"p\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s\">\"there\"</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// 1</span>\n\n<span class=\"c1\">//results with</span>\n<span class=\"n\">expect</span><span class=\"w\"> </span><span class=\"n\">interner</span><span class=\"p\">.</span><span class=\"n\">buff</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"s\">\"hithere\"</span>\n<span class=\"n\">expect</span><span class=\"w\"> </span><span class=\"n\">interner</span><span class=\"p\">.</span><span class=\"n\">start_positions</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"p\">]</span>\n\n<span class=\"c1\">// no need to store start and length, since the next value in start_positions holds where the string ends</span>\n<span class=\"n\">expect</span><span class=\"w\"> </span><span class=\"n\">interner</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">there_idx</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">interner</span><span class=\"p\">.</span><span class=\"n\">buff</span><span class=\"p\">[</span><span class=\"n\">interner</span><span class=\"p\">.</span><span class=\"n\">start_positions</span><span class=\"p\">[</span><span class=\"n\">there_idx</span><span class=\"p\">]..</span><span class=\"n\">interner</span><span class=\"p\">.</span><span class=\"n\">start_positions</span><span class=\"p\">[</span><span class=\"n\">there_idx</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">]]</span>\n</code></pre></div>\n<p>Would be happy to implement it. What type should the start_positions arraylist hold? If only string literals from source code will be in the interner, u32 would be enough. Source files with &gt; 4Gb str literals aren't realistic imo. However, if we stored embedded files in these as well (think <code>import \"some-file\" as some_str : Str</code>) then I'd use a <code>usize</code> just in case. I'm easily convinced it's an overkill though.</p>",
        "id": 500139568,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1739787310
    },
    {
        "content": "<p>null termination is viable as well. with short strings the cpu cache savings can be worth it</p>",
        "id": 500148025,
        "sender_full_name": "Andrew Kelley",
        "timestamp": 1739789281
    },
    {
        "content": "<p>Or a previous strategy Iâ€™ve seen, of prepending the string with a varint length, encoded backwards, and placed before the offset you return.</p>",
        "id": 500155574,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1739791096
    },
    {
        "content": "<p>Cool! Could do either. <span class=\"user-mention\" data-user-id=\"453336\">@Joshua Warner</span> do you think storing the length that way would be beneficial over having null terminated strings?</p>",
        "id": 500170603,
        "sender_full_name": "Norbert Hajagos",
        "timestamp": 1739795006
    },
    {
        "content": "<p>The advantage would be in making computing the length of strings &gt;= ~64 bytes (a cache line) faster</p>",
        "id": 500222092,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1739806849
    },
    {
        "content": "<p>(that said, I think it's unlikely we'll have many identifiers &gt;= 64 bytes, so <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> )</p>",
        "id": 500222215,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1739806881
    },
    {
        "content": "<p>This is the string literal Interner. We will have some large ones</p>",
        "id": 500225008,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739807528
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"577599\">Norbert Hajagos</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20IR.20serde/near/500139568\">said</a>:</p>\n<blockquote>\n<p>Would be happy to implement it. What type should the start_positions arraylist hold? If only string literals from source code will be in the interner, u32 would be enough. Source files with &gt; 4Gb str literals aren't realistic imo. However, if we stored embedded files in these as well (think <code>import \"some-file\" as some_str : Str</code>) then I'd use a <code>usize</code> just in case. I'm easily convinced it's an overkill though.</p>\n</blockquote>\n<p>I think we should handle imported sources special and just never put them in interners. That would be a waste. And since the interners are per module, the strings from a single module can never be over 4GB.</p>",
        "id": 500227622,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739808167
    },
    {
        "content": "<p>should literals be interned at all? I don't see the benefit honestly <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 500247449,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739813757
    },
    {
        "content": "<p>Only benefit is that you can close files....so maybe not worth it.</p>",
        "id": 500247557,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739813796
    },
    {
        "content": "<p>Might be better to just reference back to the original file</p>",
        "id": 500247582,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739813812
    },
    {
        "content": "<p>I guess also maybe minor cache gains later in the compiler</p>",
        "id": 500247632,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739813837
    },
    {
        "content": "<p>But yeah, I think the only real gain is if it saves a lot of memory in large roc projects due to being able to free files.</p>",
        "id": 500247786,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739813916
    },
    {
        "content": "<p>Presumably we would want to serialize that data with the can IR (or whatever else we're caching)</p>",
        "id": 500252735,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1739816071
    },
    {
        "content": "<p>That way we only have to read the can IR and not the original file (e.g. supposing we're confident it hasn't changed - and assuming we didn't need to hash it to figure that out)</p>",
        "id": 500252828,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1739816120
    },
    {
        "content": "<p>we already have to read the original file into memory in order to hash it, because the hash is the key for the cached can IR</p>",
        "id": 500253051,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739816227
    },
    {
        "content": "<p>and the can IR is a hash of the source bytes, so we know all the offsets into the source file will still be valid! <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 500253082,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739816249
    },
    {
        "content": "<p>IMO we ought to skip hashing most of the time</p>",
        "id": 500253101,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1739816259
    },
    {
        "content": "<p>That sort of thing can really matter for large projects</p>",
        "id": 500253137,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1739816282
    },
    {
        "content": "<p>(this is exactly what git does - it doesn't rehash all files in your git dir every time you commit - only the ones that have a different stat)</p>",
        "id": 500253254,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1739816320
    },
    {
        "content": "<p>If we can only read one file (the can ir), and not seek the disk to read the original file again, that's a substantial speed boost</p>",
        "id": 500253512,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1739816442
    },
    {
        "content": "<p>Note: this is the kind of thing that is super easy to change later</p>",
        "id": 500260855,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739819952
    },
    {
        "content": "<p>So either way we go should be fine.</p>",
        "id": 500260871,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739819964
    },
    {
        "content": "<p>But yeah, especially on a HDD, reading only one could be big gains</p>",
        "id": 500260978,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739820016
    },
    {
        "content": "<p>I'm not sure how we could skip it <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 500263288,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739821261
    },
    {
        "content": "<p>like if the CLI receives an instruction to check <code>main.roc</code>, how would it know what cached IR to load without reading and hashing the source bytes?</p>",
        "id": 500263455,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739821351
    },
    {
        "content": "<p>(it's different if it's a persistent process that's watching the filesystem for changes, of course)</p>",
        "id": 500263495,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739821379
    },
    {
        "content": "<p>Oh yeah, the hash of the file is the key to the cache.</p>",
        "id": 500267032,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739822988
    },
    {
        "content": "<p>So hashing is required unless we come up with a different key</p>",
        "id": 500267039,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739822999
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"453336\">Joshua Warner</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20IR.20serde/near/500155574\">said</a>:</p>\n<blockquote>\n<p>Or a previous strategy Iâ€™ve seen, of prepending the string with a varint length, encoded backwards, and placed before the offset you return.</p>\n</blockquote>\n<p>This never occured to me. Cool idea!</p>",
        "id": 500305405,
        "sender_full_name": "Andrew Kelley",
        "timestamp": 1739845172
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20IR.20serde/near/500247449\">said</a>:</p>\n<blockquote>\n<p>should literals be interned at all? I don't see the benefit honestly <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n</blockquote>\n<p>In zig we do it because it helps simplify our memory model, particularly with serialization</p>",
        "id": 500305525,
        "sender_full_name": "Andrew Kelley",
        "timestamp": 1739845233
    },
    {
        "content": "<p>I must be missing something because I don't see the connection with files</p>",
        "id": 500305569,
        "sender_full_name": "Andrew Kelley",
        "timestamp": 1739845262
    },
    {
        "content": "<p>if the literal doesn't have any escapes in it, you can just store the region in the original source file<br>\nbecause those are the exact bytes you want anyway</p>",
        "id": 500305924,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739845485
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20IR.20serde/near/500263455\">said</a>:</p>\n<blockquote>\n<p>like if the CLI receives an instruction to check <code>main.roc</code>, how would it know what cached IR to load without reading and hashing the source bytes?</p>\n</blockquote>\n<p>Have a cache file per source file path, and store the size, mtime, inode.  If any of those change, cache miss. We do this in zig for source -&gt; ZIR</p>",
        "id": 500305934,
        "sender_full_name": "Andrew Kelley",
        "timestamp": 1739845493
    },
    {
        "content": "<p>Oh, we don't have source files, tokens, or ast nodes loaded at all in the happy path</p>",
        "id": 500305987,
        "sender_full_name": "Andrew Kelley",
        "timestamp": 1739845527
    },
    {
        "content": "<p>we could do the size/mtime/inode/etc as an extra layer, but if any of those change we still have to redo the hash computation</p>",
        "id": 500306024,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739845562
    },
    {
        "content": "<p>so the tradeoff for the cache hit scenario would be:</p>\n<ul>\n<li>\"always hash\" means in the happy path where we're getting a cache hit, we just read the file and hash it and then proceed</li>\n<li>\"size/mtime/inode/etc\" means in the happy path we do strictly more work, because we check those things and then calculate the hash anyway</li>\n</ul>\n<p>in the cache miss scenario, we might discover that we need to re-hash sooner...but then the first thing we do in a cache miss is hash anyway, to know what to name the new cache file <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 500306225,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739845682
    },
    {
        "content": "<p>so I guess another way to say it is that we re-hash whether there's going to be a cache miss or cache hit, so might as well just always do it, yeah?</p>",
        "id": 500306289,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739845712
    },
    {
        "content": "<p>I think you should be able to avoid rehashing when you have a hit</p>",
        "id": 500306403,
        "sender_full_name": "Andrew Kelley",
        "timestamp": 1739845795
    },
    {
        "content": "<p>In our case it would be extremely wasteful since we don't even need access to the file contents on a cache hit</p>",
        "id": 500306484,
        "sender_full_name": "Andrew Kelley",
        "timestamp": 1739845823
    },
    {
        "content": "<p>Maybe I'm not understanding what you mean when you say \"hash\". Are you talking about the file contents?</p>",
        "id": 500306551,
        "sender_full_name": "Andrew Kelley",
        "timestamp": 1739845869
    },
    {
        "content": "<p>I vaguely recall something about assigning a unique integer per identifier across all source files or something like that. I'm guessing that's what you mean by \"hash\"</p>",
        "id": 500307183,
        "sender_full_name": "Andrew Kelley",
        "timestamp": 1739846299
    },
    {
        "content": "<p>by hash I specifically mean a BLAKE3 hash of the entire contents of the <code>.roc </code>source file</p>",
        "id": 500307405,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739846451
    },
    {
        "content": "<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> how do we know we have a hit without rehashing though?</p>",
        "id": 500307439,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739846479
    },
    {
        "content": "<p>(mtime, inode, size) is generally considered to be reliable enough. As a bonus you can try to detect mtime granularity and avoid false positives in case the file system has high granularity (i.e. NFS, which nobody should be using)</p>",
        "id": 500308483,
        "sender_full_name": "Andrew Kelley",
        "timestamp": 1739847254
    },
    {
        "content": "<p>fstat cache hits are going to be a lot faster than hashing cache hits. Especially if you don't need to load the file contents on hit</p>",
        "id": 500308577,
        "sender_full_name": "Andrew Kelley",
        "timestamp": 1739847350
    },
    {
        "content": "<p>If we intern string literals, then I'm pretty sure we wouldn't need anything from the source file, just the cache contents</p>",
        "id": 500308710,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739847427
    },
    {
        "content": "<p>Unless there are compiler errors and we need to show diagnostics based on regions in the source, of course</p>",
        "id": 500308733,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739847450
    },
    {
        "content": "<p>gotcha, yeah that's a reasonable argument for layering a (mtime, inode, size) cache on top of the BLAKE3 hash cache, to avoid reading the files and BLAKE3-ing them unnecessarily in the happy path case <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 500308849,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739847538
    },
    {
        "content": "<p>I don't think we need to do any special design work for that now - can add that on sometime after 0.1.0</p>",
        "id": 500308880,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739847554
    },
    {
        "content": "<p>but it is a good argument for not assuming we have the source bytes in memory</p>",
        "id": 500308899,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739847572
    },
    {
        "content": "<p>so yeah, maybe just interning them is simplest haha</p>",
        "id": 500308956,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739847603
    },
    {
        "content": "<p>(them being literals)</p>",
        "id": 500308992,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739847610
    },
    {
        "content": "<p>It's simpler for 0.1.0 as well</p>",
        "id": 500309021,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739847629
    },
    {
        "content": "<p>But not <em>that</em> much simpler</p>",
        "id": 500309068,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739847646
    },
    {
        "content": "<p>interning literals?</p>",
        "id": 500309159,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1739847721
    },
    {
        "content": "<p>Yes</p>",
        "id": 500309881,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739848243
    },
    {
        "content": "<p>We can differentiate between interning (ensuring we have one unique copy of each) and just copying them</p>",
        "id": 500312331,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1739850143
    },
    {
        "content": "<p>The latter is what we need to avoid re-reading the source file</p>",
        "id": 500312349,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1739850161
    },
    {
        "content": "<p>The former is potentially a small binary size optimization, but this is probably the wrong layer to do that at</p>",
        "id": 500312379,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1739850188
    },
    {
        "content": "<p>We need to ensure symbols are unique, but I don't see any particular reason we need to guarantee strings are</p>",
        "id": 500312395,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1739850209
    },
    {
        "content": "<p>I'm talking about just copying, not interning, good distinction</p>",
        "id": 500313521,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1739851028
    },
    {
        "content": "<p>Yeah, string interner doesn't deduplicate</p>",
        "id": 500317752,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739853831
    },
    {
        "content": "<p>It could, but unnecessary for the most part</p>",
        "id": 500317763,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1739853840
    },
    {
        "content": "<p>I've made a draft PR with an initial implementation of Parser AST -&gt; SExpr</p>\n<p><a href=\"https://github.com/roc-lang/roc/pull/7629\">https://github.com/roc-lang/roc/pull/7629</a></p>\n<p>It doesn't really do a whole lot right now... but it compiles and runs <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span> </p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"k\">test</span><span class=\"w\"> </span><span class=\"s\">\"example s-expr\"</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">source</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\module []</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\foo = \"bar\"</span>\n<span class=\"w\">    </span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\(header statement)</span>\n<span class=\"w\">    </span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"k\">try</span><span class=\"w\"> </span><span class=\"n\">testHelper</span><span class=\"p\">(</span><span class=\"n\">testing</span><span class=\"p\">.</span><span class=\"n\">allocator</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">source</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 501228789,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740201253
    },
    {
        "content": "<p>Intention will be to make it generate snapshots somehow... but while I'm developing the IR and wiring it up I'll probably use a unit test.</p>",
        "id": 501228818,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740201295
    },
    {
        "content": "<p>After going down this road a bit further... I'm thinking this may be the wrong approach.</p>",
        "id": 501312927,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740267492
    },
    {
        "content": "<p>The issue is how to work with the nested nodes and our SoA structure.</p>",
        "id": 501312951,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740267521
    },
    {
        "content": "<p>I'm going to try just using the standard zig <code>format</code></p>",
        "id": 501312960,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740267536
    },
    {
        "content": "<p>That does mean we are providing a <code>std.io.Writer</code>, but I assume there is a way for that to not allocate, like maybe a heap allocated writer or similar.</p>",
        "id": 501313011,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740267602
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"453336\">@Joshua Warner</span> <span class=\"user-mention\" data-user-id=\"781658\">@Anthony Bullard</span> </p>\n<p>How should I be getting the ident strings back out of the Parser AST? </p>\n<p>I'm reasonably sure we just haven't got to this part yet, but wondering where the interned strings would be. </p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"c1\">/// Represents a Pattern used in pattern matching.</span>\n<span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">Pattern</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">union</span><span class=\"p\">(</span><span class=\"k\">enum</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">ident</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">ident_tok</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">TokenIdx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">// &lt;--- should this be an interned Ident.Idx instead?</span>\n<span class=\"w\">        </span><span class=\"n\">region</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Region</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"p\">},</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">Token</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">tag</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Tag</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"n\">offset</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"n\">extra</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Extra</span><span class=\"p\">,</span>\n\n<span class=\"w\">    </span><span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">Extra</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">union</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">length</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"n\">interned</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">base</span><span class=\"p\">.</span><span class=\"n\">Ident</span><span class=\"p\">.</span><span class=\"n\">Idx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&lt;---</span><span class=\"w\"> </span><span class=\"k\">or</span><span class=\"w\"> </span><span class=\"n\">should</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">pulling</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"n\">from</span><span class=\"w\"> </span><span class=\"n\">here</span><span class=\"o\">??</span>\n<span class=\"w\">    </span><span class=\"p\">};</span>\n</code></pre></div>",
        "id": 501315227,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740269666
    },
    {
        "content": "<p>Or maybe using the <code>offset</code> and <code>length</code> and just indexing from the source bytes</p>",
        "id": 501315270,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740269723
    },
    {
        "content": "<p>Or maybe I should be using the <code>Region</code> somehow</p>",
        "id": 501315390,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740269851
    },
    {
        "content": "<p>Ok, yeah I'm pretty sure I should be grabbing them from the <code>ModuleEnv</code> using the <code>Ident.Idx</code>. So I'll need to take the env as an argument for the formatting helper.</p>",
        "id": 501315928,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740270312
    },
    {
        "content": "<p>Yeah you can fetch indents from the ModuleEnv</p>",
        "id": 501316347,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1740270689
    },
    {
        "content": "<p>Strings and numbers and such youâ€™ll have to fetch from the source for now, but my plan is to also stash those somewhere, possibly on the ModuleEnv</p>",
        "id": 501316424,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1740270729
    },
    {
        "content": "<p>Ok got something working. Just building out more of the structure for a minimal SExpr test</p>",
        "id": 501317313,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740271600
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"453336\">@Joshua Warner</span> I've currently got the Can IR assuming that we have <code>StringLiteral.Idx</code> for the text of numbers as well as strings: <a href=\"https://github.com/roc-lang/roc/blob/7fc2a08e2811fed7207ab5035f680bbf697d232f/src/check/canonicalize/IR.zig#L88\">https://github.com/roc-lang/roc/blob/7fc2a08e2811fed7207ab5035f680bbf697d232f/src/check/canonicalize/IR.zig#L88</a></p>",
        "id": 501319530,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1740273597
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515757\">Luke Boswell</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20IR.20serde/near/501312927\">said</a>:</p>\n<blockquote>\n<p>After going down this road a bit further... I'm thinking this may be the wrong approach.</p>\n</blockquote>\n<p>Would be glad to chat about this design space at some point or help with implementation issues. Overall, the perf isn't too important. Though good perf will help with fuzzing</p>",
        "id": 501330023,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740281617
    },
    {
        "content": "<p>It was more a reflection on my <code>SExpr</code> \"library\" and how I had planned to map between the IR's and that to generate a string. </p>\n<p>My new approach is to make a <code>toStr</code> helper for things that can be implemented at each level in the IR (but still has the global SoA context). Probably a terrible description -- but I'll get something minimal working soon and share my PR for comments/review.</p>",
        "id": 501330636,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740282227
    },
    {
        "content": "<p>Basically I'm experimenting with ways to do it as I haven't built something like this before.</p>",
        "id": 501330702,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740282266
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"343810\">@Brendan Hansknecht</span> interested to know what you think of this <a href=\"https://github.com/roc-lang/roc/pull/7629\">https://github.com/roc-lang/roc/pull/7629</a></p>\n<p>Currently have this test passing.</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"k\">test</span><span class=\"w\"> </span><span class=\"s\">\"example s-expr\"</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">source</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\module [foo, bar]</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\foo = \"hey\"</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\bar = \"yo\"</span>\n<span class=\"w\">    </span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\(parse_ast (header \"module\" (exposes (\"foo\" \"bar\"))) (statements (decl (pattern (ident \"foo\")) (body ((expr \"hey\")))) (decl (pattern (ident \"bar\")) (body ((expr \"yo\"))))))</span>\n<span class=\"w\">    </span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"k\">try</span><span class=\"w\"> </span><span class=\"n\">testSExprHelper</span><span class=\"p\">(</span><span class=\"n\">testing</span><span class=\"p\">.</span><span class=\"n\">allocator</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">source</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 501333617,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740284914
    },
    {
        "content": "<p>Basic idea is to implement the following for various levels of the IR hierarchy and just call it recursively writing out the AST as it goes.</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">toStr</span><span class=\"p\">(</span><span class=\"n\">ir</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"nb\">@This</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">base</span><span class=\"p\">.</span><span class=\"n\">ModuleEnv</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">writer</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">.</span><span class=\"n\">io</span><span class=\"p\">.</span><span class=\"n\">AnyWriter</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">}</span>\n</code></pre></div>",
        "id": 501333754,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740285035
    },
    {
        "content": "<p>Ah, but then you have to separately make a parser for every ir? Well, I guess the parser isn't strictly required. Just nice to have</p>",
        "id": 501337330,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740288257
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"343810\">@Brendan Hansknecht</span> I was heading in the direction of having a separate SExpr IR -- see <a href=\"https://github.com/roc-lang/roc/blob/c72993c7519188698937bcc359d15e5b032ebe78/src/check/parse/SExpr.zig\">https://github.com/roc-lang/roc/blob/c72993c7519188698937bcc359d15e5b032ebe78/src/check/parse/SExpr.zig</a> for an example. </p>\n<p>This approach with <code>toStr</code> is my second attempt but taking a different direction. </p>\n<p>I'm not sure how important it will be for parsing these IR's. That seems to be a tangental requirement in the nice to have category -- but also feels like a rabbit hole in itself. </p>\n<p>I can appreciate the idea of build a list of tokens instead of writing directly to a buffer -- I was thinking this enables us to implement checks to ensure everything is well formed. </p>\n<p>I am not opposed to returning to try the SExpr IR idea again, I think I would simplify it a littler further, only have the \"node\" itself a comptime type variable.</p>",
        "id": 501414359,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740348276
    },
    {
        "content": "<p>Why does anything need comptime? (I think the comptime free IR I shared on the PR should be enough)</p>",
        "id": 501414491,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740348367
    },
    {
        "content": "<blockquote>\n<p>I'm not sure how important it will be for parsing these IR's. That seems to be a tangental requirement in the nice to have category -- but also feels like a rabbit hole in itself.</p>\n</blockquote>\n<p>I don't think we need to write any of the parsing right now. I think we can just write a basic node type, conversion logic from parse ir to that basic node type, and a printer.</p>",
        "id": 501414731,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740348584
    },
    {
        "content": "<p>I think it could be super minimal</p>",
        "id": 501414738,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740348589
    },
    {
        "content": "<p>Cause the sexpr ir should be trivial to print</p>",
        "id": 501414799,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740348616
    },
    {
        "content": "<p>(and pretty trivial to parse too)</p>",
        "id": 501414810,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740348626
    },
    {
        "content": "<p>Yeah it's easy to do. I did the first version like that (without comptime).</p>",
        "id": 501414856,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740348673
    },
    {
        "content": "<p>All this said, I don't want to block anything, but I don't understand the issue with a super simple sexpr ir as an intermediate.</p>",
        "id": 501414889,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740348717
    },
    {
        "content": "<p>I added the comptime so you could pass in a \"parser\" function to take the <code>[]u8</code> and give you back the nodes you expect -- or an error if it didn't recognise the node string</p>",
        "id": 501414891,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740348719
    },
    {
        "content": "<p>There's no issue. I'm just exploring the design space a little.</p>",
        "id": 501414965,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740348762
    },
    {
        "content": "<p>Oh, I would just separately parse to sexpr ir, then simply pattern match on sexpr ir to convert to the parse ir.</p>",
        "id": 501414973,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740348772
    },
    {
        "content": "<p>so parsing sexpr ir would accept all node types and names. Only the final conversion would invalidate specific like node types</p>",
        "id": 501415011,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740348816
    },
    {
        "content": "<p>That's probably simpler than where I was going. <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 501415018,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740348827
    },
    {
        "content": "<p>to use sexprs to build IRs for later stages (anything after solve), then will it need to parse nodes that contain type information as well?</p>",
        "id": 501436674,
        "sender_full_name": "Jared Ramirez",
        "timestamp": 1740366397
    },
    {
        "content": "<p>Likely</p>",
        "id": 501436792,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740366486
    },
    {
        "content": "<p>Though we can make type info a child node or side band if necessary (as long as we make a way to print it)</p>",
        "id": 501436829,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740366526
    },
    {
        "content": "<p>Or if may be the case that we don't support parsing later IRs and they simply print in a lossy form. Haven't fully thought through this</p>",
        "id": 501436892,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740366592
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/channel/395097-compiler-development/topic/zig.20compiler.20-.20IR.20serde/near/501436892\">said</a>:</p>\n<blockquote>\n<p>Or if may be the case that we don't support parsing later IRs and they simply print in a lossy form. Haven't fully thought through this</p>\n</blockquote>\n<p>I've been thinking along these lines as one of the reasons why we may not want to \"parse\" the IR's.</p>",
        "id": 501440993,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740369622
    },
    {
        "content": "<p>The other thought is that these SExpr IR's aren't very nice to read. I'm starting to think it might be nicer just to make something more human readable that is unique for each IR that just includes the context relevant for that stage.</p>",
        "id": 501441043,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740369662
    },
    {
        "content": "<p>ï¿¼ <span class=\"user-mention silent\" data-user-id=\"515757\">Luke Boswell</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20IR.20serde/near/501441043\">said</a>:</p>\n<blockquote>\n<p>The other thought is that these SExpr IR's aren't very nice to read. I'm starting to think it might be nicer just to make something more human readable that is unique for each IR that just includes the context relevant for that stage.</p>\n</blockquote>\n<p>I was thinking a similar thing as Iâ€™ve been hand-writing some IRs (while exploring the function solving stage). It seems like sexprs that contain ast _plus_ type info could get in unwieldy.</p>",
        "id": 501443269,
        "sender_full_name": "Jared Ramirez",
        "timestamp": 1740370555
    },
    {
        "content": "<p>And each stage has different data, so thereâ€™s one main parser, it would need to support a bunch of nodes that are maybe only applicable to a single stage</p>",
        "id": 501444320,
        "sender_full_name": "Jared Ramirez",
        "timestamp": 1740371052
    },
    {
        "content": "<p>My thinking was to do sexprs with perhaps some tasteful extensions. Keep it simple to print and parse but perhaps slightly less verbose</p>",
        "id": 501445531,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1740371950
    },
    {
        "content": "<p>I guess I see a two way split. I think it is fine to either:</p>\n<ol>\n<li>Go the way of the old compiler, just have pretty printing, and make it special per IR (give up parsing)</li>\n<li>Use s expression and for at least the high level IRs, but maybe all IRs eventually add parsing.</li>\n</ol>\n<p>Just depends on our exact goals.</p>",
        "id": 501446095,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740372389
    },
    {
        "content": "<p>Goal one is definitely snapshot tests (which requires printing and some reliability, but doesn't need to be perfect).</p>",
        "id": 501446128,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740372430
    },
    {
        "content": "<p>Goal two is parsing for better fuzzing (probably also requires verification, which may actually not be reasonable).</p>",
        "id": 501446176,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740372479
    },
    {
        "content": "<p>I think we could minorly expand expressions to support types and that would be reasonable (something to worry about later)</p>",
        "id": 501446261,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740372546
    },
    {
        "content": "<p>So I would argue that s expressions leave more open for future improvements</p>",
        "id": 501446385,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740372634
    },
    {
        "content": "<p>That said, the simplicity of bespoke printing and no parsing is also reasonable as long as we try to be consistent with printing.</p>",
        "id": 501446428,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740372680
    },
    {
        "content": "<p>I definitely still lean s expr currently.</p>",
        "id": 501446454,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740372718
    },
    {
        "content": "<p>I've got something simple that is working ok. I'm going to continue with converting it into some small snapshots and trying a simple heuristic for pretty printing. </p>\n<p>I'm busy all day tomorrow, but should be able to make some progress later in the week.</p>",
        "id": 501477161,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740386106
    },
    {
        "content": "<p>I've updated my PR and would like to merge what I have to prevent it going stale again. </p>\n<p>I haven't quite figured out how to get the string parts back to working  yet, but the rest is working well. </p>\n<p>I also added an option to give either compact or pretty formatted strings. So now our unit test looks like this.</p>\n<p>The next step is to generate actual snapshot files instead of having a unit test. But I'm pretty happy now with the API I think.</p>\n<p><span class=\"user-mention\" data-user-id=\"343810\">@Brendan Hansknecht</span> can you cast your eye over my implementation - particularly the <code>children: std.ArrayListUnmanaged(Node)</code> part... <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span> </p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"k\">test</span><span class=\"w\"> </span><span class=\"s\">\"example s-expr\"</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">source</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\module [foo, bar]</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\foo = \"hey\"</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\bar = \"yo\"</span>\n<span class=\"w\">    </span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\(file</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\    (header</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\        'foo'</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\        'bar')</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\    (decl</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\        (ident</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\            'foo')</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\        (string_part))</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\    (decl</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\        (ident</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\            'bar')</span>\n<span class=\"w\">        </span><span class=\"sh\">\\\\        (string_part)))</span>\n<span class=\"w\">    </span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"k\">try</span><span class=\"w\"> </span><span class=\"n\">testSExprHelper</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 502495778,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740718849
    },
    {
        "content": "<p>Ok, I've had a crack at an initial implementation for a tool to run through all the snapshot files... <a href=\"https://github.com/roc-lang/roc/pull/7644\">https://github.com/roc-lang/roc/pull/7644</a></p>\n<p>This PR adds a snapshot tool that iterates through all the snapshot text files in <code>src/snapshots/*.txt</code> and re-generates the AST/IR's for each compiler stage.</p>\n<div class=\"codehilite\"><pre><span></span><code>$ zig build snapshot\ninfo: processed 2 snapshots in 1ms.\n$ zig build snapshot -- --verbose\ninfo: src/snapshots/002.txt\ninfo: src/snapshots/001.txt\ninfo: processed 2 snapshots in 2ms.\n</code></pre></div>\n<p>Here is an example of a snapshot file.</p>\n<div class=\"codehilite\"><pre><span></span><code>~~~META\ndescription=Basic example to develop the snapshot methodology\n~~~SOURCE\nmodule [foo, bar]\nfoo = &quot;one&quot;\nbar = &quot;two&quot;\n~~~PARSE\n(file\n    (header\n        &#39;foo&#39;\n        &#39;bar&#39;)\n    (decl\n        (ident\n            &#39;foo&#39;)\n        (string_part))\n    (decl\n        (ident\n            &#39;bar&#39;)\n        (string_part)))\n</code></pre></div>",
        "id": 502695968,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740792890
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"611722\">@Isaac Van Doren</span> -- how would you feel about me adding <code>FORMAT</code> as a section in these snapshot tests, instead of having a unit tests that write out to another file? </p>\n<p>We could then also run the formatter on  each snapshot file in our corpus.</p>",
        "id": 502701093,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740796812
    },
    {
        "content": "<p>If we think that's a good idea, I'm down to give it a try. We can land the format cli PR, I can rebase my snapshot PR and try it out</p>",
        "id": 502701163,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740796884
    },
    {
        "content": "<p>I guess I'm thinking of the \"snapshot\" tool as like our integration test suite...</p>",
        "id": 502701184,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740796910
    },
    {
        "content": "<p>Yeah, sounds great!</p>\n<p>Would also be great to make the format section optional. If the section is missing, it will then be required that the source section formats to itself.</p>",
        "id": 502701320,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740797023
    },
    {
        "content": "<p>Well... it's kind of one way.</p>",
        "id": 502701380,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740797051
    },
    {
        "content": "<p>So like, we put un-formatted code in the SOURCE section... it formats it and adds to the FORMATED section.</p>",
        "id": 502701409,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740797073
    },
    {
        "content": "<p>Then you can see in any changes in the <code>git diff</code></p>",
        "id": 502701414,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740797082
    },
    {
        "content": "<p>Did you have another idea in mind <span class=\"user-mention\" data-user-id=\"343810\">@Brendan Hansknecht</span> ? why would we want it optional?</p>",
        "id": 502701489,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740797153
    },
    {
        "content": "<p>Or maybe if the formatted code is identical we don't bother writing out the section... but I wonder if it's cheaper just to dump the bytes out than compare the strings.</p>",
        "id": 502701615,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740797236
    },
    {
        "content": "<p>I guess to work with git diff, if only a SOURCE section. The process is read source, format it, and write it back to SOURCE (only source means it is already formatted correctly). This avoids printing the same chunk of code twice in a row if the formatting is already good.</p>\n<p>If a FORMATTED section exist, we expect the SOURCE to change when formatted. So we need to write out both sections and they aren't redundant.</p>\n<p>So just noise reduction, but ensure that all test case can format</p>",
        "id": 502701624,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740797242
    },
    {
        "content": "<p>Ahk that's a good idea. That way we will know if the formatting changes, but not duplicate things unnecessarily.</p>",
        "id": 502701727,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740797302
    },
    {
        "content": "<p>Maybe that isn't needed, but I feel like for long examples, it will be nice to not print the source twice</p>",
        "id": 502701731,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740797306
    },
    {
        "content": "<p>FYI <span class=\"user-mention\" data-user-id=\"611722\">@Isaac Van Doren</span> I merged your PR -- I'll adapt your integration tests into the snapshot tool as above.</p>",
        "id": 502701858,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740797422
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"343810\">@Brendan Hansknecht</span> -- I assumed we want to build the snapshot tool by default so you can run the integration tests easily</p>",
        "id": 502701932,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740797481
    },
    {
        "content": "<p>I'm happy to make it a flag though. Just that was my assumption</p>",
        "id": 502701959,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740797508
    },
    {
        "content": "<p>I guess it should probably just sit behind <code>zig build test</code> also? or might we want to keep that for unit tests only?</p>",
        "id": 502702015,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740797540
    },
    {
        "content": "<p>Yeah validating formatting in the multi tiered snapshots sounds useful</p>",
        "id": 502703020,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1740798276
    },
    {
        "content": "<p>But it won't be testing the same behavior as the test I wrote so I think we should keep it. That test wasn't meant to really check anything about the actual formatting itself, just that <code>roc format</code> correctly reads in the specified file and writes back out the formatted version.</p>",
        "id": 502703178,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1740798383
    },
    {
        "content": "<p>Originally that test was e2e (it actually built the roc executable and invoked it). I think it would be good to stand up a separate e2e suite for the CLI which would be a good place for tests like that to live</p>",
        "id": 502703328,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1740798514
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515757\">Luke Boswell</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20IR.20serde/near/502701932\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> -- I assumed we want to build the snapshot tool by default so you can run the integration tests easily</p>\n</blockquote>\n<p>That's probably fine.</p>\n<p>Just thinking if someone only wants to build roc, they can just <code>zig build</code> and that can be roc and no other wasted time</p>",
        "id": 502703802,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740798841
    },
    {
        "content": "<p>Any concerns with a separate e2e suite for the CLI? I'm happy to set it up</p>",
        "id": 502704148,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1740799092
    },
    {
        "content": "<p>I feel like it would be pretty redundant with all of the snapshot tests. Not bad to add a few of, but it is probably preferable to avoid too many scattered tests</p>",
        "id": 502704626,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740799382
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515757\">Luke Boswell</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20IR.20serde/near/502702015\">said</a>:</p>\n<blockquote>\n<p>I guess it should probably just sit behind <code>zig build test</code> also? or might we want to keep that for unit tests only?</p>\n</blockquote>\n<p>If we put it behind, <code>zig build test</code> we just need to make it sure it is fast enough. Might hurt the dev loop, in which case, probably should be <code>zig build test -Dsnapshot</code>. I think really the separation is for ensure fast feedback.</p>\n<p>I assume eventually we will have enough snapshot tests we will want to separate it out, but probably fine to start unified and only separate out if it gets too slow.</p>",
        "id": 502704788,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740799522
    },
    {
        "content": "<p>I might leave it as <code>zig build snapshot</code> for now... at least for this PR</p>",
        "id": 502705391,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740800041
    },
    {
        "content": "<p>I can imagine we'll iterate on the design a few more times at least</p>",
        "id": 502705442,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740800064
    },
    {
        "content": "<blockquote>\n<p>I feel like it would be pretty redundant with all of the snapshot tests. Not bad to add a few of, but it is probably preferable to avoid too many scattered tests</p>\n</blockquote>\n<p>My intention would be to focus on focusing on the CLI/orchestration logic that wouldn't be tested by the snapshots at all, so I don't think there would be much overlap there. I wouldn't try to make it exhaustive, just for some confidence that changes to the CLI are correct without having to manually test everything.</p>",
        "id": 502706302,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1740800830
    },
    {
        "content": "<p>Ah, I thought you meant specifically formatting tests. Like another suite of tests but just for formatting.</p>",
        "id": 502706355,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740800872
    },
    {
        "content": "<p>But like tests that format examples/stdlib (folder vs file vs invalid) or exercise various cli args sound great</p>",
        "id": 502706449,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1740800926
    },
    {
        "content": "<p>Right, that's what I'm thinking <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 502706476,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1740800957
    },
    {
        "content": "<p>Anyone looking for something to help out with, we should set up our snapshot tool to run in CI with the other zig things. </p>\n<p>I haven't started looking at this yet. But it's ready to be added now.</p>",
        "id": 502798564,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740871519
    },
    {
        "content": "<p>I think the next thing I'd like to tackle is parsing just an expression (not a full file), and translate some of our syntax snapshot tests across to work on improving coverage there. </p>\n<p>Maybe look at how we might handle multi file snapshots... <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 502798676,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740871616
    },
    {
        "content": "<blockquote>\n<p>we should set up our snapshot tool to run in CI</p>\n</blockquote>\n<p>What are the commands to use it?</p>",
        "id": 502974197,
        "sender_full_name": "Anton",
        "timestamp": 1740992789
    },
    {
        "content": "<p><code>zig build snapshot</code><br>\n<code>zig build snapshot -- --verbose</code> also</p>",
        "id": 502987189,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1740996672
    },
    {
        "content": "<p>I'll get on that after the roc nix package</p>",
        "id": 502988421,
        "sender_full_name": "Anton",
        "timestamp": 1740997076
    },
    {
        "content": "<p><code>zig build snapshot</code> updates the golden values right? Why do we want to run it in CI?</p>",
        "id": 503024065,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1741007895
    },
    {
        "content": "<p>You run it, then a few extra git commands to ensure that none of the snapshot files changed</p>",
        "id": 503073886,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1741020042
    },
    {
        "content": "<p>If any change or if new ones pop into existence, it is a failure</p>",
        "id": 503074003,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1741020077
    },
    {
        "content": "<p>Ah I see. I was imagining that there would be a command that would explicitly check that the snapshots matched the current output without requiring you to manually diff them</p>",
        "id": 503075312,
        "sender_full_name": "Isaac Van Doren",
        "timestamp": 1741020445
    },
    {
        "content": "<p>Small improvement to sexpr pretty printing: <a href=\"https://github.com/roc-lang/roc/pull/7659\">https://github.com/roc-lang/roc/pull/7659</a></p>",
        "id": 503294092,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1741101567
    },
    {
        "content": "<p>What approach should we take for snapshots that are just a single expression... </p>\n<p>For example in <code>crates/compiler/test_syntax/tests/snapshots/pass/add_var_with_spaces.expr.roc</code> we have a single expression</p>\n<div class=\"codehilite\"><pre><span></span><code>x + 2\n</code></pre></div>\n<p>Would we want snapshots this small, i.e. without being a full module? </p>\n<p>I was thinking of migrating these across one by one as snapshots and using them to help add parser functionality.</p>",
        "id": 503726206,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1741248254
    },
    {
        "content": "<p>Or perhaps we would want something like this instead... so turn them into a full module.</p>\n<div class=\"codehilite\"><pre><span></span><code>~~~META\ndescription=Add a variable with spaces\n~~~SOURCE\nmodule [add2]\n\nadd2 = x + 2\n~~~PARSE\n(file\n    (header &#39;add2&#39;)\n    (decl\n        (ident &#39;add2&#39;)\n        (binop\n            &#39;+&#39;\n            (ident &#39;&#39; &#39;x&#39;)\n            (int &#39;2&#39;))))\n</code></pre></div>",
        "id": 503728272,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1741248924
    },
    {
        "content": "<p>Also -- minor tangent while I'm looking at it... would we prefer <code>(binop  '+' &lt;lhs&gt; &lt;rhs&gt;)</code> ... or switch on the token and make it more like <code>(plus &lt;lhs&gt; &lt;rhs&gt;)</code></p>",
        "id": 503728931,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1741249122
    },
    {
        "content": "<p>I'd vote for the former (AKA <code>(binop ...)</code>) since it's more consistent with how the rest of the S-expr stuff seems to work, and it gets desugared immediately in the next stage, so it's minor anyway</p>",
        "id": 503729398,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1741249268
    },
    {
        "content": "<p>Definitely want to be able to parse single syntax nodes (exprs, statements, header, etc)</p>",
        "id": 503756798,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1741257091
    },
    {
        "content": "<p>Could just have <code>type = Expr</code> in the META section of the snapshot</p>",
        "id": 503833480,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1741277529
    },
    {
        "content": "<p>It's really cool seeing this stuff come alive...</p>\n<div class=\"codehilite\"><pre><span></span><code>~~~META\ndescription=Various type annotations\n~~~SOURCE\nmodule []\n\nfoo : U64\nbar : Thing(a, b, _)\nbaz : (a, b, c)\nadd_one : (U8, U16 -&gt; U32)\nmain! : List(String) -&gt; Result({}, _)\n~~~PARSE\n(file\n    (header)\n    (type_anno\n        &#39;foo&#39;\n        (tag &#39;U64&#39;))\n    (type_anno\n        &#39;bar&#39;\n        (tag\n            &#39;Thing&#39;\n            (ty_var &#39;a&#39;)\n            (ty_var &#39;b&#39;)\n            (_)))\n    (type_anno\n        &#39;baz&#39;\n        (tuple\n            (ty_var &#39;a&#39;)\n            (ty_var &#39;b&#39;)\n            (ty_var &#39;c&#39;)))\n    (type_anno\n        &#39;add_one&#39;\n        (fn\n            (tag &#39;U32&#39;)\n            (tag &#39;U8&#39;)\n            (tag &#39;U16&#39;)))\n    (type_anno\n        &#39;main!&#39;\n        (fn\n            (tag\n                &#39;Result&#39;\n                (record)\n                (_))\n            (tag\n                &#39;List&#39;\n                (tag &#39;String&#39;)))))\n</code></pre></div>",
        "id": 503937067,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1741316698
    },
    {
        "content": "<p>Some simplifications I'm debating rn (just for the snapshots, not renaming tag unions in the zig source or anything)</p>\n<ul>\n<li><code>type_anno</code> -&gt; <code>tann</code></li>\n<li><code>ty_var</code> -&gt; <code>tvar</code></li>\n</ul>\n<p>There's a lot of design space here. It's nice that this is all one way and so easy to update the snapshots.</p>",
        "id": 503937229,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1741316805
    },
    {
        "content": "<p><code>type_anno</code> and <code>ty_var</code> are a lot clearer, I wouldn't change them if we don't experience noticeable problems due to verbosity.</p>",
        "id": 504257825,
        "sender_full_name": "Anton",
        "timestamp": 1741426797
    },
    {
        "content": "<p>I'd just like to say in case anyone is wondering Re the current state of snapshots, because they look somewhat  strange.</p>\n<p>I've just been dumping things in there to help figure out syntax issues with the parser and seed the fuzzer etc. </p>\n<p>The current snapshots are pretty expendable and we will probably blow them away soon or change them a lot when we start having a usable Can etc.</p>",
        "id": 504324427,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1741473326
    },
    {
        "content": "<p>I think it's this output is really nice, but I _personally_ would prefer double quotes for strings.  Are we using singles just to avoid having to worry about escaping?</p>",
        "id": 504585749,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1741614181
    },
    {
        "content": "<p>Just wanted to show off a little... checkout this snapshot. I'm pretty happy with how this is starting to look. It's really easy to see at a glance where the issues are. You can feed inputs from fuzz crashes and dissect what the compiler is doing pretty quickly -- which has helped me find and fix a number of issues.</p>\n<p>I'm loving the formatting for Problems also <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span> </p>\n<div class=\"codehilite\"><pre><span></span><code>~~~META\ndescription=fuzz crash\n~~~SOURCE\nH{o,\n  \u001f  ]\n\nfoo =\n\n    &quot;on        (string &#39;onmo %&#39;)))\n~~~PROBLEMS\nTOKENIZE: (2:4-2:4) AsciiControl:\n\n  \u001f  ]\n   ^\nTOKENIZE: (1:6-1:6) Expected the correct closing brace here:\n\n  \u001f  ]\n      ^\n\nTOKENIZE: (6:7-6:36) UnclosedString:\n\n    &quot;on        (string &#39;onmo %&#39;)))\n      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nPARSER: missing_header\n~~~TOKENS\nUpperIdent,OpenCurly,LowerIdent,Comma,Newline,CloseCurly,Newline,LowerIdent,OpAssign,Newline,StringStart,StringPart,EndOfFile\n~~~PARSE\n(file\n    (malformed_header &#39;missing_header&#39;)\n    (record (field &#39;o&#39;))\n    (decl\n        (ident &#39;foo&#39;)\n        (string &#39;on        (string &#39;onmo %&#39;)))&#39;)))\n~~~FORMATTED\n{ o }\n\nfoo = &quot;on        (string &#39;onmo %&#39;)))&quot;\n~~~END\n</code></pre></div>",
        "id": 504732462,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1741664188
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"781658\">Anthony Bullard</span> <a href=\"#narrow/channel/395097-compiler-development/topic/zig.20compiler.20-.20IR.20serde/near/504585749\">said</a>:</p>\n<blockquote>\n<p>I think it's this output is really nice, but I _personally_ would prefer double quotes for strings.  Are we using singles just to avoid having to worry about escaping?</p>\n</blockquote>\n<p>I changed it to double quotes in <a href=\"https://github.com/roc-lang/roc/pull/7672\">https://github.com/roc-lang/roc/pull/7672</a></p>",
        "id": 504733942,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1741665178
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"515757\">@Luke Boswell</span> I'm dealing with an issue with Zig where TLDR we want to move to using TAB as the canonical indentation character in the formatter but Zig multiline string literals do not support using TAB in them.  So long story short I need to move all of the current fmt tests to snapshots (I don't have to per se, but I think it's the logical move).</p>\n<p>In order to do that I am moving to make snapshots support different IR nodes like the old test_syntax snapshots did.  Are you aligned with this?  It means that I need to expose some extra methods on the Parse IR so that we can output the SExpr and format correctly.</p>",
        "id": 517935471,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1747176081
    },
    {
        "content": "<p>I'm not sure what you mean by </p>\n<blockquote>\n<p>make snapshots support different IR nodes like the old test_syntax snapshots did</p>\n</blockquote>",
        "id": 517986669,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1747206709
    },
    {
        "content": "<p>In general though, I think moving the fmt tests to snapshots is a great idea!</p>",
        "id": 517986745,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1747206725
    },
    {
        "content": "<p>That was my intention too, but I figured you wanted the kitchen sink in there because it was easier to work with while developing the Parser initial implementation.</p>",
        "id": 517986907,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1747206783
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515757\">Luke Boswell</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20IR.20serde/near/517986669\">said</a>:</p>\n<blockquote>\n<p>I'm not sure what you mean by </p>\n<blockquote>\n<p>make snapshots support different IR nodes like the old test_syntax snapshots did</p>\n</blockquote>\n</blockquote>\n<p>sorry i mean have it support snapshots of just exprs, statements, or headers instead of just modules</p>",
        "id": 518025309,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1747217726
    },
    {
        "content": "<p>yeah, that is something we need to support anyway (imo)</p>",
        "id": 518031577,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1747219716
    }
]