[
    {
        "content": "<p>I want to take a crack at getting desugaring going so that we have a sugar-free IR to work with canonicalization.  Is the correct approach here to just use the existing Parse IR and walk through and just move nodes in that have no sugar, and then break down sugar and insert it?</p>",
        "id": 519377817,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1747745765
    },
    {
        "content": "<p>And also, do we even have enough sugar at this point to warrant a whole separate step in the compiler for it? And if we should, should we try to minimize the number of modules that we touch in desugar by marking a Parse IR struct as \"needing desugaring\" when we insert nodes that require it?</p>",
        "id": 519378279,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1747745886
    },
    {
        "content": "<p>I think it would even be nice if we can track nodes that need desugaring and literally just mutate the existing IR (a downside being those nodes then are probably quite a ways away from each other more likely in larger files)</p>",
        "id": 519378817,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1747746036
    },
    {
        "content": "<blockquote>\n<p>to warrant a whole separate step in the compiler for it</p>\n</blockquote>\n<p>I am in favor of a separate step. I feel like it would help maintainability. It's nice for on-boarding and debugging to have a place where all the desugaring is happening, vs having it intertwined with a bunch of other stuff.</p>",
        "id": 519379050,
        "sender_full_name": "Anton",
        "timestamp": 1747746117
    },
    {
        "content": "<p>Another approach could be to have the sugar nodes describe themselves for the purposes of formatting and parse error reporting, but also insert the sugar when we insert the node and then node would have a link to it - and then Can can just skip past it's details and fetch the real nodes</p>",
        "id": 519379212,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1747746162
    },
    {
        "content": "<blockquote>\n<p>should we try to minimize the number of modules that we touch in desugar</p>\n</blockquote>\n<p>That seems like something we could leave for later if need be?</p>",
        "id": 519379240,
        "sender_full_name": "Anton",
        "timestamp": 1747746173
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"361169\">Anton</span> <a href=\"#narrow/channel/395097-compiler-development/topic/zig.20compiler.20-.20desugaring/near/519379240\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>should we try to minimize the number of modules that we touch in desugar</p>\n</blockquote>\n<p>That seems like something we could leave for later if need be?</p>\n</blockquote>\n<p>Yeah, I'm trying not to OVERLY optimize too early, but I think this is plain perf lying on the floor if we are using the same IR</p>",
        "id": 519379377,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1747746220
    },
    {
        "content": "<blockquote>\n<p>sugar nodes describe themselves for the purposes of formatting and parse error reporting</p>\n</blockquote>\n<p>How does this work in the old compiler?</p>",
        "id": 519379549,
        "sender_full_name": "Anton",
        "timestamp": 1747746260
    },
    {
        "content": "<p>We just walk the entire AST and return new AST nodes that are still Parse AST nodes</p>",
        "id": 519379724,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1747746311
    },
    {
        "content": "<p>(And just a note, I'm not going to start on this today - just trying to line up some tasks for the coming weeks.  I want to have a broad high-level consensus before I put hands on keyboard)</p>",
        "id": 519379881,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1747746355
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"781658\">Anthony Bullard</span> <a href=\"#narrow/channel/395097-compiler-development/topic/zig.20compiler.20-.20desugaring/near/519379212\">said</a>:</p>\n<blockquote>\n<p>Another approach could be to have the sugar nodes describe themselves for the purposes of formatting and parse error reporting, but also insert the sugar when we insert the node and then node would have a link to it - and then Can can just skip past it's details and fetch the real nodes</p>\n</blockquote>\n<p>That seems like a reasonable approach but it's not my area of expertise</p>",
        "id": 519380471,
        "sender_full_name": "Anton",
        "timestamp": 1747746525
    },
    {
        "content": "<p>I think it's fine to start as a separate step</p>",
        "id": 519382482,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1747747056
    },
    {
        "content": "<p>I have a vague intuition that our current set of sugar can all be done during canonicalization without a separate pass (which was not true of our pre-0.1.0 sugar!)</p>",
        "id": 519382624,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1747747084
    },
    {
        "content": "<p>but if that turns out to be true, then it should be super easy to just take the separate pass and incorporate it into canonicalization anyway, so having it as a separate pass shouldn't be a significant downside</p>",
        "id": 519382747,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1747747108
    },
    {
        "content": "<p>I could be misremembering, but I think we already did Pratt parsing to resolve operator precedence during parsing, right?</p>",
        "id": 519383057,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1747747196
    },
    {
        "content": "<p>if so, I assume the only remaining concern is associativity (and reporting errors there), which can be a desugaring thing</p>",
        "id": 519383227,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1747747232
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20desugaring/near/519383227\">said</a>:</p>\n<blockquote>\n<p>if so, I assume the only remaining concern is associativity (and reporting errors there), which can be a desugaring thing</p>\n</blockquote>\n<p>i thought pratt parsing took associativity into account?  no?</p>",
        "id": 519398217,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1747750723
    },
    {
        "content": "<p>i implemented that so long ago i forgot the specifics and im not at my machine</p>",
        "id": 519398349,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1747750755
    },
    {
        "content": "<p>oh maybe it does, I forget too <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 519412717,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1747754270
    },
    {
        "content": "<p>i've been digging through the Canoncalization code wrapping my mind around what <span class=\"user-mention\" data-user-id=\"461444\">@Sam Mohr</span> has already built.  fixed a number of assumptions that have changed since then, but there is a lot around the way idents, modules, and aliases are handled that i'm having a whale of a time wrapping my mind around</p>",
        "id": 519715224,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1747868201
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"781658\">@Anthony Bullard</span> want to chat about it? I'm free in like 30 min</p>",
        "id": 519715494,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1747868354
    },
    {
        "content": "<p>i'd love to!  i have a \"wellbeing day\" on friday and would love to use it to make some progress while the kids are at school</p>",
        "id": 519715551,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1747868394
    },
    {
        "content": "<p>I can also answer one off question in DMs or in the channel</p>",
        "id": 519742709,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1747886700
    },
    {
        "content": "<p>Though I'm sure Richard knows what he's talking about</p>",
        "id": 519742940,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1747886850
    },
    {
        "content": "<p>I am going to take you up on this <span class=\"user-mention\" data-user-id=\"461444\">@Sam Mohr</span> I'm trying to understand how you imagined the Can IR working in later stages.  It seems that it stores things in a way that makes it difficult to walk down through the AST in order - but maybe I'm missing something</p>",
        "id": 520088359,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748017132
    },
    {
        "content": "<p>This is my initial PR with some basic tests on adding idents and being able to see if they are or are not in scope</p>",
        "id": 520102854,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748022670
    },
    {
        "content": "<p><a href=\"https://github.com/roc-lang/roc/pull/7806\">https://github.com/roc-lang/roc/pull/7806</a></p>",
        "id": 520103010,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748022723
    },
    {
        "content": "<p>In a convo I had with <span class=\"user-mention\" data-user-id=\"281383\">@Richard Feldman</span>  and <span class=\"user-mention\" data-user-id=\"515757\">@Luke Boswell</span> , we talked about not needing typevars in the Can IR.  I also think we should probably move to a Node/Extra Data structure like we did for parse</p>",
        "id": 520103716,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748023016
    },
    {
        "content": "<p>As opposed to today where every type of node has its own list</p>",
        "id": 520103807,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748023069
    },
    {
        "content": "<p>yeah I think if we start with \"<code>TypeVar</code> is just a type alias for Can IR Node Index\" then a lot of things will fall out of that</p>",
        "id": 520104215,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748023215
    },
    {
        "content": "<p>e.g. if all the info we need to store for 1 node doesn't fit in 1 node slot (without the size of one node getting unacceptably large), such as an <code>if</code> node, then ideally we use multiple node slots to store that extra info</p>",
        "id": 520104390,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748023276
    },
    {
        "content": "<p>so for example, in the case of <code>if</code>, the information we need is:</p>\n<ul>\n<li>what's the index of the can IR node for the conditional</li>\n<li>what are the indices of the can IR nodes for the branches</li>\n<li>what's the index of the can IR node for the final <code>else</code> branch, if there is one</li>\n</ul>\n<p>in the Rust compiler's <a href=\"https://github.com/roc-lang/roc/blob/main/crates/compiler/can/src/expr.rs#L194-L199\"><code>If</code> node</a>, we store an explicit type variable for the condition and another for the branches.</p>",
        "id": 520106180,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748023930
    },
    {
        "content": "<p>We don't need to store one for the conditional anymore, because the node index of the condition is automatically a type variable, so we just use that.</p>",
        "id": 520106187,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748023935
    },
    {
        "content": "<p>We also don't need to store one for the branches, because we're going to unify all the branches together anyway, so we just need to know what the first one's variable is and we're all set. And if we have the node ID of the first branch, then we know its variable, because in this design they're the same.</p>",
        "id": 520106295,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748023992
    },
    {
        "content": "<p>so an example of how we could do <code>If</code> completely inline:</p>\n<ul>\n<li>we have an <code>If</code> node which stores the node index of the first <code>else</code> branch and that's it</li>\n<li>immediately after that node (as in, right at the <code>If</code> node's index + 1 in the flat array of nodes) we have the conditional IR node. We don't need to write down its index because we already know it's just at our own index + 1.</li>\n<li>in the interpreter, type checker, and code generator, we will always traverse the entire conditional before doing anything with any branches, so at that point we'll be at the end of the conditional</li>\n<li>if we make sure to put the <code>then</code> branch immediately after the conditional, then we don't need to store an index for that either because we'll be right there as soon as we finish processing the conditional</li>\n<li>the interpreter does need to know where the <code>else</code> branch is (without traversing the whole <code>then</code> branch) because if the conditional is false, it will want to jump straight there - but fortunately, that's the one index we <em>did</em> write down in the original node, so we're all set there</li>\n<li>if it's an <code>else if</code>, then the <code>else</code> branch will immediately begin with an <code>if</code>, and this whole pattern repeats</li>\n<li>if this is an <code>if</code> without an <code>else</code>, we can record that in the original node (e.g. have a different discriminant for <code>if</code> and <code>if_without_else</code> and they work slightly differently)</li>\n</ul>",
        "id": 520107757,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748024628
    },
    {
        "content": "<p>so basically what we're building is kind of like a linked list of nested <code>if</code>/<code>else</code>s, except it's all inline in the one flat array of nodes, no side tables needed</p>",
        "id": 520107821,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748024644
    },
    {
        "content": "<p>and all the info necessary is already there for traversing it, checking its types (including type vars), interpreting it, code-genning it, etc.</p>",
        "id": 520107892,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748024676
    },
    {
        "content": "<p>and memory locality is pretty much as good as we can get it because it's all contiguous in one flat array</p>",
        "id": 520107977,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748024709
    },
    {
        "content": "<p>this would seem to work pretty well but unless we return the last node we touched when fetching the \"usable struct\" that represents the node, we will run into problems with any say conditional that's more than a simple expr</p>",
        "id": 520113447,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748026918
    },
    {
        "content": "<p>say \"getExpr\" would need to return the Expr union member AND the last node index we touched constructing it</p>",
        "id": 520113594,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748026968
    },
    {
        "content": "<p>which actually would require building out (or at least traversing ) the entire expr tree to find thst</p>",
        "id": 520113796,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748027057
    },
    {
        "content": "<p>which would require pointers since it would be a recursive data structure</p>",
        "id": 520113900,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748027115
    },
    {
        "content": "<p>or if you want to avoid that, walking the nodes for a complex expression over and over to to get the child nodes all the way down</p>",
        "id": 520113997,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748027162
    },
    {
        "content": "<p>whereas storing the span of the referenced nodes avoids the need for that</p>",
        "id": 520114165,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748027227
    },
    {
        "content": "<p>For instance, take a <code>if</code> expression like this:</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">something</span><span class=\"o\">.</span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"s2\">\"Hello\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">123</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"no\">Stdout</span><span class=\"o\">.</span><span class=\"n\">line!</span><span class=\"p\">(</span><span class=\"s2\">\"Branch A\"</span><span class=\"p\">)</span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"no\">Stdout</span><span class=\"o\">.</span><span class=\"n\">line!</span><span class=\"p\">(</span><span class=\"s2\">\"Branch B\"</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Would result (with the straight-line left-to-right approach you lay out above) in the following node layout</p>\n<div class=\"codehilite\"><pre><span></span><code>IF_THEN_ELSE, STATIC_DISPATCH(args=2), IDENT, IDENT, STRING(parts=1), STRING_PART, INT,\nAPPLY(args=1), QUALIFIED_IDENT, STRING(parts=1), STRING_PART,\nAPPLY(args=1), QUALIFIED_IDENT, STRING(parts=1), STRING_PART\n</code></pre></div>\n<p>To know how to get the else body would require traversing through the conditional and the then body, and would to wanting to collecting something like</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">If</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">conditional</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"p\">.</span><span class=\"n\">Idx</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"s\">\"@then\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"p\">.</span><span class=\"n\">Idx</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"s\">\"@else\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"p\">.</span><span class=\"n\">Idx</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">this_if</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">If</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"n\">conditional</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"s\">\"@then\"</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"s\">\"@else\"</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">11</span><span class=\"w\"> </span><span class=\"p\">};</span>\n</code></pre></div>\n<p>And when you fetch the conditional, you'd have to run through all the nodes again (until we have two args) to get something like</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">StaticDispatch</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">subject</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"p\">.</span><span class=\"n\">Idx</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"s\">\"@callee\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Node</span><span class=\"p\">.</span><span class=\"n\">Idx</span><span class=\"p\">,</span>\n<span class=\"w\">   </span><span class=\"n\">args</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"p\">[]</span><span class=\"n\">Node</span><span class=\"p\">.</span><span class=\"n\">Idx</span><span class=\"p\">,</span>\n<span class=\"p\">};</span>\n\n<span class=\"kr\">const</span><span class=\"w\"> </span><span class=\"n\">this_sd</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">StaticDispatch</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"n\">subject</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"s\">\"@callee\"</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"n\">args</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">.{</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">};</span>\n</code></pre></div>\n<p>Since we have to skip the STRING_PART at Index 5.</p>\n<p>So we've already walked through nodes 1-6 twice.  I don't think that's a big deal, but is that we want to be doing?  We'd have to have <code>walk*</code> methods as well as <code>get*</code> methods so that we walk through the nodes without building intermediate structs that we will through away (they would instead return the last node idx touched)</p>",
        "id": 520116400,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748028269
    },
    {
        "content": "<p>I think the structure of having a Node that stores a primary piece of data, and a span of extra data in a side array allows us to basically \"memoize\" that node traversal at the cost of moving between two arrays (I would assume the loaded chunks of those arrays could both fit nice and cozy in the L1 cache of most modern processors for most expressions (or even an average decl))</p>",
        "id": 520117081,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748028568
    },
    {
        "content": "<p>So I guess my preference is to lean heavily on the structure of the Parse IR which seems to be incredibly fast and the mechanics of it are easy to understand</p>",
        "id": 520117225,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748028622
    },
    {
        "content": "<p>looking at it while thinking about TypeVars, I think that should work fine <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 520121565,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748030563
    },
    {
        "content": "<p>I'd say go for it!</p>",
        "id": 520121677,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748030612
    },
    {
        "content": "<p>Push up the broken rough draft state of where I'm headed with the IR - again heavily based on Parse IR</p>",
        "id": 520134071,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748037098
    },
    {
        "content": "<p>Anything outside of the NodeStore is probably incorrect or only partially correct.  Most likely out of date</p>",
        "id": 520134151,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748037126
    },
    {
        "content": "<p>So just focus on the high-level API of the NodeStore</p>",
        "id": 520134198,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748037161
    },
    {
        "content": "<p>I'm done for the day, hope to have some time tomorrow morning to clean up some of the broken stuff and then fill in the minimal details to get my can tests (and any other broken tests and code) working again</p>",
        "id": 520134351,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748037254
    },
    {
        "content": "<p>I gave it a quick read - looking good so far! <span aria-label=\"raised hands\" class=\"emoji emoji-1f64c\" role=\"img\" title=\"raised hands\">:raised_hands:</span></p>",
        "id": 520155824,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748055493
    },
    {
        "content": "<p>Reading through the PR now, it seems like we've removed the ownership of the <code>ModuleEnv</code> from the <code>can.IR</code>. Are we not planning on doing the two syscall caching of the Can IR, maybe instead opting for a manual (de)serialization?</p>",
        "id": 520262423,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748152206
    },
    {
        "content": "<p>If not, then the <code>ModuleEnv</code> should continue to be owned by the <code>can.IR</code></p>",
        "id": 520262450,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748152264
    },
    {
        "content": "<p>it's a decision i'm going back on <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 520280982,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748169069
    },
    {
        "content": "<p>i still don't understand how we can do it in two syscalls with all of the pointers going on here</p>",
        "id": 520281066,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748169144
    },
    {
        "content": "<p>but it's just not the kind of thing i have experience with</p>",
        "id": 520281120,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748169200
    },
    {
        "content": "<p>but module work is forcing my<br>\nhand</p>",
        "id": 520281135,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748169220
    },
    {
        "content": "<p>Do you agree with the ModuleWork mechanism?</p>",
        "id": 520281210,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748169278
    },
    {
        "content": "<p>Its goal is to allow simple parallel compilation that doesn't require complex/non-trivial lookup of compilation artifacts from other compiler phases</p>",
        "id": 520281237,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748169332
    },
    {
        "content": "<p>it  seems fine every if i haven't read through it all</p>",
        "id": 520281278,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748169363
    },
    {
        "content": "<p>Yeah, okay</p>",
        "id": 520281298,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748169370
    },
    {
        "content": "<p>I think another mechanism could work</p>",
        "id": 520281300,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748169379
    },
    {
        "content": "<p>But high level seems good</p>",
        "id": 520281310,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748169394
    },
    {
        "content": "<p>possibly but i'm hyper focused on getting Can moving at the moment</p>",
        "id": 520281318,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748169413
    },
    {
        "content": "<p>That's great, thanks for picking up the slack!</p>",
        "id": 520281331,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748169426
    },
    {
        "content": "<p>I'm gonna try again to read through the new IR shape</p>",
        "id": 520281333,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748169437
    },
    {
        "content": "<p>I'm feeling like the new IR has further indirection from the underlying concept of a syntax tree</p>",
        "id": 520281441,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748169528
    },
    {
        "content": "<p>Which makes programming with it harder to get correct</p>",
        "id": 520281447,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748169538
    },
    {
        "content": "<p>The old IR is basically just a tree, but instead of every node being behind a heap allocation, they're instead indices into arrays of the right node type</p>",
        "id": 520281499,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748169595
    },
    {
        "content": "<p>This mechanism flattens everything into a single bucket, and the <code>Node</code> needs to be interacted with via some unwrapping API for interaction with the syntax tree</p>",
        "id": 520281555,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748169650
    },
    {
        "content": "<p>Is there a reasonable perf benefit to the parse style IR over the old IR?</p>",
        "id": 520281577,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748169680
    },
    {
        "content": "<p>Well you are more likely to have cache locality if all of the nodes are in one contiguous block of memory, whereas the different slices we had before could have their backing storage allocated all over the place.  But that's more theory (and me watching Matt Lugg's talks about Zig's compiler) than anything else.</p>",
        "id": 520281775,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748169875
    },
    {
        "content": "<p>And they will be in one contiguous block since we created the nodes in order while running through the tree</p>",
        "id": 520281820,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748169928
    },
    {
        "content": "<p>The ParseIR design has also been shown to be very fast, and I know how to work with it - and someone that learns one IR can translate that knowledge towards understanding the second</p>",
        "id": 520281913,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748169986
    },
    {
        "content": "<p>And during unification/type checking we can just add the typevars off row using the same index as the original node</p>",
        "id": 520281963,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748170051
    },
    {
        "content": "<p>(Richard said he wanted to avoid having TypeVars in the CanIR, unlike what we did with the Rust compiler)</p>",
        "id": 520282018,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748170093
    },
    {
        "content": "<p>But I want your feedback if you are willing and able <span class=\"user-mention\" data-user-id=\"461444\">@Sam Mohr</span> I trust your opinion and design sense.</p>",
        "id": 520282040,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748170144
    },
    {
        "content": "<p>Yeah, cache locality is the argument that drives all of this array-backed storage in the first place</p>",
        "id": 520282380,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748170457
    },
    {
        "content": "<p>In this case, it <em>feels</em> like the parse IR approach (do you have a better name for the pattern?) would have better spatial locality</p>",
        "id": 520282443,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748170544
    },
    {
        "content": "<p>The bias I have towards the existing pattern is that it lets the compiler check we're doing things correctly at the type level</p>",
        "id": 520282544,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748170621
    },
    {
        "content": "<p>And that's not really true of the parse IR, its runtime benefits notwithstanding</p>",
        "id": 520282560,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748170638
    },
    {
        "content": "<p>We have to really get it right in terms of putting in and taking out the right data for the right IR node</p>",
        "id": 520282574,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748170675
    },
    {
        "content": "<p>However, this is compiler dev</p>",
        "id": 520282625,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748170703
    },
    {
        "content": "<p>And two rules are important to consider:</p>",
        "id": 520282628,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748170717
    },
    {
        "content": "<ol>\n<li>We aren't trying to use standard maintainability rules because perf is more important at a line-by-line level than a normal project by far</li>\n</ol>",
        "id": 520282651,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748170763
    },
    {
        "content": "<ol start=\"2\">\n<li>We don't have that much ongoing contribution, so code that does what we want is better than idealized code that doesn't exist</li>\n</ol>",
        "id": 520282665,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748170789
    },
    {
        "content": "<p>So if you're working on it and no one else is, then getting something that works, has the right behavior, and won't need to be made more performant in the future sounds good to me</p>",
        "id": 520282755,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748170839
    },
    {
        "content": "<p>Last memory-related thought: the single, mother Node approach means that all nodes have the same size, which is the minimum required to represent the largest node type</p>",
        "id": 520282943,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171023
    },
    {
        "content": "<p>But with heterogeneous storage of IR nodes, only a few nodes (e.g. <code>if</code> and <code>when</code>) need a lot of memory, and the rest can just be small pointers to those</p>",
        "id": 520283017,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171077
    },
    {
        "content": "<p>So as much as we probably store children closer to their parents, we probably use more memory</p>",
        "id": 520283040,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171100
    },
    {
        "content": "<p>No idea how much that trade-off is though <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 520283055,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171115
    },
    {
        "content": "<p>But those nodes are made minimal and just point (through extra_data an array of just u32s) to other nodes which contain the other information</p>",
        "id": 520283079,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748171142
    },
    {
        "content": "<p>If they are larger than what we consider minimal</p>",
        "id": 520283148,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748171181
    },
    {
        "content": "<p>Ah, my memory was off</p>",
        "id": 520283200,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171236
    },
    {
        "content": "<p>A modern CPU core can fit I think I counted a chunk of 1000 nodes and a chunk of 1000 extra_data into L1 cache and still have plenty of room for the stack</p>",
        "id": 520283202,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748171238
    },
    {
        "content": "<p>Something I guess I hadn't done yet was the extraction of all the bigger nodes to their own lists</p>",
        "id": 520283218,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171258
    },
    {
        "content": "<p>Basically, you have <code>data_1</code>, <code>data_2</code>, and <code>data_3</code> on every node. How few <code>data</code> fields could you get away with if you moved the bigger node types to their own arrays?</p>",
        "id": 520283297,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171324
    },
    {
        "content": "<p>I think that being able to just grab numbers off a chunk likely in L1 cache to lookup a node that is probably also in L1 cache is going to be ridiculously fast.</p>",
        "id": 520283299,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748171325
    },
    {
        "content": "<p>Yeah, I'll admit that I am much more strongly motivated by the \"have the code look like the domain model\" argument than the perf argument, and that first argument doesn't matter as much</p>",
        "id": 520283339,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171373
    },
    {
        "content": "<p>Both should be very fast, and your approach is <em>probably</em> faster</p>",
        "id": 520283348,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171391
    },
    {
        "content": "<p>You use three data <del>nodes</del> fields.  One is for primary data (the main business of the node), and data_2 and data_3 will be either used for ancillary data or storing a Span for accessing a chunk of extra_data that points to more nodes</p>",
        "id": 520283350,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748171392
    },
    {
        "content": "<p>You can look at how we store if_then_else exprs in the Parse IR</p>",
        "id": 520283429,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748171450
    },
    {
        "content": "<p><a href=\"https://github.com/roc-lang/roc/blob/main/src/check/parse/IR.zig#L1189\">https://github.com/roc-lang/roc/blob/main/src/check/parse/IR.zig#L1189</a> &lt;- Add the node</p>",
        "id": 520283463,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748171492
    },
    {
        "content": "<p>But if 50% of nodes only need 2 <code>data</code> fields, then you could save 4 / 2 = 2 bytes per IR node on average</p>",
        "id": 520283476,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171507
    },
    {
        "content": "<p><a href=\"https://github.com/roc-lang/roc/blob/main/src/check/parse/IR.zig#L1916\">https://github.com/roc-lang/roc/blob/main/src/check/parse/IR.zig#L1916</a> &lt;- Get the node</p>",
        "id": 520283492,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748171522
    },
    {
        "content": "<p><del>That's the same line number</del></p>",
        "id": 520283530,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171539
    },
    {
        "content": "<p>And then the owner of the IR can lazily grab the other bits as it needs it</p>",
        "id": 520283547,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748171565
    },
    {
        "content": "<p>I understand this</p>",
        "id": 520283560,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171585
    },
    {
        "content": "<p>snark not intended</p>",
        "id": 520283568,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171593
    },
    {
        "content": "<p>It's true, but then we would more likely have to create more nodes</p>",
        "id": 520283585,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748171625
    },
    {
        "content": "<p>It's relatively simple, yes, it just leaves us open to math errors in a way that a more typed approach doesn't</p>",
        "id": 520283586,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171626
    },
    {
        "content": "<p>It's probably not an exact science, but we can measure and adapt the size of the nodes as we find things working</p>",
        "id": 520283646,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748171652
    },
    {
        "content": "<p>Yes, agreed</p>",
        "id": 520283649,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171663
    },
    {
        "content": "<p>I think that this is a pretty modular part of the compiler</p>",
        "id": 520283658,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171674
    },
    {
        "content": "<p>The nice thing is the way things can go bad is small and it's limited to these API functiosn</p>",
        "id": 520283662,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748171678
    },
    {
        "content": "<p>So the surface error of type unsafety is very contained for the amount of simplicity we get</p>",
        "id": 520283704,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748171713
    },
    {
        "content": "<p>You just have to communicate that direct interaction with the underlying data should never be done</p>",
        "id": 520283717,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171729
    },
    {
        "content": "<p>This sounds like a job for Captain Encapsulation!</p>",
        "id": 520283725,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171744
    },
    {
        "content": "<p>I just want to trust that compiler devs are smart enough to understand that :-). And that thorough snapshot testing will have our backs</p>",
        "id": 520283779,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748171790
    },
    {
        "content": "<p>Well, better to not rely on trust</p>",
        "id": 520283788,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171807
    },
    {
        "content": "<p>I believe in our testing suite</p>",
        "id": 520283791,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748171818
    },
    {
        "content": "<p>And some asserts</p>",
        "id": 520283797,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748171822
    },
    {
        "content": "<p>maybe even a lot of asserts at scale</p>",
        "id": 520283803,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748171831
    },
    {
        "content": "<p>How would our testing suite prevent someone from directly reading/writing to an array?</p>",
        "id": 520283804,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171836
    },
    {
        "content": "<p>If you do something wrong - the snapshots will change in a pretty profound and noticable way</p>",
        "id": 520283817,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748171858
    },
    {
        "content": "<p>I think you can make things work properly by manually manipulating the data, even if it's more effort than using the provided APIs</p>",
        "id": 520283877,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171907
    },
    {
        "content": "<p>Do you think that encapsulation is actively bad here?</p>",
        "id": 520283882,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748171921
    },
    {
        "content": "<p>No, that's why I provide the API I do</p>",
        "id": 520284007,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748172093
    },
    {
        "content": "<p>Zig doesn't really believe in encapsulation</p>",
        "id": 520284017,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748172107
    },
    {
        "content": "<p>Yeah, that's the underlying issue, isn't it</p>",
        "id": 520284025,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748172117
    },
    {
        "content": "<p>Cause I'd say that API is only half of a solution, like a jar without a lid</p>",
        "id": 520284079,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748172134
    },
    {
        "content": "<p>Andrew seems to not be the biggest fan of the concept</p>",
        "id": 520284081,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748172136
    },
    {
        "content": "<p>You can't encapsulate without privacy</p>",
        "id": 520284088,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748172152
    },
    {
        "content": "<p>It's kind like, you wouldn't touch the <code>items</code> pointer in a slice, would you?</p>",
        "id": 520284092,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748172160
    },
    {
        "content": "<p>So much of the Rust compiler's development seemed to be done by people inferring how it worked based on what they saw in undocumented code</p>",
        "id": 520284146,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748172216
    },
    {
        "content": "<p>...</p>",
        "id": 520284159,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748172235
    },
    {
        "content": "<p>I guess if it's not a problem, it's not a problem</p>",
        "id": 520284171,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748172242
    },
    {
        "content": "<p>I'd just <em>always</em> look for a low-cost way to rely on zero trust, or less trust if that's what I can get</p>",
        "id": 520284252,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748172286
    },
    {
        "content": "<p>But Zig doesn't make that easy without awkwardly naming fields <code>itemsDontTouchMePlease</code></p>",
        "id": 520284281,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748172327
    },
    {
        "content": "<p>So maybe it's not worth it</p>",
        "id": 520284303,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748172334
    },
    {
        "content": "<p>I search for \"Andrew Kelley on Zig encapsulation\" and AI gave me this, I wonder if Andrew would agree with the slop:</p>\n<blockquote>\n<p>Andrew Kelley, the creator of the <a href=\"https://www.google.com/search?sca_esv=ac42a23dc90a30b7&amp;cs=1&amp;sxsrf=AE3TifOrpCBYYR6BkpWKt2sBMmxOtMLCCQ%3A1748172223621&amp;q=Zig+programming+language&amp;sa=X&amp;ved=2ahUKEwicpPqCwb6NAxVmvokEHeLCFW8QxccNegQIAhAB&amp;mstk=AUtExfALGH5_h8bEwomKcr_lPpNpg9eAqjlLOGUeJSKpWau_oI10U_tVnILPQuBwQV5ngm2dyMD26G0FgQ6-CorGxbiX6lFnT3bzGU8JHOA2MP1oeD1ny6xZceGV5nfeAob6SlGHPazqmcjvTKXPkIVms5HKEfi7VSw4cVlACkFYmemHDVi4oEygFJqDydNniJY7-jI2iVIFxNKsE4GfG090c_JXCtcDNopdzfm-k3m68KwYWfvYvNUqSPT_mpoB9En--YwzP7Q9PIJ8gZ-xh7zNEFjO4het9Y9PLTVOzNgCgF-kgw&amp;csui=3\">Zig programming language</a>, has not specifically addressed encapsulation in the same way as other languages like C++ or Java. However, Zig does offer features that enable encapsulation through other mechanisms. Kelley's focus is on a system-level programming language that emphasizes safety and performance, with encapsulation being a secondary concern. </p>\n<p>Here's a breakdown of how encapsulation works in Zig and what Kelley's perspective is:</p>\n<ol>\n<li>Encapsulation through Modules and Structures:</li>\n</ol>\n<ul>\n<li>Zig uses modules to group related functions and data, providing a basic level of encapsulation.</li>\n<li>Structures (like <code>struct</code>) are used to define data types, and while they don't have the same access modifiers as other languages, they can be used to create data-hiding mechanisms.</li>\n</ul>\n<ol start=\"2\">\n<li>Implicit vs. Explicit Encapsulation:</li>\n</ol>\n<ul>\n<li>Zig doesn't have explicit access modifiers (like <code>public</code>, <code>private</code>, <code>protected</code>).</li>\n<li>Encapsulation is achieved through a combination of module organization, structure definition, and coding practices.</li>\n</ul>\n<ol start=\"3\">\n<li>Kelley's Emphasis on Safety and Performance:</li>\n</ol>\n<ul>\n<li>Kelley's primary focus is on creating a language that is safe by default and provides excellent performance.</li>\n<li>This means that while encapsulation is important, it's not the central focus in the same way as in languages that prioritize object-oriented programming.</li>\n</ul>\n<ol start=\"4\">\n<li>Alternative Encapsulation Techniques:</li>\n</ol>\n<ul>\n<li>Zig developers can use techniques like using private functions within modules, using unions for data representation, and employing memory-safe allocation methods to achieve levels of encapsulation.</li>\n</ul>\n<ol start=\"5\">\n<li>Kelley's Views on Encapsulation:</li>\n</ol>\n<ul>\n<li>While Kelley doesn't have a strong emphasis on traditional object-oriented encapsulation, he does understand its importance in building complex and robust software.</li>\n<li>He has suggested that Zig's structure and module system allow for a reasonable degree of encapsulation without sacrificing the language's focus on safety and performance.</li>\n</ul>\n<p>In essence, Zig's approach to encapsulation is more functional and less object-oriented, with encapsulation being achieved through a combination of modules, structures, and coding practices. Kelley's focus on safety and performance means that while encapsulation is important, it's not the primary driver in the same way as in other languages.</p>\n</blockquote>",
        "id": 520284313,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748172344
    },
    {
        "content": "<p>A lot of what's said there mirrors my memory of what he has said on the topic before</p>",
        "id": 520284398,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748172396
    },
    {
        "content": "<p>And I know that big Zig users like TigerBeetle solve this through a HEAVY use of Asserts and some very sophisticated testing techniques</p>",
        "id": 520284464,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748172454
    },
    {
        "content": "<p>Here's his reason from the mouth (finger mouth?): <a href=\"https://github.com/ziglang/zig/issues/9909#issuecomment-942686366\">https://github.com/ziglang/zig/issues/9909#issuecomment-942686366</a></p>",
        "id": 520284479,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748172470
    },
    {
        "content": "<blockquote>\n<p>the more effective strategy is to provide <strong>composable abstraction layers</strong>.</p>\n</blockquote>",
        "id": 520284574,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748172554
    },
    {
        "content": "<p>The current IR feels like it follows that better by not requiring the half of encapsulation that Zig lets us implement, but again, it should be <em>good enough</em> to do it the way you've outlined, as well as faster and in line with the proven effective approach in the parse code</p>",
        "id": 520284687,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748172660
    },
    {
        "content": "<p>We could try this approach if you are really concerned: <a href=\"https://github.com/ziglang/zig/issues/9909#issuecomment-2679366674\">https://github.com/ziglang/zig/issues/9909#issuecomment-2679366674</a></p>",
        "id": 520284715,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748172693
    },
    {
        "content": "<p>Lmao let's not</p>",
        "id": 520284730,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748172711
    },
    {
        "content": "<p>I'm not really concerned. I'm continuing this conversation because it seems like you're more interested in us finding alignment, but I don't strongly hold my fundamentally different opinion</p>",
        "id": 520284808,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748172766
    },
    {
        "content": "<p>It's pretty simple.  Just a bitCast inside every method that needs the private field (NodeStore here)</p>",
        "id": 520284809,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748172767
    },
    {
        "content": "<p>Cool</p>",
        "id": 520284818,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748172779
    },
    {
        "content": "<p>I'm just trying to ride with wave of what Zig does, and since I am working on it with very smart people - hoping that we will all be striving for understanding before moving and all row the boat in the right direction</p>",
        "id": 520284857,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748172842
    },
    {
        "content": "<p>Yeah, that's part of it, I like doing what Zig devs people would do, let's work with the language instead of against it</p>",
        "id": 520285039,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748172996
    },
    {
        "content": "<p>Agreed <span aria-label=\"handshake\" class=\"emoji emoji-1f91d\" role=\"img\" title=\"handshake\">:handshake:</span></p>",
        "id": 520285049,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748173016
    },
    {
        "content": "<p>But now my kids woke up, so I'll have to actually code later ;-)</p>",
        "id": 520285065,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748173037
    },
    {
        "content": "<p>kk</p>",
        "id": 520285066,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748173041
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"781658\">Anthony Bullard</span> <a href=\"#narrow/channel/395097-compiler-development/topic/zig.20compiler.20-.20desugaring/near/520281066\">said</a>:</p>\n<blockquote>\n<p>i still don't understand how we can do it in two syscalls with all of the pointers going on here</p>\n</blockquote>\n<p>Just to get back to this, the goal is to save/load cache data at a module level (and maybe for other data) as quickly possible. We can manually write serializers and deserializers to do this, but then they need to write to a file on the scale of bytes at a time, rather than all of the memory we care about all at once.</p>\n<p>Luckily for us, Richard had an idea (coming from discussion with Andrew, I think) that if all of the memory that we want to cache exists in one contiguous array, we can just write that to a file directly. And even better, we can read it directly back to memory on cache load with no deserialization step!</p>\n<p>This only works if we have all of the memory we want in a single block with no pointers (pointers will be wrong if the heap is different in different runs, but indices are fine). That's why <code>ModuleEnv</code> is owned by <code>can.IR</code>: then everything is in one place!</p>",
        "id": 520285271,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748173229
    },
    {
        "content": "<p>just a quick note - the approach <span class=\"user-mention\" data-user-id=\"341568\">@Jared Ramirez</span> used in <a href=\"https://github.com/roc-lang/roc/pull/7772\">https://github.com/roc-lang/roc/pull/7772</a> checks all these boxes!</p>",
        "id": 520288528,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748176216
    },
    {
        "content": "<ul>\n<li>everything is index-based</li>\n<li>types can be nested (just like the tree of canonical IR nodes)</li>\n<li>there is a statically-known number of pointers in the whole data structure (they're all <a href=\"https://github.com/roc-lang/roc/pull/7772/files#diff-1cd1b9ba7bb1e34989361cb881940bc31b7513ba1476d893cc0d82a65bd21606R49-R60\">right here</a>) so after the one read syscall, all we have to do is go update these 9 pointers and we're done - and it's always exactly 9 pointers, as opposed to having to traverse the entire structure and update a number of pointers that grows with the size of the deserialized data</li>\n</ul>",
        "id": 520288716,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748176424
    },
    {
        "content": "<p>Hmm, I thought the design of the new compiler's canonicalize pass was already very similar to just 'desugaring'. What's the delta between those?</p>",
        "id": 520478400,
        "sender_full_name": "Joshua Warner",
        "timestamp": 1748272693
    },
    {
        "content": "<p>That's likely what we will get Joshua</p>",
        "id": 520640996,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748344436
    },
    {
        "content": "<p>But right now I'm dealing with a clean compile that crashes with a SIGBUS error</p>",
        "id": 520641085,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748344452
    },
    {
        "content": "<p>So that's a lot of fun</p>",
        "id": 520641110,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748344458
    },
    {
        "content": "<p>Does zig crash or does our (partial) compilation of a roc file crash?</p>",
        "id": 520644110,
        "sender_full_name": "Anton",
        "timestamp": 1748345311
    },
    {
        "content": "<p>a test crashes</p>",
        "id": 520646243,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748345976
    },
    {
        "content": "<p>net new to my change</p>",
        "id": 520646266,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748345983
    },
    {
        "content": "<p>it's some sort of alignment issue, but it's not clear what's the cause</p>",
        "id": 520646403,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748346015
    },
    {
        "content": "<p>there is no stack trace</p>",
        "id": 520646436,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748346029
    },
    {
        "content": "<p>Sounds tough, I can take a look if you put up a branch :)</p>",
        "id": 520646600,
        "sender_full_name": "Anton",
        "timestamp": 1748346097
    },
    {
        "content": "<p>valgrind should help you get additional info</p>",
        "id": 520648260,
        "sender_full_name": "Anton",
        "timestamp": 1748346611
    },
    {
        "content": "<p>I've got a theory that I'll test, then try valgrind, then I'll phone a friend <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 520659095,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748349794
    },
    {
        "content": "<p>I'm going to have to push the branch anyway to run this on my Linux machine since I valgrind doesn't work on macos</p>",
        "id": 520659943,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748350031
    },
    {
        "content": "<p>Even tearing my test down to being pretty minimal (not calling the actual can method) I've went from SIGBUS to SIGSEGV to now a SIGTRAP</p>",
        "id": 520677031,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748354599
    },
    {
        "content": "<p>Back to seg fault :-)</p>",
        "id": 520680569,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748355559
    },
    {
        "content": "<p>It has something to do with deinit'ing an ArrayListUnmanaged</p>",
        "id": 520680611,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748355574
    },
    {
        "content": "<p>I'll have to figure it out tomorrow</p>",
        "id": 520680634,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748355581
    },
    {
        "content": "<p>This is a good thing for me to struggle with, since there is obviously something I don't understand</p>",
        "id": 520680685,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748355598
    },
    {
        "content": "<p>This might be why <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span> : </p>\n<blockquote>\n<p>Deinit levels backing arraylist with 16562106820025843780 items</p>\n</blockquote>",
        "id": 520684908,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748356737
    },
    {
        "content": "<p>What's weird is that it \"just happens all the sudden\", here's all the logs at every place we handle it until deinit'ing that array:</p>\n<blockquote>\n<p>Enter with 0 levels...Returning a scope with 1 levels...can has a scope with 1 levels...Deinit levels...Deinit levels backing arraylist with 7484431091188432957 items...Segmentation fault at address 0x67de0a6c582d003d</p>\n</blockquote>",
        "id": 520686947,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748357240
    },
    {
        "content": "<p>And you can see the number of items has changed, which tells me the items array has junk in it</p>",
        "id": 520687085,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748357280
    },
    {
        "content": "<p>That's also not addressable in even 64 bytes (7 quintillion???)</p>",
        "id": 520687406,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748357365
    },
    {
        "content": "<p>This code:</p>\n<div class=\"codehilite\" data-code-language=\"Zig\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kr\">var</span><span class=\"w\"> </span><span class=\"n\">can</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Self</span><span class=\"p\">.</span><span class=\"n\">init</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">can_ir</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">parse_ir</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"n\">std</span><span class=\"p\">.</span><span class=\"n\">debug</span><span class=\"p\">.</span><span class=\"n\">print</span><span class=\"p\">(</span><span class=\"s\">\"can has a scope with {d} levels...\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">.{</span><span class=\"n\">can</span><span class=\"p\">.</span><span class=\"n\">scope</span><span class=\"p\">.</span><span class=\"n\">levels</span><span class=\"p\">.</span><span class=\"n\">levels</span><span class=\"p\">.</span><span class=\"n\">items</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">});</span>\n<span class=\"w\">    </span><span class=\"n\">can</span><span class=\"p\">.</span><span class=\"n\">deinit</span><span class=\"p\">();</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Deinit for can</span>\n<span class=\"w\">    </span><span class=\"kr\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">deinit</span><span class=\"p\">(</span><span class=\"n\">self</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">std</span><span class=\"p\">.</span><span class=\"n\">debug</span><span class=\"p\">.</span><span class=\"n\">print</span><span class=\"p\">(</span><span class=\"s\">\"Can has a scope with {d} levels at deinit...\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">.{</span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">scope</span><span class=\"p\">.</span><span class=\"n\">levels</span><span class=\"p\">.</span><span class=\"n\">levels</span><span class=\"p\">.</span><span class=\"n\">items</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">});</span>\n<span class=\"w\">        </span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">scope</span><span class=\"p\">.</span><span class=\"n\">deinit</span><span class=\"p\">();</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n</code></pre></div>\n<p>Will produce this:</p>\n<blockquote>\n<p>can has a scope with 1 levels...Can has a scope with 4371552663 levels at deinit...</p>\n</blockquote>",
        "id": 520688397,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748357621
    },
    {
        "content": "<p>It's something with pointers....</p>",
        "id": 520689801,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748357954
    },
    {
        "content": "<p>It's that the Scope was created internally by Can in an init function, but not heap allocated so it fell off the stack and the pointer did in fact point to garbage.</p>",
        "id": 520698182,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748360143
    },
    {
        "content": "<p>Oh interesting</p>",
        "id": 520698350,
        "sender_full_name": "Anton",
        "timestamp": 1748360184
    },
    {
        "content": "<p>Yeah, the issue I have now is leaks.</p>",
        "id": 520764674,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748382557
    },
    {
        "content": "<p>There seems to be some contention between wanting the ModuleEnv to be owned by Can IR and not having issues with memory leaks</p>",
        "id": 520765352,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748382893
    },
    {
        "content": "<p>Or a skill issue on my part (probably the most likely answer)</p>",
        "id": 520765425,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748382930
    },
    {
        "content": "<p>And...I think I just solved it</p>",
        "id": 520765656,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748383042
    },
    {
        "content": "<p>Finally:</p>\n<div class=\"codehilite\"><pre><span></span><code>Build Summary: 4/4 steps succeeded; 117/117 tests passed\ntest success\n└─ run test 117 passed 318ms MaxRSS:3M\n   └─ zig test Debug native success 2s MaxRSS:535M\n      └─ options cached\n</code></pre></div>",
        "id": 520768031,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748384395
    },
    {
        "content": "<p>Updated my PR</p>",
        "id": 520769010,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748384963
    },
    {
        "content": "<p>And now....to actually do canonicalization stuff</p>",
        "id": 520769029,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748384976
    },
    {
        "content": "<p>for binops and unaries, two questions:</p>\n<ol>\n<li>should i desugar them to \"normal\" functions or special dispatch?</li>\n<li>if normal do i need to add the module that encloses that function to the imports?</li>\n</ol>",
        "id": 520772533,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748387368
    },
    {
        "content": "<p>and specifically for ?? do we want to continue desugaring to match or a function call?</p>",
        "id": 520772646,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748387429
    },
    {
        "content": "<p>i'm also assuming <code>return</code> will need to do a pretty substantial rewrite when desugaring?</p>",
        "id": 520772767,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748387524
    },
    {
        "content": "<p>normal functions by default, but not if control flow is involved</p>",
        "id": 520772939,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748387683
    },
    {
        "content": "<p><code>return</code> shouldn't be sugar, it should be a first-class thing</p>",
        "id": 520772960,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748387705
    },
    {
        "content": "<p>so <code>and</code>, <code>or</code>, <code>?</code>, and <code>??</code> all desugar to control flow</p>",
        "id": 520772985,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748387735
    },
    {
        "content": "<p>that said, I actually kinda wonder if we should skip desugaring until later</p>",
        "id": 520773214,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748387907
    },
    {
        "content": "<p>that said, I actually kinda wonder if we should skip desugaring until later</p>",
        "id": 520773223,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748387921
    },
    {
        "content": "<p>like just keep all of those first-class for now</p>",
        "id": 520773231,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748387937
    },
    {
        "content": "<p>in canonicalization</p>",
        "id": 520773245,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748387951
    },
    {
        "content": "<p>because we already do <code>CalledVia</code> to distinguish between plain function calls and desugared operators, so are we actually saving ourselves anything to desugar at this point, or are we just making <code>roc check</code> do unnecessary work?</p>",
        "id": 520773374,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748388065
    },
    {
        "content": "<p>when that work could be deferred to actual builds instead</p>",
        "id": 520773392,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748388086
    },
    {
        "content": "<p>Oh that would make can much simpler</p>",
        "id": 520773637,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748388244
    },
    {
        "content": "<p>If it's easy enough to type check those constructs, that's fine with me</p>",
        "id": 520773649,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748388260
    },
    {
        "content": "<p>I think as far as unifying types goes, <code>and</code>, <code>or</code>, <code>?</code> and <code>??</code> should be fine – we'll just have to internally give them the same type as what the functions they desugar to when generating constraints</p>",
        "id": 520774158,
        "sender_full_name": "Jared Ramirez",
        "timestamp": 1748388663
    },
    {
        "content": "<p>it feels like Can is doing work that 90% of which COULD be done at parse time</p>",
        "id": 520774752,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748389156
    },
    {
        "content": "<p><del>1 is Dispatch</del></p>",
        "id": 520774788,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748389177
    },
    {
        "content": "<p>The dispatch type checking should be checking the type of the first arg, so desugaring to a method call is just extra work for later</p>",
        "id": 520774933,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748389313
    },
    {
        "content": "<p>wait</p>",
        "id": 520775148,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748389489
    },
    {
        "content": "<p>Okay, so <code>foo.bar()</code> doesn't just desugar to <code>bar(foo)</code> or <code>foo-&gt;bar()</code> since it really means <code>Foo.bar(foo)</code></p>",
        "id": 520775205,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748389548
    },
    {
        "content": "<p>Meaning that if I write <code>foo + bar</code>, that needs to turn into <code>Foo.add(foo, bar)</code></p>",
        "id": 520775260,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748389576
    },
    {
        "content": "<p>I think there's a benefit to desugaring, because the <code>canonicalize</code> stage of the compiler is cached and the <code>resolve_imports</code> stage is not</p>",
        "id": 520775413,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748389705
    },
    {
        "content": "<p>Literally any work that we can do before caching without having to read any files outside of the current file should be done in <code>can</code> (and maybe a future <code>solo_typecheck</code>)</p>",
        "id": 520775451,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748389764
    },
    {
        "content": "<p>A more complex caching mechanism was discussed at some point to allow for caching of work from later stages  (at least <code>check_types</code>) to recognize a tree of dependencies, AKA if <code>Foo.roc</code> imports <code>Bar.roc</code> then <code>Foo.roc</code> can be loaded so long as <code>Bar.roc</code> hasn't changed</p>",
        "id": 520775696,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748389948
    },
    {
        "content": "<p>Anyway, for now, I think desugaring should be done at the beginning of or during <code>canonicalize</code> because it will almost always require less work overall</p>",
        "id": 520775756,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748390006
    },
    {
        "content": "<p>I dunno, I hear what you're saying Sam - but I'd like to try deferring it and see how it goes</p>",
        "id": 520775987,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748390225
    },
    {
        "content": "<p>maybe I'm wrong in practice but I'd like to try it that way as a first pass</p>",
        "id": 520776015,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748390261
    },
    {
        "content": "<p>We can definitely try it!</p>",
        "id": 520776104,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748390309
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"781658\">Anthony Bullard</span> <a href=\"#narrow/stream/395097-compiler-development/topic/zig.20compiler.20-.20desugaring/near/520774752\">said</a>:</p>\n<blockquote>\n<p>it feels like Can is doing work that 90% of which COULD be done at parse time</p>\n</blockquote>\n<p>you mean as in resolving names based on scope?</p>",
        "id": 520776152,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748390362
    },
    {
        "content": "<p>there's another piece we haven't gotten to, which is building a dependency graph between top level decls so we can sort them before type checking (which is very important for type checking correctness)</p>",
        "id": 520776560,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748390563
    },
    {
        "content": "<p>I presume you could do that by notating <em>any</em> idents used in the body of a decl and seeing what they point to, not needing to maintain a graph within the decls</p>",
        "id": 520776787,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748390725
    },
    {
        "content": "<p>I know you're more getting at the macro recipe of can, just throwing that out</p>",
        "id": 520776920,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748390804
    },
    {
        "content": "<p>right, I just mean conceptually</p>",
        "id": 520776992,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748390868
    },
    {
        "content": "<p>how do we solve for mutual recursion?</p>",
        "id": 520777626,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748391339
    },
    {
        "content": "<p>i thought the solve their was just walking the top level decls collecting the idents, and then just assigning each one a type var</p>",
        "id": 520777714,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748391384
    },
    {
        "content": "<p>and then walking them again to solve them</p>",
        "id": 520777738,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748391401
    },
    {
        "content": "<p>and then you just have to have cycle checking for condition less mutual recursion(no base case) like</p>\n<p>a = |x| b(x)<br>\nb = |x| a(x)</p>",
        "id": 520777989,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748391553
    },
    {
        "content": "<p>which is silly and diabolical if done earnestly</p>",
        "id": 520778130,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748391630
    },
    {
        "content": "<p>You look for SCCs</p>",
        "id": 520778217,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748391713
    },
    {
        "content": "<p>And think in terms of those, unless the SCC is size 1</p>",
        "id": 520778273,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748391728
    },
    {
        "content": "<p>Have you seen how we handle those in the Rust code?</p>",
        "id": 520778305,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748391752
    },
    {
        "content": "<p>I think recursion can be allowed if all the decls are functions, and pretty sure they are not allowed if they are all constants, not sure about a mix</p>",
        "id": 520778720,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1748392071
    },
    {
        "content": "<p>yep, exactly</p>",
        "id": 520782308,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748394608
    },
    {
        "content": "<p>ok, not familiar with the term SCC</p>",
        "id": 520783148,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748395114
    },
    {
        "content": "<p>you mean from graph theory?</p>",
        "id": 520783317,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748395223
    },
    {
        "content": "<p>strongly connected component</p>",
        "id": 520783322,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748395227
    },
    {
        "content": "<p>yeah</p>",
        "id": 520783325,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748395228
    },
    {
        "content": "<p>oh ok</p>",
        "id": 520783344,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748395241
    },
    {
        "content": "<p>i think i've implemented these without knowing they existed</p>",
        "id": 520783380,
        "sender_full_name": "Anthony Bullard",
        "timestamp": 1748395265
    },
    {
        "content": "<p>basically you input all the \"a depends on b\" relationships and it outputs all the groups of cycles</p>",
        "id": 520783419,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748395293
    },
    {
        "content": "<p>if a group has a size of 1 then it's not involved in any cycles</p>",
        "id": 520783447,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748395313
    },
    {
        "content": "<p>etc</p>",
        "id": 520783455,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1748395318
    }
]