[
    {
        "content": "<p>I plotted the mandelbrot set using Roc <a href=\"/user_uploads/22008/r8eHg6ETeFirMk6z2mqzOt04/Screen-Shot-2022-09-16-at-5.10.32-PM.png\">Screen-Shot-2022-09-16-at-5.10.32-PM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/22008/r8eHg6ETeFirMk6z2mqzOt04/Screen-Shot-2022-09-16-at-5.10.32-PM.png\" title=\"Screen-Shot-2022-09-16-at-5.10.32-PM.png\"><img src=\"/user_uploads/22008/r8eHg6ETeFirMk6z2mqzOt04/Screen-Shot-2022-09-16-at-5.10.32-PM.png\"></a></div>",
        "id": 299242074,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663362694
    },
    {
        "content": "<p>Would be very curious to do a performance comparison with other languages. I'm using the dumbest escape time algorithm possible.</p>",
        "id": 299242232,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663362775
    },
    {
        "content": "<p>cooooooooool!!!</p>",
        "id": 299243897,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1663363740
    },
    {
        "content": "<p>Nice!</p>",
        "id": 299243939,
        "sender_full_name": "Brian Carroll",
        "timestamp": 1663363761
    },
    {
        "content": "<p>I really want to try doing this properly perhaps using that Bevy platform <span class=\"user-mention\" data-user-id=\"462053\">@JanCVanB</span>  started working on.</p>",
        "id": 299243971,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663363775
    },
    {
        "content": "<p>Do you mean this Plotters platform? <a href=\"https://github.com/JanCVanB/roc-plotters\">https://github.com/JanCVanB/roc-plotters</a></p>",
        "id": 299248382,
        "sender_full_name": "jan kili",
        "timestamp": 1663366217
    },
    {
        "content": "<p>I'm currently updating it to work with latest Roc, so this is good timing</p>",
        "id": 299248414,
        "sender_full_name": "jan kili",
        "timestamp": 1663366232
    },
    {
        "content": "<p>(huh, why did I name the Bevy one \"bevies\", plural? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> foolish <a href=\"https://github.com/JanCVanB/roc-bevies\">https://github.com/JanCVanB/roc-bevies</a>)</p>",
        "id": 299248522,
        "sender_full_name": "jan kili",
        "timestamp": 1663366301
    },
    {
        "content": "<p><span aria-label=\"point of information\" class=\"emoji emoji-261d\" role=\"img\" title=\"point of information\">:point_of_information:</span> <span aria-label=\"surprise\" class=\"emoji emoji-1f62e\" role=\"img\" title=\"surprise\">:surprise:</span>  Whoa, that ascii mandelbrot is PRETTY, great job!</p>",
        "id": 299248601,
        "sender_full_name": "jan kili",
        "timestamp": 1663366326
    },
    {
        "content": "<p>Thanks. I had to set the complex plane to stretch to fit the plot, and ensure that the plot was exactly three times as wide as it is tall.</p>",
        "id": 299250196,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663367135
    },
    {
        "content": "<p>I saw the roc-plotters platform, but when I saw the line graphs I figured it might not be a good fit for plotting fractals. Maybe I was wrong about that tho! I figured the Bevy platform used for the breakout example would be a way to render actual pixels. </p>\n<p>I don't know Bevy at all but if it provided access to the GPU that would really unlock some performance. These plots are float-heavy.</p>",
        "id": 299250636,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663367406
    },
    {
        "content": "<p>When I get some time, I'd like to do ASCII versions in JS, Rust, and Haskell too. I'm extremely curious how Roc would compare considering how it did with quicksort.</p>",
        "id": 299250854,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663367586
    },
    {
        "content": "<p>I doubt I am smart enough to do it, but it would be interesting to see how close we could get to Kalles Fraktaler with Roc</p>",
        "id": 299251177,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663367824
    },
    {
        "content": "<p>But yeah if you think the plotters platform will work for this once you have it updated, I'll definitely do a version with that!</p>",
        "id": 299251280,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663367900
    },
    {
        "content": "<p>Take a look at the scatter example, it hints at how the Plotters lib can do WAY more than I integrated with</p>",
        "id": 299251501,
        "sender_full_name": "jan kili",
        "timestamp": 1663368068
    },
    {
        "content": "<p>And the Plotters rust library in general - it might be simpler to extend that platform than bevy, but only if you have no bevy experience like I don't</p>",
        "id": 299251942,
        "sender_full_name": "jan kili",
        "timestamp": 1663368377
    },
    {
        "content": "<p>Either way, help advancing any aspect of those visualization platforms is very welcome!!</p>",
        "id": 299251979,
        "sender_full_name": "jan kili",
        "timestamp": 1663368413
    },
    {
        "content": "<p>Good point about the GPU...</p>",
        "id": 299252040,
        "sender_full_name": "jan kili",
        "timestamp": 1663368464
    },
    {
        "content": "<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 299252050,
        "sender_full_name": "jan kili",
        "timestamp": 1663368473
    },
    {
        "content": "<p>@ me with any questions or ideas! I'm happy to review code, contribute, etc</p>",
        "id": 299262759,
        "sender_full_name": "jan kili",
        "timestamp": 1663378317
    },
    {
        "content": "<p>Sweet!</p>",
        "id": 299264844,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663380449
    },
    {
        "content": "<p>Update: created a repo and added a couple additional implementations in Rust and JS.  <a href=\"https://github.com/sandprickle/fROCtals\">https://github.com/sandprickle/fROCtals</a></p>",
        "id": 299354654,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663441391
    },
    {
        "content": "<p>Set up all three implementations to create identical plots, with max iterations set to 1M. <br>\nOn my M1 Macbook Air, I got the following results:</p>\n<p>JS (Node v16): ~10.3 s<br>\nRoc: ~ 4.62 s<br>\nRust: ~ 4.57 s</p>\n<p>So my question is: Is Roc just that fast, or did I fail to optimize the Rust version properly?</p>",
        "id": 299355189,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663441740
    },
    {
        "content": "<p>doesn't look like anything is obviously inefficient in the rust code</p>",
        "id": 299355786,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1663442249
    },
    {
        "content": "<p>so if you ran a release build then yes</p>",
        "id": 299355813,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1663442278
    },
    {
        "content": "<p>the code here is very simple, so roc and rust should produce pretty much the same thing (because both use llvm)</p>",
        "id": 299355879,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1663442299
    },
    {
        "content": "<p>Cool. Would you consider this to be an algorithm that would typically be pathological for a pure functional language, or not so much? </p>\n<p>IOW, is this a good showcase of the optimizations you‚Äôve done with the Roc compiler?</p>",
        "id": 299356161,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663442556
    },
    {
        "content": "<p>not in terms of performance I think? but the sort of \"textbook implementation\" is easier in roc I think</p>",
        "id": 299356618,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1663442984
    },
    {
        "content": "<p>I'd be interested to see how haskell fares, in particular when you don't try too hard to optimize</p>",
        "id": 299356688,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1663443014
    },
    {
        "content": "<p>I was thinking I‚Äôd do one in Haskell next</p>",
        "id": 299356885,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663443187
    },
    {
        "content": "<p>Do you think something along the lines of my Roc implementation would be sufficiently naive for the Haskell implementation?</p>",
        "id": 299356959,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663443246
    },
    {
        "content": "<p>yes  I think that would be interesting</p>",
        "id": 299356978,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1663443284
    },
    {
        "content": "<p>Cool. That‚Äôs next on my list then.</p>",
        "id": 299356995,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663443299
    },
    {
        "content": "<p>in particular: we see how ghc does versus llvm on this problem, and how good/bad the roc stdlib is versus the haskell one</p>",
        "id": 299357020,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1663443321
    },
    {
        "content": "<p>I made it to chapter 4 or so of Graham Hutton‚Äôs Haskell book, and that was probably a year ago or more. We‚Äôll see how far I get with it.</p>",
        "id": 299357457,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663443670
    },
    {
        "content": "<p>So standard prelude is what you‚Äôre more curious about? That‚Äôs what Haskell calls their stdlib right?</p>",
        "id": 299357488,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663443704
    },
    {
        "content": "<p>yeah</p>",
        "id": 299357499,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1663443713
    },
    {
        "content": "<p>Cool, I don‚Äôt know how to use alternate preludes anyway üòÖ</p>",
        "id": 299357551,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663443739
    },
    {
        "content": "<p>one advantage that the more modern preludes may have is that they use <code>Text</code> instead of <code>String</code> (i.e. a linked list of characters, a bad idea)</p>",
        "id": 299357582,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1663443775
    },
    {
        "content": "<p>for the rest of the code, I don't think a more modern prelude would change anything</p>",
        "id": 299357604,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1663443795
    },
    {
        "content": "<p>but haskell does have mutable vectors in the prelude somewhere, which might be an improvement, but those are so obscure that I'd say it doesn't really count as idiomatic haskell</p>",
        "id": 299357641,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1663443834
    },
    {
        "content": "<p>I was about to ask whether I should use the default list or one of the vectors.</p>",
        "id": 299357726,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663443868
    },
    {
        "content": "<p>I‚Äôm curious to try both.</p>",
        "id": 299357743,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663443879
    },
    {
        "content": "<p>Using a list puts idiomatic Haskell against idiomatic Roc, while using a vector would highlight more of the overhead/optimization differences when using the same data structures.</p>",
        "id": 299357887,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663444016
    },
    {
        "content": "<p>Or similar, I guess. Not sure if haskell vectors would be on the stack like the arrays I used in the Rust version.</p>",
        "id": 299357922,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663444059
    },
    {
        "content": "<p>I don't think they would be</p>",
        "id": 299358297,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1663444392
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"522634\">@Bryce Miller</span> that's a very cool result! Would you mind if I share a screenshot of your post with the numbers?</p>",
        "id": 299364419,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1663449827
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281383\">@Richard Feldman</span> Don't mind at all! I also have some results from my desktop (Ryzen 3800X) which shows a larger difference between Roc and Rust.</p>",
        "id": 299364548,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663449950
    },
    {
        "content": "<p>3800X results (Fedora)<br>\nJS: ~ 9 s (not super consistent)<br>\nRoc: ~ 3.16 s<br>\nRust: ~ 2.86 s</p>",
        "id": 299364770,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663450134
    },
    {
        "content": "<p>Odd that JS didn't get much faster <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 299364807,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663450163
    },
    {
        "content": "<p>How was/is your initial/current developer experience? Docs, syntax, compiler, etc</p>",
        "id": 299365975,
        "sender_full_name": "jan kili",
        "timestamp": 1663451225
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"522634\">@Bryce Miller</span> I bet the gap will be much bigger if you do like 1000 elements, because then the jit wouldn't kick in</p>",
        "id": 299366748,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1663451874
    },
    {
        "content": "<p>(the gap between JS and the others, I mean - Roc doesn't use a JIT)</p>",
        "id": 299366808,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1663451904
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281383\">@Richard Feldman</span> You mean using a smaller array, or fewer iterations, or both? Maybe I can add a cli arg to all the implementations to set the iteration count.</p>",
        "id": 299369280,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663454089
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"462053\">@JanCVanB</span> the biggest thing I wanted was hover definitions so I could check type signatures. Format on save would be really nice, but at least Roc has a built-in formatter. I‚Äôm still fighting to get a haskell formatter working with nvim. Coffeescript syntax highlighting kinda breaks with backpassing, so I switched to the VScode extension that someone made. Less robust, but at least I don‚Äôt get a lot of red with backpassed functions. </p>\n<p>Speaking of backpassing, that‚Äôs going to take some getting used to. Coming from Elm, a lot of the other characteristics of the language are pretty intuitive. Backpassing syntax still hurts my brain a little bit.</p>",
        "id": 299369587,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663454465
    },
    {
        "content": "<p>you don't need to use it, especially for the list stuff</p>",
        "id": 299369700,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1663454581
    },
    {
        "content": "<p>Yeah, I don't feel like this little script really needed it. I included it in one place just to try getting used to the syntax. Once my brain is able to decode it quickly, I think it will be a very welcome feature. Indentation hell is real.</p>",
        "id": 299369786,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663454663
    },
    {
        "content": "<p>On that note, really grateful that local values don't have an additional level of indentation like they do in Elm's <code>let...in</code>.</p>",
        "id": 299369887,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663454766
    },
    {
        "content": "<p>Oh, and docs were pretty good. The function signature for List.mapWithIndex I think could use a set of parens for the callback tho?</p>",
        "id": 299369917,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663454824
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"522634\">@Bryce Miller</span> I meant smaller number of iterations - like 1000 instead of 1M</p>",
        "id": 299369935,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1663454861
    },
    {
        "content": "<p>wow a time-traveling message</p>",
        "id": 299370010,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1663454917
    },
    {
        "content": "<p>Might be useful to have a link to <a href=\"http://roc-lang.org/builtins\">roc-lang.org/builtins</a> tutorial though? I had to rummage through Zulip to find it.</p>",
        "id": 299370033,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663454955
    },
    {
        "content": "<p>yeah that was weird haha, not sure why it repeated much later</p>",
        "id": 299370037,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1663454960
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"522634\">@Bryce Miller</span> that's a good call! I can add a link to it in the readme</p>",
        "id": 299370045,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1663454985
    },
    {
        "content": "<p>you've heard of time-traveling debuggers. now get ready for... time traveling zulip chats!</p>",
        "id": 299370049,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663454997
    },
    {
        "content": "<p>I'll do some runs with 1k iterations and see what happens!</p>",
        "id": 299370111,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663455042
    },
    {
        "content": "<p>btw <code>hyperfine</code> is an excellent tool for running benchmarks like this</p>",
        "id": 299370256,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1663455206
    },
    {
        "content": "<p>don't want to be doing <a href=\"https://www.youtube.com/watch?v=r-TLSBdHe1A\">eyeball statistics</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"r-TLSBdHe1A\" href=\"https://www.youtube.com/watch?v=r-TLSBdHe1A\"><img src=\"https://uploads.zulipusercontent.net/06bee759c1dbe2c4354c820cedf34a8b3c178c93/68747470733a2f2f692e7974696d672e636f6d2f76692f722d544c534264486531412f64656661756c742e6a7067\"></a></div>",
        "id": 299370316,
        "sender_full_name": "Folkert de Vries",
        "timestamp": 1663455245
    },
    {
        "content": "<p>I think I was looking at user time only, not total time for the numbers I provided above (using the <code>time</code> command I think built in to zsh?).  I'll definitely re-run these benchmarks using hyperfine. Thanks for the suggestion!</p>\n<p>Looking at <em>total</em> time using the <code>time</code> command,  1k iterations makes JS roughly an order of magnitude slower. Roc and Rust are hovering around 0.005s, where JS is around 0.045s.</p>",
        "id": 299370963,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663455955
    },
    {
        "content": "<p>I wonder how much of that is js engine startup time and such.</p>",
        "id": 299373251,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1663458835
    },
    {
        "content": "<p>Like how long does Js take with 0 and 1 loop iterations?</p>",
        "id": 299373349,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1663458934
    },
    {
        "content": "<p>Added some benchmarks via hyperfine to the repo.</p>",
        "id": 299379741,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663466768
    },
    {
        "content": "<p>I‚Äôll try to do some with 1 iteration too. I mainly included JS as a reference ‚Äúslow‚Äù language.</p>",
        "id": 299379840,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663466902
    },
    {
        "content": "<p>Awesome. Interested to see the results. Can make some pretty graphs as the number of iterations increase</p>",
        "id": 299379952,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1663467065
    },
    {
        "content": "<p>I have the Haskell implementation nearly done too. Either I messed up the algorithm or I‚Äôm making some rookie Haskell mistakes. Or both.</p>",
        "id": 299380483,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663467796
    },
    {
        "content": "<p><a href=\"/user_uploads/22008/auorR2DcEarUYm3bO9wnJknV/Screen-Shot-2022-09-18-at-1.44.25-PM.png\">Screen-Shot-2022-09-18-at-1.44.25-PM.png</a> Apple M1 results with 1K iterations including Haskell,  via hyperfine</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/22008/auorR2DcEarUYm3bO9wnJknV/Screen-Shot-2022-09-18-at-1.44.25-PM.png\" title=\"Screen-Shot-2022-09-18-at-1.44.25-PM.png\"><img src=\"/user_uploads/22008/auorR2DcEarUYm3bO9wnJknV/Screen-Shot-2022-09-18-at-1.44.25-PM.png\"></a></div>",
        "id": 299460131,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663523139
    },
    {
        "content": "<p><a href=\"/user_uploads/22008/qeMhaZZMtT-gITVO5jo4rsRh/Screen-Shot-2022-09-18-at-1.45.59-PM.png\">Screen-Shot-2022-09-18-at-1.45.59-PM.png</a> AMD Ryzen 3800X results including Haskell, via hyperfine</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/22008/qeMhaZZMtT-gITVO5jo4rsRh/Screen-Shot-2022-09-18-at-1.45.59-PM.png\" title=\"Screen-Shot-2022-09-18-at-1.45.59-PM.png\"><img src=\"/user_uploads/22008/qeMhaZZMtT-gITVO5jo4rsRh/Screen-Shot-2022-09-18-at-1.45.59-PM.png\"></a></div>",
        "id": 299460240,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663523202
    },
    {
        "content": "<p>Using default Prelude for Haskell, no vectors. Completely unoptimized to the best of my knowledge.</p>",
        "id": 299460309,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663523257
    },
    {
        "content": "<p>Next up is to accept cli param for iteration count so I can use hyperfine to generate data</p>",
        "id": 299460421,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663523301
    },
    {
        "content": "<p>From a random post online about Haskel:</p>\n<blockquote>\n<p>There is no such thing as \"release mode\". Perhaps you want to enable more optimization? In that case, pass in --ghc-options -O2. Alternatively, add -O2 to ghc-options: in your cabal file.</p>\n</blockquote>",
        "id": 299461282,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1663523839
    },
    {
        "content": "<p>Oh interesting. I was wondering whether there was a flag I should be using for a production build. I know almost nothing about Haskell.</p>",
        "id": 299463284,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663525015
    },
    {
        "content": "<p>Ok that's actually a substantial improvement.</p>",
        "id": 299463693,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663525247
    },
    {
        "content": "<p><a href=\"/user_uploads/22008/YDbOy7sSLVlqyJIkvKbnivco/Screen-Shot-2022-09-18-at-2.22.50-PM.png\">Screen-Shot-2022-09-18-at-2.22.50-PM.png</a> Apple M1 with <code>-O2</code> GHC option</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/22008/YDbOy7sSLVlqyJIkvKbnivco/Screen-Shot-2022-09-18-at-2.22.50-PM.png\" title=\"Screen-Shot-2022-09-18-at-2.22.50-PM.png\"><img src=\"/user_uploads/22008/YDbOy7sSLVlqyJIkvKbnivco/Screen-Shot-2022-09-18-at-2.22.50-PM.png\"></a></div>",
        "id": 299463957,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663525403
    },
    {
        "content": "<p>Oh wow, about 2x faster</p>",
        "id": 299464264,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1663525607
    },
    {
        "content": "<p>Yeah pretty surprising.</p>",
        "id": 299464307,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663525635
    },
    {
        "content": "<p>Would a substantially larger plot hurt the linked lists in Haskell more?  Maybe I can do some supersampling if the larger memory footprint would reveal something interesting.</p>",
        "id": 299464476,
        "sender_full_name": "Bryce Miller",
        "timestamp": 1663525750
    },
    {
        "content": "<p>I depends on the algorithm. Haven't actually read through your code, but i wouldn't expect any huge slowdown from larger lists</p>",
        "id": 299467325,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1663527946
    },
    {
        "content": "<p>But again, heavily depends on how the lists are being used</p>",
        "id": 299467337,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1663527959
    }
]