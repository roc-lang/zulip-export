[
    {
        "content": "<p>Just finished up <a href=\"https://github.com/mkalvas/aoc/blob/roc/src/2021/01/code.roc\">day 1</a> and <a href=\"https://github.com/mkalvas/aoc/blob/roc/src/2021/02/code.roc\">day 2</a>. Some random thoughts so far:</p>\n<ul>\n<li>The hardest part of actually using it for me so far has been not being able to see the inferred types of things I've written. I'm used to hovering for types in my IDE or being able to load the module in the repl and explore that way. It makes it harder to see the standard library's signatures to use them correctly or write type signatures of my own. I feel like I'm missing some obvious way to say \"show me what you think these types are\" with the command line. <strong>Important context</strong>: I can't get the editor to work on my machine since I'm also experiencing <a href=\"#narrow/stream/257722-editor/topic/error.20when.20starting.20on.20macOS\">this error</a>, so I was looking for some other options.</li>\n<li>Obviously there's still documentation and things that would go a long way as well. How to read files (for example) was a total unknown of just looking through some of the example code on GitHub and this forum.</li>\n<li>I find myself missing tuples a lot. Not sure if that will get better or worse as I use it more.</li>\n<li>I have some experience with Elixir, OCaml, Reason, and Haskell as well as a lot of non-FP languages. This has felt by far the closest to Elixir in my opinion (which makes sense) particularly with the heavy reliance on the pipe-forward (first param) operator. (<a href=\"https://github.com/mkalvas/aoc/blob/roc/src/2021/02/code.exs\">compare day 2 in elixir to the roc version</a>)</li>\n<li>I'm not sure I totally <strong><em>get</em></strong> the whole platform thing yet and how that would realistically work in a productive way.</li>\n<li>String parsing feels like it needs a less tedious pattern (being able to assign variables while destructuring into tuples, tags, or lists could help). Same with indexed list access. I definitely get the safety and everything, but for a lot of people in a lot of situations, making the call to use a simpler function that could crash your program is not just convenient, but actually a good idea. A CLI that parses a file should be able to just error out without handling it every step up the stack if the file is totally unusable. Maybe I'm just missing a panic/error function or something? (see note about docs)</li>\n<li>I think I like it. I'm not sure I feel that it does things better or in a way that would convert me to using it at work. Maybe understanding the platform stuff would help. I'm sure I'll get a better feel after using it more. There are certainly some things around the language and ecosystem that feel novel.</li>\n</ul>\n<p>Looking forward to continuing with it for a while this month. Hopefully I can help provide some feedback along the way.</p>\n<p>Most importantly, thank you for building something cool and sharing it with the world! I know it takes a lot of time, effort, and caring to work on all this.</p>\n<p>Roc on! <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> <img alt=\":roc:\" class=\"emoji\" src=\"https://zulip-avatars.s3.amazonaws.com/22008/emoji/images/18217.png\" title=\"roc\"> <span aria-label=\"rock on\" class=\"emoji emoji-1f918\" role=\"img\" title=\"rock on\">:rock_on:</span></p>",
        "id": 301994497,
        "sender_full_name": "Mike Kalvas",
        "timestamp": 1664768456
    },
    {
        "content": "<blockquote>\n<p>The hardest part of actually using it for me so far has been not being able to see the inferred types of things I've written. I'm used to hovering for types in my IDE or being able to load the module in the repl and explore that way.</p>\n</blockquote>\n<p>This is also the biggest pain point for me. It will be alleviated by the editor, but the editor hasn't been a priority for development recently, due to a variety of other things that have come up. I've written a small lsp server that queries the compiler for type information to make hover easier in the meantime, but to say it works well is an overstatement <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 302066380,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1664804643
    },
    {
        "content": "<blockquote>\n<p>I find myself missing tuples a lot. Not sure if that will get better or worse as I use it more.</p>\n</blockquote>\n<p>Tuples are planned to be supported, and should land relatively soon!</p>",
        "id": 302066445,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1664804665
    },
    {
        "content": "<blockquote>\n<p>being able to assign variables while destructuring into tuples, tags, or lists could help</p>\n</blockquote>\n<p>could you elaborate what you mean by this? does this go beyond destructuring assignments you can do in e.g. pattern matching?</p>",
        "id": 302066710,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1664804726
    },
    {
        "content": "<p>We technically already have a way to make tuples They just are witten weird. You have to use a tag. <code>T var1 var2 var3</code> or <code>Pair a b</code> you can pick any name you want as long as it starts with a capital letter. Then you can just destructure it to get the valued back out.</p>",
        "id": 302068780,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1664805410
    },
    {
        "content": "<p>at least this way we can finally agree on pronunciation, as <code>Tooooople a b</code> is different than <code>Tuhpul a b</code>.</p>",
        "id": 302068991,
        "sender_full_name": "Brian Hicks",
        "timestamp": 1664805472
    },
    {
        "content": "<p>I think having pattern matching would be great, but specifically for the string splitting case, I can typically split and assign to variables in a list or tuple at once.</p>\n<div class=\"codehilite\" data-code-language=\"Elixir\"><pre><span></span><code><span class=\"c1\"># elixir</span><span class=\"w\"></span>\n<span class=\"p\">[</span><span class=\"n\">cmd</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">String</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"n\">line</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"c1\">-- haskell</span><span class=\"w\"></span>\n<span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">cmd</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">break</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"sc\">' '</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">line</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"JavaScript\"><pre><span></span><code><span class=\"c1\">// js</span><span class=\"w\"></span>\n<span class=\"kd\">const</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"nx\">cmd</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">val</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nx\">line</span><span class=\"p\">.</span><span class=\"nx\">split</span><span class=\"p\">(</span><span class=\"s1\">' '</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"c1\"># roc</span><span class=\"w\"></span>\n<span class=\"nv\">lineToDir</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"nx\">line</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"nv\">result</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nv\">parts</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nx\">Str</span><span class=\"p\">.</span><span class=\"nx\">split</span><span class=\"w\"> </span><span class=\"nx\">line</span><span class=\"w\"> </span><span class=\"s\">\" \"</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">cmd</span><span class=\"w\"> </span><span class=\"o\">&lt;-</span><span class=\"w\"> </span><span class=\"nx\">List</span><span class=\"p\">.</span><span class=\"nx\">get</span><span class=\"w\"> </span><span class=\"nx\">parts</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"nx\">Result</span><span class=\"p\">.</span><span class=\"nx\">try</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">val</span><span class=\"w\"> </span><span class=\"o\">&lt;-</span><span class=\"w\"> </span><span class=\"nx\">List</span><span class=\"p\">.</span><span class=\"nx\">get</span><span class=\"w\"> </span><span class=\"nx\">parts</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"nx\">Result</span><span class=\"p\">.</span><span class=\"nx\">try</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">Ok</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nx\">Tuple</span><span class=\"w\"> </span><span class=\"nx\">cmd</span><span class=\"w\"> </span><span class=\"nx\">val</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"nx\">Result</span><span class=\"p\">.</span><span class=\"nx\">mapErr</span><span class=\"w\"> </span><span class=\"nx\">result</span><span class=\"w\"> </span><span class=\"err\">\\</span><span class=\"nx\">_</span><span class=\"w\"> </span><span class=\"nf\">-&gt;</span><span class=\"w\"> </span><span class=\"nx\">InvalidLine</span><span class=\"w\"> </span><span class=\"nx\">line</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I can see how this is more a conversation about safety than \"tuples\", but list/tuple destructuring is <em>very</em> common in most FP. Whether I just need to shift my mindset to using records more is one thing, but in this instance, it's obvious that there's a step in there no matter what because the <code>Str.split</code> returns a <code>List</code> which can't be destructured.</p>",
        "id": 302069867,
        "sender_full_name": "Mike Kalvas",
        "timestamp": 1664805719
    },
    {
        "content": "<p>For platforms, there are some talks linked on <a href=\"http://roc-lang.org\">roc-lang.org</a>. Those may help. If not, the main idea is just have a shell that manages all effects around a purely functional core. A platform is kinda like a runtime or framework. It enable roc to be a pure functional language while doing stuff. Of course there are other ways to create a similar abstraction, but generally that requires implementing all possible effects in the standard library. This also, hopefully, makes roc great for being a scripting language. For example, it could be used instead of Lua in a game.</p>",
        "id": 302069871,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1664805720
    },
    {
        "content": "<p>Try <code>Str.splitFirst</code> instead of <code>Str.split</code> if you want cleaner matching. But yeah, we don't have any list pattern matching yet and that is quite inconvenient.</p>",
        "id": 302070212,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1664805830
    },
    {
        "content": "<p>Even once we have list pattern mstching, i think it will still be more verbose due to needing to support error cases. Probably would require a when clause with a default case. Tuples, on the other hand, can just be pattern matched/destructured directly.</p>",
        "id": 302070553,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1664805945
    },
    {
        "content": "<p>I think I understand that aspect of platforms. It does seem like a cool idea. The part I'm interested in as a new Roc dev getting up and running is \"as someone who's trying to write a program in Roc, what platform do I pick?\" and \"what if I don't know how to code a platform but want to use Roc?\" It seems like the hopeful answer to this is that there will be many choices and that people will be able to recommend a good base platform.</p>\n<p>I think it might be outside the wheelhouse for a lot of users to discern between good platforms. Given the low level nature of platform code, I'd like a well-vetted platform that I can be reasonably sure doesn't contain horrible memory unsafe bugs and security holes. Having many community platforms seems to divide that attention and possibly allow bugs to exist longer without detection.</p>\n<p>I also wonder about what platforms will support. It seems like one well-written platform could become the default for so many people that it keeps growing features until it just becomes a \"standard runtime\" that a different language would have.</p>\n<p>Thanks for the rec on <code>splitFirst</code>.</p>\n<p>Expanding on the destructuring and pattern matching, this example comes from AoC 2021 day 2. Here's some haskell code that does this in a slightly less verbose way (whether that's good or not).</p>\n<div class=\"codehilite\" data-code-language=\"Haskell\"><pre><span></span><code><span class=\"nf\">parseDir</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">String</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">String</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"nf\">parseDir</span><span class=\"w\"> </span><span class=\"n\">line</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kr\">do</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">cmd</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">valStr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">break</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"sc\">' '</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">line</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">cmd</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">read</span><span class=\"w\"> </span><span class=\"n\">valStr</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n<span class=\"nf\">move</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Int</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">String</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Int</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"nf\">move</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"s\">\"up\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"nf\">move</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"s\">\"down\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"nf\">move</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"s\">\"forward\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"nf\">move</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"kr\">_</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n<span class=\"nf\">solve</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"p\">[(</span><span class=\"kt\">String</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"p\">)]</span><span class=\"w\"> </span><span class=\"ow\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">Int</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">Int</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"nf\">solve</span><span class=\"w\"> </span><span class=\"n\">dirs</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kr\">do</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kr\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">horiz</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">depth</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">aim</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"n\">foldl</span><span class=\"w\"> </span><span class=\"n\">move</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">dirs</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">horiz</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">aim</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">horiz</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">depth</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n<span class=\"nf\">main</span><span class=\"w\"> </span><span class=\"ow\">::</span><span class=\"w\"> </span><span class=\"kt\">IO</span><span class=\"w\"> </span><span class=\"nb\">()</span><span class=\"w\"></span>\n<span class=\"nf\">main</span><span class=\"w\"> </span><span class=\"ow\">=</span><span class=\"w\"> </span><span class=\"kr\">do</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">input</span><span class=\"w\"> </span><span class=\"ow\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">lines</span><span class=\"w\"> </span><span class=\"o\">&lt;$&gt;</span><span class=\"w\"> </span><span class=\"n\">readFile</span><span class=\"w\"> </span><span class=\"s\">\"input.txt\"</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">print</span><span class=\"w\"> </span><span class=\"o\">$</span><span class=\"w\"> </span><span class=\"n\">solve</span><span class=\"w\"> </span><span class=\"o\">$</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"n\">parseDir</span><span class=\"w\"> </span><span class=\"n\">input</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The interesting thing is that <code>break</code> will return <code>([], [])</code> for empty strings. We can then pass it forward to <code>move</code> and handle a malformed command as a no-op. I could see a real production system that would want to be able to ignore malformed inputs instead of error handling there.</p>\n<p>The other piece of this that I mentioned in the initial post was the option to pick erroring code. I did this here with the <code>read valStr :: Int</code>. I'm not trying to advocate for one side or the other though. I'm sure there's value to having <strong>none</strong> of this in a language. But it does help in some cases and it certainly helps with things that can crash and that's OK (e.g. a personal project that will only ever run on my machine).</p>",
        "id": 302076583,
        "sender_full_name": "Mike Kalvas",
        "timestamp": 1664807813
    },
    {
        "content": "<p>Your idea around platforms is pretty accurate. Though I don't expect a single standard platform to emerge. I think what is much more likely is that a standard platform or 2 will emerge per category. This is the standard web server platform, standard cli app platform, standard permission restricted cli app platform, standard 2d game platform, etc.</p>",
        "id": 302080324,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1664808875
    },
    {
        "content": "<p>The average Roc user should only have to search a platform repository, read some reviews (maybe sort by stars or something), and then pick a platform. They would be able to look at the fulls docs for its api, and use it by pointing their app at the url. They would not have to understand how it works under the hood.</p>",
        "id": 302080602,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1664808970
    },
    {
        "content": "<blockquote>\n<p>break will return ([], []) for empty strings</p>\n</blockquote>\n<p>We could propose an api change instead of returning a result for <code>Str.splitFirst</code>. Or maybe add a builtin like that if we want to avoid the failure case. Not sure the pros/cons. If you want, make a thread in <a class=\"stream\" data-stream-id=\"304641\" href=\"/#narrow/stream/304641-ideas\">#ideas</a></p>",
        "id": 302081210,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1664809162
    },
    {
        "content": "<p>Though also, you could just <code>Str.splitFirst someStr \" \" |&gt; Result.withDefault {before: \"\", after: \"\"}</code></p>",
        "id": 302081430,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1664809214
    },
    {
        "content": "<p>more verbose, but much more concise than pattern matching</p>",
        "id": 302081579,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1664809243
    },
    {
        "content": "<p>Yeah that <code>splitFirst</code> <code>Result.withDefault</code> kind of approach was kind of what I was alluding to about maybe just getting more in the record mindset. I'm happy to change my mindset for the opinions of the language because I think opinionated languages remove a lot of discussion/uncertainty noise for developers. I'll hold off on posting in #ideas until I've used it more and can form a better opinion.</p>",
        "id": 302082169,
        "sender_full_name": "Mike Kalvas",
        "timestamp": 1664809427
    },
    {
        "content": "<p>I am <em>very</em> pleasantly surprised that this:</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"nx\">something</span><span class=\"w\"> </span><span class=\"o\">&lt;-</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nx\">value</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"nx\">thingThatReturnsResult</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"nx\">convertResultToTask</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"nx\">await</span><span class=\"w\"></span>\n<span class=\"c1\"># ...</span><span class=\"w\"></span>\n</code></pre></div>\n<p>correctly desugars. this is amazing for clarity</p>",
        "id": 303530739,
        "sender_full_name": "Gabriel Pickl",
        "timestamp": 1665527247
    },
    {
        "content": "<p>Multi-line backpassing with pipelining....awesome. i never realized that worked.</p>",
        "id": 303531999,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1665527895
    },
    {
        "content": "<p>yeah my gut feeling was that it <em>wouldn't</em>, but while refactoring I just tried it on a whim</p>",
        "id": 303532172,
        "sender_full_name": "Gabriel Pickl",
        "timestamp": 1665528004
    },
    {
        "content": "<p>because at least from my understanding that actually needs some special handling (since the function from the backpass needs to be passed to the last call in the pipeline, not the result of the pipeline)</p>",
        "id": 303532249,
        "sender_full_name": "Gabriel Pickl",
        "timestamp": 1665528052
    },
    {
        "content": "<p>Tagged unions which can have aliased names are so nice. being able to have <code>Up</code> and <code>Up Nat</code> allows for a type of matching that i'm often missing in elm. of course, i'll have to see if that becomes a maintainability problem in larger applications... but since the compiler can fully resolve all the types i don't see this being more than a momentary confusion.</p>",
        "id": 303534848,
        "sender_full_name": "Gabriel Pickl",
        "timestamp": 1665529749
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"487580\">@Gabriel Pickl</span> curious about this last comment. Could you give an example?</p>",
        "id": 303840091,
        "sender_full_name": "Georges Boris",
        "timestamp": 1665670127
    }
]