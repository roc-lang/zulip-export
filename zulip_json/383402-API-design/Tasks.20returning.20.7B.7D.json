[
    {
        "content": "<p>Has there been any discussion for more convenient backpassing syntax when the task returns <code>{}</code>? I find it odd to have to write <code>_ &lt;- Stdout.line \"hello\" |&gt; Task.await</code>. I'm sure you all know that Haskell \"automatically\" handles <code>IO ()</code> in the do notation. I'm guessing this has been thought about and rejected?</p>",
        "id": 434503825,
        "sender_full_name": "drew",
        "timestamp": 1713621811
    },
    {
        "content": "<p>Hi drew,<br>\nWe created <a href=\"https://docs.google.com/document/d/1mTEZlOKqtMonmVsIGEC1A9ufs1TQHhVgZ52Vn-13GeU/edit#heading=h.8qhbfnuufxi9\">the <code>!</code> syntax</a> so you can avoid writing <code>_ &lt;-</code>. I believe most of it is (very recently) implemented, I'm not sure what from the design doc is still missing.</p>",
        "id": 434506087,
        "sender_full_name": "Anton",
        "timestamp": 1713623737
    },
    {
        "content": "<p>awesome thanks!</p>",
        "id": 434506202,
        "sender_full_name": "drew",
        "timestamp": 1713623843
    },
    {
        "content": "<p>oh wow, the <code>!</code> design is really nice. i like that it means everything looks like the direct style.</p>",
        "id": 434506604,
        "sender_full_name": "drew",
        "timestamp": 1713624195
    },
    {
        "content": "<p>the <code>with</code> syntax feels slightly awkward, but i like that <code>!</code> builds on <code>with</code>, and you'd _definitely_ want <code>with</code> for parsers imo.</p>",
        "id": 434506850,
        "sender_full_name": "drew",
        "timestamp": 1713624378
    },
    {
        "content": "<p>does <code>with</code> work for the entire following block? can you nest <code>with</code>s?</p>",
        "id": 434506884,
        "sender_full_name": "drew",
        "timestamp": 1713624415
    },
    {
        "content": "<p>one downside to removing backpassing is that if you want to interleave effects you need to use explicit callbacks, right?</p>",
        "id": 434506938,
        "sender_full_name": "drew",
        "timestamp": 1713624458
    },
    {
        "content": "<p>I think the current plan is to not add <code>with</code> unless it gains a really clear need.</p>",
        "id": 434507599,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1713624926
    },
    {
        "content": "<p>First we are making <code>!</code> special to only tasks</p>",
        "id": 434507619,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1713624944
    },
    {
        "content": "<p>Next thing we would consider is making <code>!</code> valid for any <code>andThen</code> style function on an opaque type (maybe a special case for result if needed). I don't think we can make it work with generic type aliases.</p>",
        "id": 434507905,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1713625006
    },
    {
        "content": "<p>After that, we would look into <code>with</code> if there is still need for more flexibility</p>",
        "id": 434508050,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1713625033
    },
    {
        "content": "<p>And yes, this means that callback need to be explicit otherwise. At least once back passing is removed</p>",
        "id": 434508077,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1713625067
    },
    {
        "content": "<p>got it, thanks.</p>",
        "id": 434520909,
        "sender_full_name": "drew",
        "timestamp": 1713635073
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/383402-API-Design/topic/Tasks.20returning.20.7B.7D/near/434507905\">said</a>:</p>\n<blockquote>\n<p>Next thing we would consider is making <code>!</code> valid for any <code>andThen</code> style function on an opaque type (maybe a special case for result if needed). I don't think we can make it work with generic type aliases.</p>\n</blockquote>\n<p>how would this look for a non-Task type?</p>",
        "id": 434522454,
        "sender_full_name": "drew",
        "timestamp": 1713636323
    },
    {
        "content": "<p>does this mean that whatever the returned type is, if it could be subsequently passed to that module's <code>andThen</code> function, you could use <code>!</code>?</p>",
        "id": 434522536,
        "sender_full_name": "drew",
        "timestamp": 1713636375
    },
    {
        "content": "<p>This has been discussed some, but is not nailed down. A big question is if we want the complexity it could bring to the type system or simply to have a basic rewrite rule like what you mentioned by calling the module's <code>andThen</code> function.</p>",
        "id": 434523286,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1713637003
    },
    {
        "content": "<p>this couldn't be implemented directly via abilities because of higher-kinded types, yeah?</p>",
        "id": 434523994,
        "sender_full_name": "drew",
        "timestamp": 1713637593
    },
    {
        "content": "<p>Exactly</p>",
        "id": 434524293,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1713637888
    },
    {
        "content": "<p>just when you thought you were out, monads pull you back in</p>",
        "id": 434528804,
        "sender_full_name": "drew",
        "timestamp": 1713642312
    },
    {
        "content": "<p>Yeah, maybe. Though having a single monad for a very specific scope is very different from totally generic monad use cases.</p>",
        "id": 434529190,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1713642675
    },
    {
        "content": "<p>Though how <code>!</code> and other syntax sugar work today, they are essentially macros. So they technically can skip past the type system and just generate something.</p>",
        "id": 434529222,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1713642718
    },
    {
        "content": "<p>totally agreed. i do think having <code>!</code> work with user defined types seems better.</p>",
        "id": 434529263,
        "sender_full_name": "drew",
        "timestamp": 1713642729
    },
    {
        "content": "<p>+1</p>",
        "id": 434529407,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1713642860
    },
    {
        "content": "<p>the <code>!</code> reminds me a bit of letops in ocaml</p>",
        "id": 434530182,
        "sender_full_name": "drew",
        "timestamp": 1713643634
    },
    {
        "content": "<p>I'm curious to see what specific use cases (if any) remain for user-defined types once we have shadowing and can use that for random number seeds</p>",
        "id": 434531462,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1713644870
    },
    {
        "content": "<p>the seed-passing style is very straightforward and composes trivially with tasks; the main ergonomics problem there is naming</p>",
        "id": 434531540,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1713644940
    },
    {
        "content": "<p>whereas the \"build up a big <code>Generator</code>\" style clashes with tasks regardless of whether it has <code>!</code> sugar - so I think once we have shadowing that will likely end up being the recommended style to use anyway</p>",
        "id": 434531621,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1713645007
    },
    {
        "content": "<p>and I don't think <code>!</code> would solve a significant pain point in parsers - e.g. Elm has neither that nor a backpassing equivalent and there doesn't seem to be demand for anything like that in Elm parsers</p>",
        "id": 434531688,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1713645091
    },
    {
        "content": "<p>so if we have shadowing I'm not really sure what the specific use cases would be, what the delta in experience would be between having <code>!</code> work and not work with those types, etc.</p>",
        "id": 434531742,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1713645127
    },
    {
        "content": "<p>interesting. what’s the “seed passing style”?</p>",
        "id": 434535498,
        "sender_full_name": "drew",
        "timestamp": 1713648913
    },
    {
        "content": "<p>and what do you mean by shadowing in this context?</p>",
        "id": 434535509,
        "sender_full_name": "drew",
        "timestamp": 1713648931
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/stream/383402-API-Design/topic/Tasks.20returning.20.7B.7D/near/434531462\">said</a>:</p>\n<blockquote>\n<p>I'm curious to see what specific use cases (if any) remain for user-defined types once we have shadowing and can use that for random number seeds</p>\n</blockquote>\n<p>I was thinking that if we have !-syntax for custom types, it might come in useful in the design of roc-ci. To replace the backpassing I'm using in the current design. This is an example pipeline definition in the current design:</p>\n<div class=\"codehilite\"><pre><span></span><code>buildAndTest : Ci.Job\nbuildAndTest =\n    repoDetails &lt;- Ci.step0 &quot;setup git&quot; Ci.setupGit\n    binary &lt;- Ci.step1 &quot;build binary&quot; buildBinary repoDetails\n    testsPass &lt;- Ci.step1 &quot;run tests&quot; runTests binary\n    _ &lt;- Ci.step2 &quot;release&quot; release binary testsPass\n    Ci.done\n</code></pre></div>\n<p>This is using backpassing to do what would be called a writer monad in Haskell. Every CI step you create is recorded into some internal data structure, from which the CI runner can later extract it.</p>\n<p>If the seed-passing-style is what I think it is, I imagine that might be an alternative here too. The internal data structure containing the steps would be passed explicitly around:</p>\n<div class=\"codehilite\"><pre><span></span><code>buildAndTest : Ci.Job\nbuildAndTest =\n    job = Ci.emptyJob\n    (repoDetails, job) = Ci.step0 job &quot;setup git&quot; Ci.setupGit\n    (binary, job) = Ci.step1 job &quot;build binary&quot; buildBinary repoDetails\n    (testsPass, job) = Ci.step1 job &quot;run tests&quot; runTests binary\n    (_, job) = Ci.step2 job &quot;release&quot; release binary testsPass\n    job\n</code></pre></div>\n<p>There is a downside to this approach though: it becomes possible to accidentally not record a CI step, particularly when you're not interested in the result of the CI step and so are <code>_</code>-ing part of the return value of that step anyway. For instance, this would be a version of the previous example where the <code>release</code> step at the end is dropped:</p>\n<div class=\"codehilite\"><pre><span></span><code>buildAndTest : Ci.Job\nbuildAndTest =\n    job = Ci.emptyJob\n    (repoDetails, job) = Ci.step0 job &quot;setup git&quot; Ci.setupGit\n    (binary, job) = Ci.step1 job &quot;build binary&quot; buildBinary repoDetails\n    (testsPass, job) = Ci.step1 job &quot;run tests&quot; runTests binary\n    _ = Ci.step2 job &quot;release&quot; release binary testsPass\n    job\n</code></pre></div>\n<p>Of course entirely different designs are possible too!</p>",
        "id": 434537126,
        "sender_full_name": "Jasper Woudenberg",
        "timestamp": 1713650571
    },
    {
        "content": "<p>One big outstanding question I have about roc is how application-wide config / data will be handled. I don’t love the Reader monad but I’m not sure what other options are available. Many use Task and rely on a specific effect from the platform?</p>",
        "id": 434537506,
        "sender_full_name": "drew",
        "timestamp": 1713650984
    },
    {
        "content": "<p>Another scenario where I think having <code>!</code> for custom types could come in useful: defining a custom <code>Task</code> type wrapping the future builtin, with tracing support.</p>\n<p>Suppose you want to create a platform that contains the following primitive for recording a span in a trace:</p>\n<div class=\"codehilite\"><pre><span></span><code>span : Str, Task val err -&gt; Task val err\n</code></pre></div>\n<p>In words: this takes a task and a string description, and would record how long the task takes to run. The platform could then add support for sending this data to some tracing platform where you can look at a flamegraph of your code.</p>\n<p>For this to work the <code>Task</code> would need to carry some metadata related to the current span:</p>\n<ul>\n<li>Either a unique ID for the current span or a mutable list of child spans, so the relation between spans in the trace tree is recorded.</li>\n<li>A timestamp representing the start time of the current span so we can calculate its duration when it ends.</li>\n</ul>\n<p>In the current design where platforms define their own <code>Task</code> type, platforms can define it to carry whatever metadata they like. If this is no longer possible because Task becomes a builtin (I'm not sure about this), another approach might be to define a custom <code>Task</code> type by wrapping the builtin one, though if <code>!</code> is not available for the custom <code>Task</code> type it would not be very ergonomic.</p>",
        "id": 434538102,
        "sender_full_name": "Jasper Woudenberg",
        "timestamp": 1713651637
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"463085\">drew</span> <a href=\"#narrow/stream/383402-API-Design/topic/Tasks.20returning.20.7B.7D/near/434537506\">said</a>:</p>\n<blockquote>\n<p>One big outstanding question I have about roc is how application-wide config / data will be handled. I don’t love the Reader monad but I’m not sure what other options are available. Many use Task and rely on a specific effect from the platform?</p>\n</blockquote>\n<p>for this use case I agree with Evan's advice for what to do in Haskell (where Reader and others are available): just pass it around!</p>",
        "id": 434542040,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1713656068
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/stream/383402-API-Design/topic/Tasks.20returning.20.7B.7D/near/434542040\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"463085\">drew</span> <a href=\"#narrow/stream/383402-API-Design/topic/Tasks.20returning.20.7B.7D/near/434537506\">said</a>:</p>\n<blockquote>\n<p>One big outstanding question I have about roc is how application-wide config / data will be handled. I don’t love the Reader monad but I’m not sure what other options are available. Many use Task and rely on a specific effect from the platform?</p>\n</blockquote>\n<p>for this use case I agree with Evan's advice for what to do in Haskell (where Reader and others are available): just pass it around!</p>\n</blockquote>\n<p>Doesn't this mean passing something like a database connection to most non-pure functions in a large-ish web application?</p>",
        "id": 434542088,
        "sender_full_name": "drew",
        "timestamp": 1713656147
    },
    {
        "content": "<p>yes, although with module params the passing doesn't have to be function-to-function, it can be module-to-module</p>",
        "id": 434542155,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1713656197
    },
    {
        "content": "<p>I suspect that would be the more common way to pass it around in Roc</p>",
        "id": 434542183,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1713656225
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"477725\">@Jasper Woudenberg</span> could it make sense in a CI platform to use <code>Task</code> instead of <code>Job</code>?</p>",
        "id": 434542187,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1713656240
    },
    {
        "content": "<p>alternatively, could an applicative-based API for <code>Job</code> make sense? Then you could use record builder syntax, and also the structure would be statically inspectable (so you could print out a build graph etc)</p>",
        "id": 434542253,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1713656292
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"477725\">Jasper Woudenberg</span> <a href=\"#narrow/stream/383402-API-Design/topic/Tasks.20returning.20.7B.7D/near/434537126\">said</a>:</p>\n<blockquote>\n<p>There is a downside to this approach though: it becomes possible to accidentally not record a CI step, particularly when you're not interested in the result of the CI step and so are <code>_</code>-ing part of the return value of that step anyway. For instance, this would be a version of the previous example where the <code>release</code> step at the end is dropped:</p>\n<p><div class=\"codehilite\"><pre><span></span><code>buildAndTest : Ci.Job\nbuildAndTest =\n    job = Ci.emptyJob\n    (repoDetails, job) = Ci.step0 job &quot;setup git&quot; Ci.setupGit\n    (binary, job) = Ci.step1 job &quot;build binary&quot; buildBinary repoDetails\n    (testsPass, job) = Ci.step1 job &quot;run tests&quot; runTests binary\n    _ = Ci.step2 job &quot;release&quot; release binary testsPass\n    job\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Would it make sense to catch this by linting <code>_ =</code>? I don't think there is much of a reason to write <code>_ =</code> in Roc if it means performing a pure computation and this discarding the result</p>",
        "id": 434543216,
        "sender_full_name": "timotree",
        "timestamp": 1713657351
    },
    {
        "content": "<p>yeah I think that's a reasonable warning in general <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>",
        "id": 434543372,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1713657493
    },
    {
        "content": "<blockquote>\n<p>could it make sense in a CI platform to use <code>Task</code> instead of <code>Job</code>?</p>\n</blockquote>\n<p>Just thinking out loud of use cases that I expect to hit this (not that they need <code>!</code>, but they could use backpassing today and <code>!</code> would be really nice):</p>\n<ol>\n<li>Task</li>\n<li>Any higher level abstraction that wraps Task</li>\n<li>Result: at least in complex functions without effects/Task</li>\n<li>Generators: sure rng can use shadowing and explicit state passing, but generators are nice. They also come in for arbitrary data generation from bytes like used in fuzzing.</li>\n<li>Streams with manual continuations might also fit to some extent</li>\n</ol>",
        "id": 434543856,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1713657932
    },
    {
        "content": "<p>Not sure if there are any common higher level wrappers of Result that would benefit from this.</p>",
        "id": 434543947,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1713658020
    },
    {
        "content": "<p>brief thoughts on those:</p>\n<ol>\n<li>(of course <code>Task</code> is definitely going to support it no matter what <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span>)</li>\n<li>\"Any higher level abstraction that wraps Task\" - in the past I've seen this used for simulating effects in tests, and logging effects, and in Roc we can do both of those without requiring wrappers. (Logging can be done by providing a function to the platform, which it can then call when executing the <code>Task</code> state machine.) I haven't heard of other use cases for wrapping <code>Task</code> that seem like a good idea, so I think the specifics matter on this one!</li>\n<li><code>Result</code> - neither Elm nor OCaml have sugar for this and it hasn't been an issue; I think it's fine if Roc doesn't have sugar for it either. Plus <code>Result</code> isn't opaque in Roc, so it can't get abilities, making it innately awkward for any kind of \"make <code>!</code> work with any type that has a particular ability\" design. If we really want it <em>just</em> for <code>Result</code> we can always discuss a <code>?</code> suffix in addition to <code>!</code></li>\n<li>Generators - to be clear, I think <code>Generator</code> is a good idea for reuse (and in that use case, it doesn't clash with <code>Task</code>), I'm specifically talking about the style of \"running\" the RNG where you wrap all the logic you want to do in a big <code>Generator</code> that you have no intention of reusing, just as a way of threading the seed around. That's the situation where you can absolutely clash with <code>Task</code>, and where using <code>seed</code> instead doesn't have that problem.</li>\n<li>Streams - is that stream in the sense of \"iterators,\" or in the sense of like \"streaming I/O\"?</li>\n</ol>",
        "id": 434545113,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1713659220
    },
    {
        "content": "<blockquote>\n<p>Logging can be done by providing a function to the platform, which it can then call when executing the <code>Task</code> state machine.</p>\n</blockquote>\n<p>That may not give you the selective logging control you want. It also makes logging depend on the platform. It would be much nicer to build a logging library in roc that creates some form of logging task that simply has to know what effect to run for various kinds of logging. So I do think there is a rather large unlock here from allowing the wrapping.</p>\n<blockquote>\n<p>I haven't heard of other use cases for wrapping <code>Task</code> that seem like a good idea</p>\n</blockquote>\n<p>Yeah, not fully sure, the CI Job and general graph building + task style seems to be where this would most likely come up.</p>\n<blockquote>\n<p>I'm specifically talking about the style of \"running\" the RNG where you wrap all the logic you want to do in a big <code>Generator</code> that you have no intention of reusing, just as a way of threading the seed around. That's the situation where you can absolutely clash with <code>Task</code>, and where using <code>seed</code> instead doesn't have that problem.</p>\n</blockquote>\n<p>I was specifically think about where you define a generator per type and they are composable. So an outer generator composes many sub generators. I guess it probably could all be direct calls. Past hiding state, I'm not sure if there is a major difference in apis.</p>\n<blockquote>\n<p>is that stream in the sense of \"iterators,\"</p>\n</blockquote>\n<p>Kinda. I was more specifically thinking lazy data creation. Made by a chain of continuations.</p>",
        "id": 434545622,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1713659780
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/stream/383402-API-Design/topic/Tasks.20returning.20.7B.7D/near/434545113\">said</a>:</p>\n<blockquote>\n<ol start=\"3\">\n<li><code>Result</code> - neither Elm nor OCaml have sugar for this and it hasn't been an issue; I think it's fine if Roc doesn't have sugar for it either. Plus <code>Result</code> isn't opaque in Roc, so it can't get abilities, making it innately awkward for any kind of \"make <code>!</code> work with any type that has a particular ability\" design. If we really want it <em>just</em> for <code>Result</code> we can always discuss a <code>?</code> suffix in addition to <code>!</code></li>\n</ol>\n</blockquote>\n<p><code>letops</code> are a syntax for this in ocaml that can work with user-defined types, right? and <code>let-ppx</code> was before <code>letops</code> were directly supported.</p>",
        "id": 434548673,
        "sender_full_name": "drew",
        "timestamp": 1713662935
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/383402-API-Design/topic/Tasks.20returning.20.7B.7D/near/434545622\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Logging can be done by providing a function to the platform, which it can then call when executing the <code>Task</code> state machine.</p>\n</blockquote>\n<p>That may not give you the selective logging control you want. It also makes logging depend on the platform. It would be much nicer to build a logging library in roc that creates some form of logging task that simply has to know what effect to run for various kinds of logging. So I do think there is a rather large unlock here from allowing the wrapping.</p>\n</blockquote>\n<p>there's a deeper discussion to be had on the topic of logging, but briefly - given that platforms can already log all I/O (and give application authors a way to specify how they want each particular I/O operation to be logged), I'm skeptical that it's really beneficial to be able to say \"okay <em>this exact</em> HTTP request should be at a different log level than <em>this exact</em> other HTTP request\" as opposed to (for example) filtering the logs in some other way, or setting the level as a function of information contained in the the HTTP request itself (e.g. if the URL is going to some known third-party analytics domain, those requests can always be set to a lower log level)</p>",
        "id": 434558704,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1713674371
    },
    {
        "content": "<p>regarding OCaml, I actually don't know anything about <code>letops</code> or <code>let-ppx</code> <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 434558720,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1713674392
    },
    {
        "content": "<p>We'll have to see in practice once we have module params. My gut feel is that platform logging support will be adhoc and inconsistent. Including, I would guess that many platforms won't have proper logging at all. As such, it will be nicer to just call <code>Stderr.line</code> or <code>File.write</code> or <code>Http.push</code> to send logs. Then it will be nicer to wrap that up in a shared library that takes in the logging primitive as a module param task. I think that is the most likely way to get a really nice and consistent logging experience that can be attached to any platform with some sort of text output primitive.</p>",
        "id": 434559603,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1713675476
    },
    {
        "content": "<p>That said, I'm not sure that you will actually need any special form of wrapping task for that.</p>",
        "id": 434559678,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1713675569
    },
    {
        "content": "<p>So it may not need any sort of special <code>!</code></p>",
        "id": 434559683,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1713675580
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/stream/383402-API-Design/topic/Tasks.20returning.20.7B.7D/near/434558720\">said</a>:</p>\n<blockquote>\n<p>regarding OCaml, I actually don't know anything about <code>letops</code> or <code>let-ppx</code> <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n</blockquote>\n<p>Here's a little example I put together to show how <code>letops</code> work -- <a href=\"https://gist.github.com/drewolson/5405ad83e5303026650d4015d185490c\">https://gist.github.com/drewolson/5405ad83e5303026650d4015d185490c</a></p>",
        "id": 434601319,
        "sender_full_name": "drew",
        "timestamp": 1713716615
    },
    {
        "content": "<p>It feels worth explaining as <code>letops</code> actually feel pretty close to what you're describing with <code>!</code> -- they work as basically \"rewrites\". They effectively make callback based code look like the direct style, using whatever definition of <code>let*</code> (or other <code>let</code>-style functions) are in scope.</p>",
        "id": 434601430,
        "sender_full_name": "drew",
        "timestamp": 1713716690
    },
    {
        "content": "<p>in the example I show using <code>let*</code> (direct-style bind) for both lists and options, just as an example</p>",
        "id": 434601447,
        "sender_full_name": "drew",
        "timestamp": 1713716707
    },
    {
        "content": "<p>the annoying downside is that you must explicitly bring into scope the particular implementation you want for a given function</p>",
        "id": 434601475,
        "sender_full_name": "drew",
        "timestamp": 1713716734
    },
    {
        "content": "<p>that said, at least it is explicit. it feels very similar to the proposal for <code>with</code> and <code>?</code>.</p>",
        "id": 434601499,
        "sender_full_name": "drew",
        "timestamp": 1713716757
    },
    {
        "content": "<p>the same tools are used for applicative-style APIs via the conventionally named <code>let+</code> and <code>and+</code></p>",
        "id": 434601775,
        "sender_full_name": "drew",
        "timestamp": 1713716976
    },
    {
        "content": "<p>here's an example of an applicative-style parser using <code>letops</code> and the <code>angstrom</code> library <a href=\"https://gist.github.com/drewolson/1776047f9ac00d51df8a7a36deb2fda6\">https://gist.github.com/drewolson/1776047f9ac00d51df8a7a36deb2fda6</a></p>",
        "id": 434602522,
        "sender_full_name": "drew",
        "timestamp": 1713717675
    },
    {
        "content": "<p>the comparisons to ocaml feel useful as it is a language without ad hoc polymorphism at all :) but i get that the design goals of roc differ. just wanted it here as a comparison / prior art.</p>",
        "id": 434602646,
        "sender_full_name": "drew",
        "timestamp": 1713717816
    },
    {
        "content": "<p>Writing this small parser also made me remember how much i dislike full type inference in ocaml, related to one of the disadvantages of HKP in the FAQ. If I accidentally forget the labeled argument to <code>Angstrom.parse_string</code>, here's the helpful error message I get:</p>",
        "id": 434602894,
        "sender_full_name": "drew",
        "timestamp": 1713718003
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>File &quot;bin/parse/main.ml&quot;, line 21, characters 4-11:\n\n21 |   | Error _ -&gt; print_endline &quot;Error!&quot;\n\n         ^^^^^^^\n\nError: This pattern should not be a constructor, the expected type is\n\n       consume:Angstrom.Consume.t -&gt; (int * int, string) result```\n</code></pre></div>",
        "id": 434602913,
        "sender_full_name": "drew",
        "timestamp": 1713718030
    },
    {
        "content": "<p>though i suppose this is actually related to currying :)</p>",
        "id": 434602928,
        "sender_full_name": "drew",
        "timestamp": 1713718051
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/stream/383402-API-Design/topic/Tasks.20returning.20.7B.7D/near/434542187\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"477725\">Jasper Woudenberg</span> could it make sense in a CI platform to use <code>Task</code> instead of <code>Job</code>?</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/stream/383402-API-Design/topic/Tasks.20returning.20.7B.7D/near/434542253\">said</a>:</p>\n<blockquote>\n<p>alternatively, could an applicative-based API for <code>Job</code> make sense? Then you could use record builder syntax, and also the structure would be statically inspectable (so you could print out a build graph etc)</p>\n</blockquote>\n<p>Yeah, I'd like to make the CI structure be statically inspectable, which is why I don't think using <code>Task</code> instead of <code>Job</code> would help. With regards to record builders, I've thought about it after getting that feedback before, but I'm not sure what record I'd want to build <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>. Would the idea be to try represent the build graph as a set of nested records?</p>\n<p>What I like about the design I have now is that it's already statically inspectable. on account of <code>Job</code> not coming with an <code>andThen</code>. And it allows you to write the project's CI almost like an ordinary function, with roc-ci being able to turn that into a pipeline (i.e., we can automatically figure out which bits to run in paralllel).</p>",
        "id": 434606306,
        "sender_full_name": "Jasper Woudenberg",
        "timestamp": 1713721278
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"477725\">Jasper Woudenberg</span> <a href=\"#narrow/stream/383402-API-Design/topic/Tasks.20returning.20.7B.7D/near/434606306\">said</a>:</p>\n<blockquote>\n<p>What I like about the design I have now is that it's already statically inspectable. on account of <code>Job</code> not coming with an <code>andThen</code>. And it allows you to write the project's CI almost like an ordinary function, with roc-ci being able to turn that into a pipeline (i.e., we can automatically figure out which bits to run in paralllel).</p>\n</blockquote>\n<p>ah! So <code>!</code> desugars into an <code>andThen</code>, so it probably wouldn't be usable here even if it did support types other than <code>Task</code> <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 434606614,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1713721587
    },
    {
        "content": "<p>So logging is one thing, but any thoughts about what it would take to have good tracing support? For me, traces have completely replaced logging in web applications, and I'd be happy never to have to think off log levels again <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>. I think in terms of functionality required, while logging could be implemented by the platform providing some log function(s), for tracing the <code>Task</code> type needs to carry some context to allow a tree of spans to be created. Will that be possible with the language-provided <code>Task</code> type?</p>",
        "id": 434606720,
        "sender_full_name": "Jasper Woudenberg",
        "timestamp": 1713721715
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/stream/383402-API-Design/topic/Tasks.20returning.20.7B.7D/near/434606614\">said</a>:</p>\n<blockquote>\n<p>ah! So <code>!</code> desugars into an <code>andThen</code>, so it probably wouldn't be usable here even if it did support types other than <code>Task</code> <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>\n</blockquote>\n<p>Ah, that makes sense, I guess that would never work then.</p>\n<p>I'll probably go with the shadowing approach then, seems pretty straight-forward and I think it'd likely have better errors then the current backpassing approach anyway.</p>",
        "id": 434606907,
        "sender_full_name": "Jasper Woudenberg",
        "timestamp": 1713721919
    },
    {
        "content": "<p>cool cool!</p>",
        "id": 434608543,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1713723474
    },
    {
        "content": "<p>out of curiosity, how do you think you'd do it in Elm? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 434608596,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1713723488
    },
    {
        "content": "<p>Elm uses <code>Task</code> so little, I'm not sure there'd be a ton of value in instrumenting it (given it'd leave most of the application out of scope). That said, if I had to, I'd probably introduce a custom <code>Task</code> type, give it the same API as the built-in task. That custom <code>Task</code> type could have a structure like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>type TracingTask err val = TracingTask (TraceContext -&gt; Task err val)\n\ntype alias TraceContext = { id: String, startTime : Time }\n</code></pre></div>\n<p>For a more full-formed example, we defined a <code>Task</code> type in a similar fashion around <code>IO</code> in <code>nri-haskell</code>:<br>\n<a href=\"https://github.com/NoRedInk/haskell-libraries/blob/trunk/nri-prelude/src/Platform/Internal.hs#L63\">https://github.com/NoRedInk/haskell-libraries/blob/trunk/nri-prelude/src/Platform/Internal.hs#L63</a></p>",
        "id": 434611170,
        "sender_full_name": "Jasper Woudenberg",
        "timestamp": 1713725856
    },
    {
        "content": "<p>oh I meant modeling <code>Job</code> in Elm</p>",
        "id": 434611277,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1713725934
    },
    {
        "content": "<p>since Elm doesn't have shadowing</p>",
        "id": 434611297,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1713725954
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281383\">Richard Feldman</span> <a href=\"#narrow/stream/383402-API-Design/topic/Tasks.20returning.20.7B.7D/near/434611277\">said</a>:</p>\n<blockquote>\n<p>oh I meant modeling <code>Job</code> in Elm</p>\n</blockquote>\n<p>Ah gotcha. Yeah, good question. Maybe define <code>Job.map2</code> and <code>Job.map3</code> and the like?</p>\n<p>Nice question, I'll think a bit about this.</p>",
        "id": 434611690,
        "sender_full_name": "Jasper Woudenberg",
        "timestamp": 1713726318
    },
    {
        "content": "<p>in playing around with <code>!</code>, i've found that ending a program in the basic-cli with _two_ statements that both use <code>!</code> works fine, but a single statement ending in <code>!</code> to end the program produces a type error</p>",
        "id": 434650676,
        "sender_full_name": "drew",
        "timestamp": 1713761689
    },
    {
        "content": "<p>see <a href=\"https://gist.github.com/drewolson/635f4c39bd209338d3f6e5030720f1a9\">https://gist.github.com/drewolson/635f4c39bd209338d3f6e5030720f1a9</a></p>",
        "id": 434650683,
        "sender_full_name": "drew",
        "timestamp": 1713761692
    },
    {
        "content": "<p>output from the non-working case:</p>",
        "id": 434650715,
        "sender_full_name": "drew",
        "timestamp": 1713761714
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>$ roc dev\n\n── TYPE MISMATCH in main.roc ───────────────────────────────────────────────────\n\nThis 2nd argument to this function has an unexpected type:\n\n22│              Stdout.line! &quot;Hello, $(name)&quot;\n\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe argument is an anonymous function of type:\n\n    {} -&gt; {}\n\nBut this function needs its 2nd argument to be:\n\n    {} -&gt; InternalTask.Task c *\n\nTip: Type comparisons between an opaque type are only ever equal if\n\nboth types are the same opaque type. Did you mean to create an opaque\n\ntype by wrapping it? If I have an opaque type Age := U32 I can create\n\nan instance of this opaque type by doing @Age 23.\n\n────────────────────────────────────────────────────────────────────────────────\n\n1 error and 0 warnings found in 27 ms\n\n.\n\nYou can run the program anyway with roc run```\n</code></pre></div>",
        "id": 434650717,
        "sender_full_name": "drew",
        "timestamp": 1713761715
    },
    {
        "content": "<p>Thank you, can you please log an issue. I'm pretty sure I know what is going wrong in this case</p>",
        "id": 434650828,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1713761768
    },
    {
        "content": "<p>Just a link to the gist is all the description needed</p>",
        "id": 434650858,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1713761792
    },
    {
        "content": "<p>sure, make the issue in the roc repo?</p>",
        "id": 434650891,
        "sender_full_name": "drew",
        "timestamp": 1713761817
    },
    {
        "content": "<p>done, it's here <a href=\"https://github.com/roc-lang/roc/issues/6661\">https://github.com/roc-lang/roc/issues/6661</a></p>",
        "id": 434650966,
        "sender_full_name": "drew",
        "timestamp": 1713761876
    }
]