[
    {
        "content": "<p>Ok, two more things that I still don't like with the sqlite api. Thought it would be good to get ideas here.</p>\n<p>For a simple query, the sqlite api is pretty reasonable (if a bit much to learn at once):</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">query_many!</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"ss\">path</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">db_path</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"ss\">query</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"SELECT id, task FROM todos WHERE status = :status;\"</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"ss\">bindings</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">name</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\":status\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"ss\">value</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nb\">String</span><span class=\"w\"> </span><span class=\"s2\">\"completed\"</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"o\">]</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"ss\">rows</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">decode_record</span><span class=\"w\"> </span><span class=\"o\">&lt;-</span>\n<span class=\"w\">        </span><span class=\"nb\">id</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">i64</span><span class=\"w\"> </span><span class=\"s2\">\"id\"</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"ss\">task</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"s2\">\"task\"</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"p\">},</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>This will grab all todos with a specific status. It will automatically decode them to a <code>Result (List { id: I64, task: Str }) _</code>. I think this api is reasonable enough.</p>\n<p>I think the api is a lot less reasonable with prepared queries (<a href=\"https://github.com/roc-lang/basic-webserver/blob/main/examples/sqlite.roc\">simple example</a>). The split of preparing the query and binding/decoding the result leads to a less understandable result:</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"n\">init!</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">\\{}</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">        </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">prepare!</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"ss\">path</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">db_path</span><span class=\"p\">,</span>\n<span class=\"w\">            </span><span class=\"ss\">query</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"SELECT id, task FROM todos WHERE status = :status;\"</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"o\">...</span>\n\n<span class=\"n\">actually_query!</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">\\</span><span class=\"n\">stmt</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">        </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">query_many_prepared!</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"n\">stmt</span><span class=\"p\">,</span>\n<span class=\"w\">            </span><span class=\"ss\">bindings</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">name</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\":status\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"ss\">value</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nb\">String</span><span class=\"w\"> </span><span class=\"s2\">\"completed\"</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"o\">]</span><span class=\"p\">,</span>\n<span class=\"w\">            </span><span class=\"ss\">rows</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">decode_record</span><span class=\"w\"> </span><span class=\"o\">&lt;-</span>\n<span class=\"w\">                </span><span class=\"nb\">id</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">i64</span><span class=\"w\"> </span><span class=\"s2\">\"id\"</span><span class=\"p\">,</span>\n<span class=\"w\">                </span><span class=\"ss\">task</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"s2\">\"task\"</span><span class=\"p\">,</span>\n<span class=\"w\">            </span><span class=\"p\">},</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"o\">...</span>\n</code></pre></div>\n<p>Maybe the decoder should be specified when preparing the query? That said, there is still not a great link between the bound variables and the original query. The split definitely hurts understandability, but preparing queries is quite important for perf.</p>\n<hr>\n<p>Secondly, we don't have an api for transactions yet. And they really are not nice to do manually. If you want max perf, it requires adding <a href=\"https://github.com/roc-lang/basic-webserver/blob/c232429d4193330800d2dc00de4323d986c4bc25/examples/todos.roc#L28-L30\">3 extra prepared stmts to your model</a> (begin, end, and rollback). On top of that, the <a href=\"https://github.com/roc-lang/basic-webserver/blob/c232429d4193330800d2dc00de4323d986c4bc25/examples/todos.roc#L137-L173\">actual transaction logic</a> feels a bit inconvenient.</p>\n<p>Part of the problem with designing an api for this is that you need to store a prepared query for begin, end, and rollback if you want max perf.</p>\n<p>Not that max perf truly matters here, but I really want to design the api to always use prepared queries if possible.</p>\n<hr>\n<p>Anyway, open to any thoughts and suggestions. Just feel like the api isn't quite right yet.</p>",
        "id": 491677085,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735858701
    },
    {
        "content": "<p>I'm curious, why is <code>bindings</code> a list?</p>\n<p>For the prepared statement problem, if you move the decoder into the prepared statement as you suggest, would it be possible to let <code>Sqlite.prepare!</code> return a function?</p>\n<div class=\"codehilite\"><pre><span></span><code>init! = \\{} -&gt;\n    query : { status: Str } =&gt; List { id: I64, task: Str }\n    query =\n        Sqlite.prepare! {\n            path: db_path,\n            query: &quot;SELECT id, task FROM todos WHERE status = :status;&quot;,\n            bindings: \\{ status } -&gt; [{ name: &quot;:status&quot;, value: status }],\n            rows: { Sqlite.decode_record &lt;-\n                id: Sqlite.i64 &quot;id&quot;,\n                task: Sqlite.str &quot;task&quot;,\n            },\n        }\n    ...\n\nactually_query! = \\stmt -&gt;\n    result = query({ status: &quot;completed&quot; })\n    ...\n</code></pre></div>\n<p>Then the type of the function becomes the prepared statement returns is self-explanatory, even without the SQL nearby.</p>",
        "id": 491679495,
        "sender_full_name": "Jasper Woudenberg",
        "timestamp": 1735860261
    },
    {
        "content": "<p>Neat use of record builders BTW!</p>",
        "id": 491679936,
        "sender_full_name": "Jasper Woudenberg",
        "timestamp": 1735860496
    },
    {
        "content": "<p>That's <span class=\"user-mention\" data-user-id=\"489294\">@Agus Zubiaga</span> 's record building handiwork, he pioneered the feature in the first place</p>",
        "id": 491680036,
        "sender_full_name": "Sam Mohr",
        "timestamp": 1735860570
    },
    {
        "content": "<blockquote>\n<p>why is <code>bindings</code> a list?</p>\n</blockquote>\n<p>Simplicity</p>",
        "id": 491680465,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735860792
    },
    {
        "content": "<p>I don't want a full query language in roc. Just want an sql string. As such, not sure the best way to do bindings.</p>\n<p>Open for suggestions for that too. Only really has to be a list at the low level to pass to the platform (Though even that could get split into many separate bind calls technically)</p>",
        "id": 491680618,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735860927
    },
    {
        "content": "<p>For the transaction, maybe a similar thing is possible to the prepared statement is possible, where there is a <code>prepare_transaction</code>function to be called from init. <code>prepare_transaction</code> will immediately prepare the three transaction queries and subsequently return the function to create transactions in actual code.</p>",
        "id": 491680626,
        "sender_full_name": "Jasper Woudenberg",
        "timestamp": 1735860931
    },
    {
        "content": "<p>Or, another idea, a single <code>Slite.setup</code> function to use in init:</p>\n<div class=\"codehilite\"><pre><span></span><code>init! = \\{} -&gt;\n    db : {\n        transaction : {} =&gt; {},\n        list_todos! : { status: Str } =&gt; List { id: I64, task: Str },\n    }\n    db = { Sqlite.setup! &lt;-\n        transaction : Sqlite.prepare_transaction!,\n        list_todos! : Sqlite.prepare! {\n            path: db_path,\n            query: &quot;SELECT id, task FROM todos WHERE status = :status;&quot;,\n            bindings: \\{ status } -&gt; [{ name: &quot;:status&quot;, value: status }],\n            rows: { Sqlite.decode_record &lt;-\n                id: Sqlite.i64 &quot;id&quot;,\n                task: Sqlite.str &quot;task&quot;,\n            },\n        }\n    }\n    ...\n\nactually_query! = \\db -&gt;\n    result = (db.list_todos) { status: &quot;completed&quot; }\n    ...\n</code></pre></div>",
        "id": 491681036,
        "sender_full_name": "Jasper Woudenberg",
        "timestamp": 1735861241
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/channel/383402-API-design/topic/Sqlite.20APIs/near/491680618\">said</a>:</p>\n<blockquote>\n<p>I don't want a full query language in roc. Just want an sql string. As such, not sure the best way to do bindings.</p>\n<p>Open for suggestions for that too. Only really has to be a list at the low level to pass to the platform (Though even that could get split into many separate bind calls technically)</p>\n</blockquote>\n<p>I like the straigt-forward binding between query and Roc code, that makes sense to me. In the example I notice the list just has a single element, a better way to phrase my question is when you would have multiple bindings in that list, or zero.</p>",
        "id": 491681349,
        "sender_full_name": "Jasper Woudenberg",
        "timestamp": 1735861417
    },
    {
        "content": "<p>It's based on the query. One per <code>:name</code> variable in the query.</p>",
        "id": 491681435,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735861468
    },
    {
        "content": "<p>So select everything would have none</p>",
        "id": 491681452,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735861485
    },
    {
        "content": "<p>Selecting with many conditions would have many</p>",
        "id": 491681466,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735861498
    },
    {
        "content": "<p>Ohhh, I didn't read that right. I thought there were multiple params in that record already, but it's key-value pairs. That explains it, thanks!</p>",
        "id": 491681508,
        "sender_full_name": "Jasper Woudenberg",
        "timestamp": 1735861529
    },
    {
        "content": "<p>Ah. Yeah, just kv pairs</p>",
        "id": 491681793,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735861724
    },
    {
        "content": "<p>Oh, that last idea with <code>Sqlite.setup!</code> doesn't make sense, if it's supposed to return a plain record. I guess the app author could opt put all their queries in a record, but they wouldn't need help from the library for that.</p>",
        "id": 491682116,
        "sender_full_name": "Jasper Woudenberg",
        "timestamp": 1735861983
    },
    {
        "content": "<p>That said, even your base idea for changes to prepare would solve the issues.</p>",
        "id": 491682244,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735862093
    },
    {
        "content": "<p>And not sure if there is a better higher level solution for transactions but the simple solution may be enough.</p>",
        "id": 491682305,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735862145
    },
    {
        "content": "<p>Just <code>prepare_transaction! : [ Deferred, Immediate, Exclusive ] =&gt; (higher level functions for running a lambda as a transaction)</code></p>",
        "id": 491682561,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735862299
    },
    {
        "content": "<p>Then it would just be missing save points, but I think that is fine for now. Just keep it simple.</p>",
        "id": 491682611,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735862355
    },
    {
        "content": "<p>I'll make this changes. Want to get the nicer API in before whenever we do the next release if possible.</p>",
        "id": 491682721,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735862413
    },
    {
        "content": "<p>Also, let me know if there is a better alternative to bindings as a list you can think of.</p>",
        "id": 491682768,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735862443
    },
    {
        "content": "<p>Thoughts for prepared queries. I think this reads a lot better overall.</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"n\">main!</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">\\</span><span class=\"n\">_args</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">db_path</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"no\">Env</span><span class=\"o\">.</span><span class=\"n\">var!</span><span class=\"w\"> </span><span class=\"s2\">\"DB_PATH\"</span>\n\n<span class=\"w\">    </span><span class=\"n\">query_todos_by_status!</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">prepare_query_many!</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"ss\">path</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">db_path</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"ss\">query</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"SELECT id, task FROM todos WHERE status = :status;\"</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"ss\">bindings</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">\\</span><span class=\"n\">status</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">name</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\":status\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"ss\">value</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nb\">String</span><span class=\"w\"> </span><span class=\"n\">status</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"o\">]</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"ss\">rows</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">decode_record</span><span class=\"w\"> </span><span class=\"o\">&lt;-</span>\n<span class=\"w\">            </span><span class=\"nb\">id</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">i64</span><span class=\"w\"> </span><span class=\"s2\">\"id\"</span><span class=\"w\"> </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">map_value</span><span class=\"w\"> </span><span class=\"no\">Num</span><span class=\"o\">.</span><span class=\"n\">toStr</span><span class=\"p\">,</span>\n<span class=\"w\">            </span><span class=\"ss\">task</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"s2\">\"task\"</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"p\">},</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"n\">todo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"n\">query_todos_by_status!</span><span class=\"w\"> </span><span class=\"s2\">\"todo\"</span>\n\n<span class=\"w\">    </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"no\">Stdout</span><span class=\"o\">.</span><span class=\"n\">line!</span><span class=\"w\"> </span><span class=\"s2\">\"Todo Tasks:\"</span>\n<span class=\"w\">    </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"no\">List</span><span class=\"o\">.</span><span class=\"n\">forEachTry!</span><span class=\"w\"> </span><span class=\"n\">todo</span><span class=\"w\"> </span><span class=\"p\">\\{</span><span class=\"w\"> </span><span class=\"nb\">id</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">task</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span>\n<span class=\"w\">        </span><span class=\"no\">Stdout</span><span class=\"o\">.</span><span class=\"n\">line!</span><span class=\"w\"> </span><span class=\"s2\">\"</span><span class=\"se\">\\t</span><span class=\"s2\">id: $(id), task: $(task)\"</span>\n\n<span class=\"w\">    </span><span class=\"n\">completed</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"n\">query_todos_by_status!</span><span class=\"w\"> </span><span class=\"s2\">\"completed\"</span>\n\n<span class=\"w\">    </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"no\">Stdout</span><span class=\"o\">.</span><span class=\"n\">line!</span><span class=\"w\"> </span><span class=\"s2\">\"</span><span class=\"se\">\\n</span><span class=\"s2\">Completed Tasks:\"</span>\n<span class=\"w\">    </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"no\">List</span><span class=\"o\">.</span><span class=\"n\">forEachTry!</span><span class=\"w\"> </span><span class=\"n\">completed</span><span class=\"w\"> </span><span class=\"p\">\\{</span><span class=\"w\"> </span><span class=\"nb\">id</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">task</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span>\n<span class=\"w\">        </span><span class=\"no\">Stdout</span><span class=\"o\">.</span><span class=\"n\">line!</span><span class=\"w\"> </span><span class=\"s2\">\"</span><span class=\"se\">\\t</span><span class=\"s2\">id: $(id), task: $(task)\"</span>\n\n<span class=\"w\">    </span><span class=\"no\">Ok</span><span class=\"w\"> </span><span class=\"p\">{}</span>\n</code></pre></div>",
        "id": 491687590,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735865710
    },
    {
        "content": "<p>And transactions now work like this:</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"n\">exec_transaction!</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"n\">prepare_transaction!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"ss\">path</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"path/to/database.db\"</span><span class=\"w\"> </span><span class=\"p\">}</span>\n\n<span class=\"n\">try</span><span class=\"w\"> </span><span class=\"n\">exec_transaction!</span><span class=\"w\"> </span><span class=\"p\">\\{}</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">try</span><span class=\"w\"> </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">execute!</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"ss\">path</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"path/to/database.db\"</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"ss\">query</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"INSERT INTO users (first, last) VALUES (:first, :last);\"</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"ss\">bindings</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"o\">[</span>\n<span class=\"w\">            </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">name</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\":first\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"ss\">value</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nb\">String</span><span class=\"w\"> </span><span class=\"s2\">\"John\"</span><span class=\"w\"> </span><span class=\"p\">},</span>\n<span class=\"w\">            </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">name</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\":last\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"ss\">value</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nb\">String</span><span class=\"w\"> </span><span class=\"s2\">\"Smith\"</span><span class=\"w\"> </span><span class=\"p\">},</span>\n<span class=\"w\">        </span><span class=\"o\">]</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n\n<span class=\"w\">    </span><span class=\"c1\"># Oh no, hit an error. Need to rollback.</span>\n<span class=\"w\">    </span><span class=\"c1\"># Note: Error could be anything.</span>\n<span class=\"w\">    </span><span class=\"no\">Err</span><span class=\"w\"> </span><span class=\"no\">NeedToRollback</span>\n</code></pre></div>",
        "id": 491690308,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735867654
    },
    {
        "content": "<p>Both of these feel ok. Though some of the type signatures are definitely a bit complex.</p>",
        "id": 491690378,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735867689
    },
    {
        "content": "<p><a href=\"https://github.com/roc-lang/basic-cli/pull/302\">https://github.com/roc-lang/basic-cli/pull/302</a></p>",
        "id": 491690534,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735867807
    },
    {
        "content": "<p>What is the type of <code>query_todos_by_status!</code>?</p>",
        "id": 491693942,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1735870551
    },
    {
        "content": "<p>If these are examples, I feel like we should type annotations... even if they're not required.</p>",
        "id": 491694015,
        "sender_full_name": "Luke Boswell",
        "timestamp": 1735870601
    },
    {
        "content": "<p><code>PreparedQueryManyStmt Str { id: Str, task: Str } _</code></p>\n<p>Where <code>_</code> is whatever the error type is.</p>",
        "id": 491694454,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735870949
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515757\">Luke Boswell</span> <a href=\"#narrow/stream/383402-API-design/topic/Sqlite.20APIs/near/491694015\">said</a>:</p>\n<blockquote>\n<p>If these are examples, I feel like we should type annotations... even if they're not required.</p>\n</blockquote>\n<p>I personally don't like that. Roc can be used without type annotations and adding the annotations makes everything feel more complex than it is.</p>",
        "id": 491694631,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735871090
    },
    {
        "content": "<p>Also, debating changing the name to <code>QueryManyFn</code> for some simplicity.</p>",
        "id": 491694691,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735871151
    },
    {
        "content": "<p>Pushed the simplified names</p>",
        "id": 491695224,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735871590
    },
    {
        "content": "<p>Ok, so this design still has a major flaw. Due to generating the entire prepared statement into a query function, the errors suck. They are a pain to store in the <code>Model</code> for basic webserver.</p>\n<p>Simple example:</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"n\">init!</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"no\">Result</span><span class=\"w\"> </span><span class=\"no\">Model</span><span class=\"w\"> </span><span class=\"n\">_</span>\n<span class=\"n\">init!</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">\\{}</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span>\n<span class=\"w\">    </span><span class=\"c1\"># Read DB_PATH environment variable</span>\n<span class=\"w\">    </span><span class=\"n\">db_path</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">        </span><span class=\"no\">Env</span><span class=\"o\">.</span><span class=\"n\">var!</span><span class=\"w\"> </span><span class=\"s2\">\"DB_PATH\"</span>\n<span class=\"w\">        </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"no\">Result</span><span class=\"o\">.</span><span class=\"n\">mapErr</span><span class=\"w\"> </span><span class=\"p\">\\</span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"no\">ServerErr</span><span class=\"w\"> </span><span class=\"s2\">\"DB_PATH not set on environment\"</span>\n<span class=\"w\">        </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"n\">try</span>\n\n<span class=\"w\">    </span><span class=\"n\">query_todos_by_status!</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">        </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">prepare_query_many!</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"ss\">path</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">db_path</span><span class=\"p\">,</span>\n<span class=\"w\">            </span><span class=\"ss\">query</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"SELECT id, task FROM todos WHERE status = :status;\"</span><span class=\"p\">,</span>\n<span class=\"w\">            </span><span class=\"ss\">bindings</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">\\</span><span class=\"nb\">name</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">name</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\":status\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"ss\">value</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nb\">String</span><span class=\"w\"> </span><span class=\"nb\">name</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"o\">]</span><span class=\"p\">,</span>\n<span class=\"w\">            </span><span class=\"ss\">rows</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">decode_record</span><span class=\"w\"> </span><span class=\"o\">&lt;-</span>\n<span class=\"w\">                </span><span class=\"nb\">id</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">i64</span><span class=\"w\"> </span><span class=\"s2\">\"id\"</span><span class=\"p\">,</span>\n<span class=\"w\">                </span><span class=\"ss\">task</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">str</span><span class=\"w\"> </span><span class=\"s2\">\"task\"</span><span class=\"p\">,</span>\n<span class=\"w\">            </span><span class=\"p\">},</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n<span class=\"w\">        </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"no\">Result</span><span class=\"o\">.</span><span class=\"n\">mapErr</span><span class=\"w\"> </span><span class=\"p\">\\</span><span class=\"n\">err</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"no\">ServerErr</span><span class=\"w\"> </span><span class=\"s2\">\"Failed to prepare Sqlite statement: $(Inspect.toStr err)\"</span>\n<span class=\"w\">        </span><span class=\"o\">|&gt;</span><span class=\"w\"> </span><span class=\"n\">try</span>\n\n<span class=\"w\">    </span><span class=\"no\">Ok</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">query_todos_by_status!</span><span class=\"w\"> </span><span class=\"p\">}</span>\n</code></pre></div>\n<p>What is model. It is a:</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">query_todos_by_status!</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Str</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"no\">Result</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"no\">List</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"nb\">id</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">I64</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"n\">task</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Str</span><span class=\"p\">,</span>\n<span class=\"p\">})</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">SqlDecodeErr</span><span class=\"w\"> </span><span class=\"o\">[</span>\n<span class=\"w\">    </span><span class=\"no\">FailedToDecodeInteger</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"no\">UnexpectedType</span><span class=\"w\"> </span><span class=\"o\">[</span>\n<span class=\"w\">        </span><span class=\"no\">Bytes</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"nb\">Integer</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"no\">Null</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"no\">Real</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"nb\">String</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"o\">]</span><span class=\"p\">,</span>\n<span class=\"o\">]</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span>\n</code></pre></div>\n<p>With this type alias: <code>QueryManyFn in out err : in =&gt; Result (List out) (SqlDecodeErr err)</code><br>\nit is a:</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"no\">Model</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">query_todos_by_status!</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">QueryManyFn</span><span class=\"w\"> </span><span class=\"no\">Str</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">id</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">I64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">task</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Str</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"no\">FailedToDecodeInteger</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">UnexpectedType</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"no\">Bytes</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">Integer</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">Null</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">Real</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">String</span><span class=\"o\">]]</span><span class=\"w\"> </span><span class=\"p\">}</span>\n</code></pre></div>\n<p>This quickly gets to be a mess (especially with many queries). I am unable to put an <code>_</code> there cause:</p>\n<div class=\"codehilite\"><pre><span></span><code>Type alias definitions may not use inferred types (_).\n</code></pre></div>\n<p>On top of that, even when I type it correctly, it becomes a closed tag union. Due to being a closed tag, the errors no longer propagate.</p>\n<hr>\n<p>So I went a different route:</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"no\">Model</span><span class=\"w\"> </span><span class=\"n\">err</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">query_todos_by_status!</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">QueryManyFn</span><span class=\"w\"> </span><span class=\"no\">Str</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">id</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">I64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">task</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Str</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"n\">err</span><span class=\"w\"> </span><span class=\"p\">}</span>\n</code></pre></div>\n<p>This feels like it should work . But it breaks due to the <code>Model</code> being passed to the platform. The use in the platform does not expect a type that takes a type variable.</p>\n<p>I tried replacing the entire use in the platform with a type variable, but that also breaks. Cause a <code>model</code> type variable contains no info and can not be used as a <code>Model err</code></p>\n<hr>\n<p>So the apis are much nicer to use, but the types have become really hard to work with.</p>",
        "id": 491705934,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735881215
    },
    {
        "content": "<p>To make the code actually work, I need to type it like so:</p>\n<div class=\"codehilite\" data-code-language=\"Ruby\"><pre><span></span><code><span class=\"no\">Model</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">query_todos_by_status!</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Sqlite</span><span class=\"o\">.</span><span class=\"n\">QueryManyFn</span><span class=\"w\"> </span><span class=\"no\">Str</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">id</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">I64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">task</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"no\">Str</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">[</span>\n<span class=\"w\">        </span><span class=\"no\">FailedToDecodeInteger</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"no\">UnexpectedType</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"no\">Bytes</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">Integer</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">Null</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"no\">Real</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">String</span><span class=\"o\">]</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"no\">StdoutErr</span><span class=\"w\"> </span><span class=\"o\">[</span>\n<span class=\"w\">                </span><span class=\"no\">AlreadyExists</span><span class=\"p\">,</span>\n<span class=\"w\">                </span><span class=\"no\">BrokenPipe</span><span class=\"p\">,</span>\n<span class=\"w\">                </span><span class=\"no\">Interrupted</span><span class=\"p\">,</span>\n<span class=\"w\">                </span><span class=\"no\">NotFound</span><span class=\"p\">,</span>\n<span class=\"w\">                </span><span class=\"no\">Other</span><span class=\"w\"> </span><span class=\"no\">Str</span><span class=\"p\">,</span>\n<span class=\"w\">                </span><span class=\"no\">OutOfMemory</span><span class=\"p\">,</span>\n<span class=\"w\">                </span><span class=\"no\">PermissionDenied</span><span class=\"p\">,</span>\n<span class=\"w\">                </span><span class=\"no\">Unsupported</span><span class=\"p\">,</span>\n<span class=\"w\">            </span><span class=\"o\">]</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"no\">ServerErr</span><span class=\"w\"> </span><span class=\"no\">Str</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"o\">]</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 491706157,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735881394
    },
    {
        "content": "<p>Code here: <a href=\"https://github.com/roc-lang/basic-webserver/tree/sqlite-better-queries\">https://github.com/roc-lang/basic-webserver/tree/sqlite-better-queries</a></p>",
        "id": 491706198,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735881447
    },
    {
        "content": "<p>How would you feel about creating a type alias for just the error?</p>\n<div class=\"codehilite\"><pre><span></span><code># Sqlite.roc\nQueryError : SqlDecodeErr [\n    FailedToDecodeInteger [],\n    UnexpectedType [\n        Bytes,\n        Integer,\n        Null,\n        Real,\n        String,\n    ],\n    ServerErr Str,\n]\n</code></pre></div>\n<p>Then the appliction Model types becomes:</p>\n<div class=\"codehilite\"><pre><span></span><code>Model : {\n    query_todos_by_status! : Str =&gt; Result (List { id : I64, task : Str })  Sqlite.QueryError\n}\n</code></pre></div>\n<p>I think that's a pretty reasonable type, every bit of it is useful documentation of how <code>query_todos_by_status!</code> is supposed to be used. It takes up a similar amount of space as the <code>Sqlite.QueryManyFn</code>-based type, and using <code>_</code> instead of the input, output, and/or error type should work.</p>",
        "id": 491721256,
        "sender_full_name": "Jasper Woudenberg",
        "timestamp": 1735892278
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/channel/383402-API-design/topic/Sqlite.20APIs/near/491682768\">said</a>:</p>\n<blockquote>\n<p>Also, let me know if there is a better alternative to bindings as a list you can think of.</p>\n</blockquote>\n<p>The one thing that occured to me is that it would be possible to take any Roc Record as an argument list and then use an encoder to pull out the key-value pairs and put them in the query.</p>\n<p>A nice benefit of that approach is that where in the current approach the <code>bindings</code> params contains some \"runtime type-annotations\" (the constructors to the <code>value</code> field), in the encoder approach the application author could instead specify the types of params using regular Roc type annotations.</p>\n<p>A downside is that whereas the current \"runtime type-annotations\" are required, Roc type annotations are optional. That might lead to problems if the application author chooses not to add them, given the <code>Model</code> needs to be concrete in order for it to be passed to the platform.</p>\n<p>A possible fix for that would be to keep the <code>bindings</code> params, but use it solely to describe the expected input type. That would also make it possible to make certain invalid input types compile-time errors, such as attempting to pass <code>List U64]</code> as a param value.</p>\n<div class=\"codehilite\"><pre><span></span><code># single param\nbindings: Sqlite.Bindings Str\nbindings = Sqlite.string\n\n# record of params\nbindings : Sqlite.Bindings { status : Str, limit : U64 }\nbindings = { Sqlite.bindings &lt;-\n    status: Sqlite.str,\n    limit: Sqlite.u64,\n}\n\n# Sqlite.roc\nBindings a := {}\n\nstr : Bindings Str\nstr = @Bindings {}\n\nu64 : Bindings U64\nu64 = @Bindings {}\n\nprepare_query! :\n    {\n        path : Str,\n        query : Str,\n        bindings : Bindings in,\n        row : SqlDecode out (RowCountErr err),\n    }\n    =&gt; Result (in =&gt; Result out err) [SqliteErr ErrCode Str]\n</code></pre></div>",
        "id": 491723564,
        "sender_full_name": "Jasper Woudenberg",
        "timestamp": 1735893671
    },
    {
        "content": "<p>Another potential benefit of the <code>Sqlite.Bindings</code> + encoder params API: It would make the types of the parameters passed in knowable when preparing queries. I imagine that means that the following errors could be handled at prepare time, rather than at query time:</p>\n<div class=\"codehilite\"><pre><span></span><code>    UnexpectedType [\n        Bytes,\n        Integer,\n        Null,\n        Real,\n        String,\n    ]\n</code></pre></div>",
        "id": 491730857,
        "sender_full_name": "Jasper Woudenberg",
        "timestamp": 1735897302
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"477725\">Jasper Woudenberg</span> <a href=\"#narrow/stream/383402-API-design/topic/Sqlite.20APIs/near/491721256\">said</a>:</p>\n<blockquote>\n<p>How would you feel about creating a type alias for just the error?</p>\n<p><div class=\"codehilite\"><pre><span></span><code># Sqlite.roc\nQueryError : SqlDecodeErr [\n    FailedToDecodeInteger [],\n    UnexpectedType [\n        Bytes,\n        Integer,\n        Null,\n        Real,\n        String,\n    ],\n    ServerErr Str,\n]\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>That wouldn't t work:</p>\n<ol>\n<li>The errors depend on the exact row decoder used.</li>\n<li>Due to generating a closed tag, some of these errors aren't even from sqlite at all. <code>ServerErr</code> is from the app, not from sqlite.</li>\n</ol>",
        "id": 491769056,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735916384
    },
    {
        "content": "<p>Also, unexpected type comes from decoding a row. If you try to decode as strings and one of the items in a column is an int, that will lead to the error.</p>",
        "id": 491769307,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735916474
    },
    {
        "content": "<p>Ah, makes sense, too bad. Does it work to remove <code>Sqlite.QueryManyFn</code> and use <code>_</code> in the <code>Model</code> on the error position?</p>\n<p>Another approach is to add a <code>onError</code> argument to <code>prepare_query_many!</code>. That would allow the application author to map that error to a more reasonable type, and subsequently you have that type rather than the original in the <code>Model</code>.</p>",
        "id": 491779294,
        "sender_full_name": "Jasper Woudenberg",
        "timestamp": 1735921197
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"477725\">Jasper Woudenberg</span> <a href=\"#narrow/stream/383402-API-design/topic/Sqlite.20APIs/near/491779294\">said</a>:</p>\n<blockquote>\n<p>Ah, makes sense, too bad. Does it work to remove <code>Sqlite.QueryManyFn</code> and use <code>_</code> in the <code>Model</code> on the error position?</p>\n</blockquote>\n<p>This is what I really wish worked, but isn't allowed in type aliases.</p>",
        "id": 491779544,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735921332
    },
    {
        "content": "<p>Yeah, onError may be the best solution.</p>",
        "id": 491779579,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735921363
    },
    {
        "content": "<p>This feels like a case where there should be a much nicer solution but I'm not seeing it.</p>",
        "id": 491779623,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735921390
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"343810\">Brendan Hansknecht</span> <a href=\"#narrow/stream/383402-API-design/topic/Sqlite.20APIs/near/491705934\">said</a>:</p>\n<blockquote>\n<p>Ok, so this design still has a major flaw. Due to generating the entire prepared statement into a query function, the errors suck. They are a pain to store in the <code>Model</code> for basic webserver.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"454654\">@Ayaz Hafiz</span> or <span class=\"user-mention\" data-user-id=\"281383\">@Richard Feldman</span> any thought on the issues being described starting in this comment? Feels like the type system is just too rigid for this design making errors a pain.</p>\n<p>A big part of the issue is that stored lambdas no longer return open tags. Maybe that is a bug?</p>",
        "id": 491780102,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735921620
    },
    {
        "content": "<blockquote>\n<p>stored lambdas no longer return open tags</p>\n</blockquote>\n<p>I assume the reason for this is that the hidden type variable doesn't propagate to the lambdas? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> </p>\n<p>Ayaz would know</p>",
        "id": 491780546,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1735921830
    },
    {
        "content": "<p>yeah the hidden \"open\" type variable doesn't apply to unions under aliases</p>",
        "id": 491780963,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1735922042
    },
    {
        "content": "<p>it would break the alias type</p>",
        "id": 491781008,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1735922046
    },
    {
        "content": "<p>because the variable doesn't appear in the alias's type parameters?</p>",
        "id": 491781141,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1735922120
    },
    {
        "content": "<p>yes</p>",
        "id": 491781309,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1735922196
    },
    {
        "content": "<p>and the type errors would be really weird, because now aliases don't necessarily have the same type</p>",
        "id": 491781371,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1735922238
    },
    {
        "content": "<p>so it would have to be</p>\n<div class=\"codehilite\" data-code-language=\"CoffeeScript\"><pre><span></span><code><span class=\"c1\"># Sqlite.roc</span>\n<span class=\"nx\">QueryError</span><span class=\"w\"> </span><span class=\"nv\">a</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"nx\">SqlDecodeErr</span><span class=\"w\"> </span><span class=\"p\">[</span>\n<span class=\"w\">    </span><span class=\"nx\">FailedToDecodeInteger</span><span class=\"w\"> </span><span class=\"p\">[],</span>\n<span class=\"w\">    </span><span class=\"nx\">UnexpectedType</span><span class=\"w\"> </span><span class=\"p\">[</span>\n<span class=\"w\">        </span><span class=\"nx\">Bytes</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"nx\">Integer</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"nx\">Null</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"nx\">Real</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"nb\">String</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"p\">]</span><span class=\"nx\">a</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"nx\">ServerErr</span><span class=\"w\"> </span><span class=\"nx\">Str</span><span class=\"p\">,</span>\n<span class=\"p\">]</span>\n</code></pre></div>",
        "id": 491781408,
        "sender_full_name": "Richard Feldman",
        "timestamp": 1735922264
    },
    {
        "content": "<p>ye[</p>",
        "id": 491781419,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1735922269
    },
    {
        "content": "<p>The only issue with adding an err type variable is that the Model can't have any type variables with how it is passed to the platform currently.</p>",
        "id": 491786380,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735924806
    },
    {
        "content": "<p>Any idea how to deal with that. I think the type has to be concrete for the platform to use it.</p>",
        "id": 491786425,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735924832
    },
    {
        "content": "<p>Maybe it is just a sign that this kind of design doesn't really work well cause the errors will become a mess and have to be stored.</p>",
        "id": 491786488,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735924870
    },
    {
        "content": "<p>i don't think there is a good way to deal with that without upcasting/downcasting</p>",
        "id": 491786506,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1735924881
    },
    {
        "content": "<p>the less granular api would be to say that the API can return any error, or make the error more opaque (e.g. <code>UnexpectedType Str</code>)</p>",
        "id": 491786608,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1735924931
    },
    {
        "content": "<p>fwiw i don't think there's really any recovery with sql query errors. You either log the error and emit a 500 or forward the error to the user. So I think a less granular API is okay.</p>",
        "id": 491786739,
        "sender_full_name": "Ayaz Hafiz",
        "timestamp": 1735925008
    },
    {
        "content": "<p>That's a good tip.</p>",
        "id": 491802087,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1735932686
    },
    {
        "content": "<p>So I just had a realization. If we are willing to switch back to having <code>server = { init!, respond! }</code>. We can link the type variables in basic-webserver.</p>\n<p>That enables use to use the platform type as.</p>\n<div class=\"codehilite\"><pre><span></span><code>Server model init_err respond_err : {\n    init! : {} =&gt; Result model init_err,\n    respond! : Http.Request, model =&gt; Result Http.Response respond_err,\n}\n</code></pre></div>\n<p>Then in the app we can define the model as:</p>\n<div class=\"codehilite\"><pre><span></span><code>Model err : {\n    query_todos_by_status! : Sqlite.QueryManyFn Str { id : I64, task : Str } err,\n}\n</code></pre></div>\n<p>This enables us to keep all the error information and avoid being explicit about all of the error tag union merging.</p>\n<p>Thoughts?</p>",
        "id": 492327721,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1736262546
    },
    {
        "content": "<p>That leads to this: <a href=\"https://github.com/roc-lang/basic-webserver/blob/6d47b5b3b992ac36a2aeda6cd01c9362b94de32d/examples/todos.roc#L12-L58\">https://github.com/roc-lang/basic-webserver/blob/6d47b5b3b992ac36a2aeda6cd01c9362b94de32d/examples/todos.roc#L12-L58</a></p>\n<p>Which on one hand is a lot nicer to use, but the types still aren't nice.</p>",
        "id": 492334289,
        "sender_full_name": "Brendan Hansknecht",
        "timestamp": 1736264410
    }
]