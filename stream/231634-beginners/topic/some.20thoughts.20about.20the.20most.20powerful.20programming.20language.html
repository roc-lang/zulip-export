<html>
<head><meta charset="utf-8"><title>some thoughts about the most powerful programming language · beginners · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/index.html">beginners</a></h2>
<h3>Topic: <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/some.20thoughts.20about.20the.20most.20powerful.20programming.20language.html">some thoughts about the most powerful programming language</a></h3>

<hr>

<base href="https://roc.zulipchat.com">

<head><link href="https://roc-lang.github.io/zulip-export/style.css" rel="stylesheet"></head>

<a name="260094294"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/some%20thoughts%20about%20the%20most%20powerful%20programming%20language/near/260094294" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Locria Cyber <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/some.20thoughts.20about.20the.20most.20powerful.20programming.20language.html#260094294">(Nov 03 2021 at 06:35)</a>:</h4>
<p>It would be nice if there is a programming language with types that depend on terms (like Idris) and strict effect tracking (like Koka).</p>
<p>In that way, we can compile all programs humankind can ever make into that language and vice versa, and refactoring would be easier.</p>
<p>Right now, refactoring is a pain, especially for new languages without IDE support, and the intermediate thing all languages compile to (like LLVM IR or object file) are painful to work with.</p>



<a name="260094579"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/some%20thoughts%20about%20the%20most%20powerful%20programming%20language/near/260094579" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Locria Cyber <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/some.20thoughts.20about.20the.20most.20powerful.20programming.20language.html#260094579">(Nov 03 2021 at 06:41)</a>:</h4>
<p>For example, <a href="https://github.com/bytecodealliance/wizer">this hack</a> exists because some language's compiler isn't powerful enough, or the language itself isn't powerful enough to <strong>express pure functions</strong>. That's also the reason why in some languages you have to write SIMD by hand because another thread may write to the target location and the compiler refuses to do the boilerplate for you.</p>



<a name="260094933"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/some%20thoughts%20about%20the%20most%20powerful%20programming%20language/near/260094933" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Locria Cyber <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/some.20thoughts.20about.20the.20most.20powerful.20programming.20language.html#260094933">(Nov 03 2021 at 06:48)</a>:</h4>
<p>And also, there is Halide, which decouples algorithm from implementation (for array manipulation). This is a good idea: optimization should be separate from description of the program (what it does). I think it's better to let the compiler decide whether to use linked list or growable contiguous memory for dynamic array by tuning with test data, rather than letting the programmers do their wishful thinking for most of the time.</p>



<hr><p>Last updated: Mar 01 2026 at 12:20 UTC</p>
</html>