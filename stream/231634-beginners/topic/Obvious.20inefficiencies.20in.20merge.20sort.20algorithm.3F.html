<html>
<head><meta charset="utf-8"><title>Obvious inefficiencies in merge sort algorithm? · beginners · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/index.html">beginners</a></h2>
<h3>Topic: <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html">Obvious inefficiencies in merge sort algorithm?</a></h3>

<hr>

<base href="https://roc.zulipchat.com">

<head><link href="https://roc-lang.github.io/zulip-export/style.css" rel="stylesheet"></head>

<a name="445149324"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/445149324" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ian McLerran <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#445149324">(Jun 17 2024 at 14:39)</a>:</h4>
<p>Can anyone see any obvious inefficiencies in my merge sort algorithm here? Implemented just for fun in Roc (as well as quicksort). However my mergesort is an order of magnitude (or several depending on list size) worse than my quicksort, despite them having theoretically the same time complexity - O(n log n)</p>
<p>Note that in order to sort the 100k element list with mergesort, I had to quadruple my stack limit from 8mb to 32mb (quicksort has no issues with a 1m list). </p>
<p>The mergesort is of course using recursion instead of List.walk to do the main sorting, which will increase stack usage, but <code>merge</code> should still recurse at most O(n) at each level of mergesort recursion, just like List.walk is O(n) at each level of recursion in quicksort.</p>
<p>Either way, the change from walking the list to recursion doesn't explain 3 orders of magnitude difference to me...</p>
<div class="codehilite"><pre><span></span><code>&gt; List.sortWith: sorted 100k elements in 117ms
----------------------------------
&gt; Sort.quicksort: sorted 100k elements in 248ms
----------------------------------
&gt; Sort.mergesort: sorted 100k elements in 122340ms
</code></pre></div>
<div class="codehilite" data-code-language="Elm"><pre><span></span><code><span class="nv">mergesort</span><span class="w"> </span><span class="nf">:</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nf">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">LT</span><span class="p">,</span><span class="w"> </span><span class="kt">EQ</span><span class="p">,</span><span class="w"> </span><span class="kt">GT</span><span class="p">])</span><span class="w"> </span><span class="nf">-&gt;</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="nv">a</span>
<span class="nv">mergesort</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="nf">\</span><span class="nv">list</span><span class="p">,</span><span class="w"> </span><span class="nv">compare</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="kt">List</span><span class="nf">.</span><span class="nv">len</span><span class="w"> </span><span class="nv">list</span><span class="w"> </span><span class="nf">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="kr">then</span>
<span class="w">        </span><span class="nv">list</span>
<span class="w">    </span><span class="kr">else</span>
<span class="w">        </span><span class="nv">midpoint</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="p">(</span><span class="kt">List</span><span class="nf">.</span><span class="nv">len</span><span class="w"> </span><span class="nv">list</span><span class="p">)</span><span class="w"> </span><span class="nf">//</span><span class="w"> </span><span class="mi">2</span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="nv">before</span><span class="p">,</span><span class="w"> </span><span class="nv">others</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="kt">List</span><span class="nf">.</span><span class="nv">split</span><span class="w"> </span><span class="nv">list</span><span class="w"> </span><span class="nv">midpoint</span>
<span class="w">        </span><span class="nv">merge</span><span class="w"> </span><span class="p">(</span><span class="nv">mergesort</span><span class="w"> </span><span class="nv">before</span><span class="w"> </span><span class="nv">compare</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">mergesort</span><span class="w"> </span><span class="nv">others</span><span class="w"> </span><span class="nv">compare</span><span class="p">)</span><span class="w"> </span><span class="nv">compare</span>

<span class="nv">merge</span><span class="w"> </span><span class="nf">:</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nf">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="kt">LT</span><span class="p">,</span><span class="w"> </span><span class="kt">EQ</span><span class="p">,</span><span class="w"> </span><span class="kt">GT</span><span class="p">])</span><span class="w"> </span><span class="nf">-&gt;</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="nv">a</span>
<span class="nv">merge</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="nf">\</span><span class="nv">left</span><span class="p">,</span><span class="w"> </span><span class="nv">right</span><span class="p">,</span><span class="w"> </span><span class="nv">compare</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">    </span><span class="nv">when</span><span class="w"> </span><span class="p">(</span><span class="nv">left</span><span class="p">,</span><span class="w"> </span><span class="nv">right</span><span class="p">)</span><span class="w"> </span><span class="nv">is</span>
<span class="w">        </span><span class="p">([],</span><span class="w"> </span><span class="nv">_</span><span class="p">)</span><span class="w"> </span><span class="nf">-&gt;</span><span class="w"> </span><span class="nv">right</span>
<span class="w">        </span><span class="p">(</span><span class="nv">_</span><span class="p">,</span><span class="w"> </span><span class="p">[])</span><span class="w"> </span><span class="nf">-&gt;</span><span class="w"> </span><span class="nv">left</span>
<span class="w">        </span><span class="p">([</span><span class="nv">l</span><span class="p">,</span><span class="w"> </span><span class="nf">..</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nv">ls</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="nv">r</span><span class="p">,</span><span class="w"> </span><span class="nf">..</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nv">rs</span><span class="p">])</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">            </span><span class="nv">when</span><span class="w"> </span><span class="nv">compare</span><span class="w"> </span><span class="nv">l</span><span class="w"> </span><span class="nv">r</span><span class="w"> </span><span class="nv">is</span>
<span class="w">                </span><span class="kt">GT</span><span class="w"> </span><span class="nf">-&gt;</span><span class="w"> </span><span class="kt">List</span><span class="nf">.</span><span class="nv">prepend</span><span class="w"> </span><span class="p">(</span><span class="nv">merge</span><span class="w"> </span><span class="nv">left</span><span class="w"> </span><span class="nv">rs</span><span class="w"> </span><span class="nv">compare</span><span class="p">)</span><span class="w"> </span><span class="nv">r</span>
<span class="w">                </span><span class="nv">_</span><span class="w"> </span><span class="nf">-&gt;</span><span class="w"> </span><span class="kt">List</span><span class="nf">.</span><span class="nv">prepend</span><span class="w"> </span><span class="p">(</span><span class="nv">merge</span><span class="w"> </span><span class="nv">ls</span><span class="w"> </span><span class="nv">right</span><span class="w"> </span><span class="nv">compare</span><span class="p">)</span><span class="w"> </span><span class="nv">l</span>
<span class="w">        </span><span class="p">(</span><span class="nv">_</span><span class="p">,</span><span class="nv">_</span><span class="p">)</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">            </span><span class="nv">crash</span><span class="w"> </span><span class="s">"merge: The previous cases should be exhaustive."</span>
</code></pre></div>



<a name="445156271"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/445156271" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#445156271">(Jun 17 2024 at 15:09)</a>:</h4>
<ol>
<li><code>prepend</code> is a bad idea. You would be better appending and then reversing at the last moment. Every <code>prepend</code> will copy the entire list</li>
</ol>



<a name="445156931"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/445156931" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#445156931">(Jun 17 2024 at 15:12)</a>:</h4>
<ol start="2">
<li>you really should preallocate the output lists. So some sort of structure where you start with <code>List.withCapacity</code>. That way <code>List.prepend</code>/<code>List.append</code> won't be allocating a bunch.</li>
</ol>



<a name="445157081"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/445157081" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#445157081">(Jun 17 2024 at 15:12)</a>:</h4>
<ol start="3">
<li>If you actually want merge sort to be as fast as possible, you probably need to do it in place with indices.</li>
</ol>



<a name="445158021"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/445158021" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#445158021">(Jun 17 2024 at 15:16)</a>:</h4>
<p>As an extra note, <code>List.sortWith</code> is actually really slow compared to how fast it could be. <a class="stream-topic" data-stream-id="395097" href="/#narrow/stream/395097-compiler-development/topic/slow.20sorting">#compiler development &gt; slow sorting</a>.</p>



<a name="445158326"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/445158326" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#445158326">(Jun 17 2024 at 15:17)</a>:</h4>
<p>Oh also, the stack limit issue is probably due to <a href="https://github.com/roc-lang/roc/issues/6434">#6434</a>.</p>



<a name="445287206"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/445287206" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> GordonBGood <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#445287206">(Jun 18 2024 at 07:16)</a>:</h4>
<p><span class="user-mention silent" data-user-id="343810">Brendan Hansknecht</span> <a href="#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/445157081">said</a>:</p>
<blockquote>
<ol start="3">
<li>If you actually want merge sort to be as fast as possible, you probably need to do it in place with indices</li>
</ol>
</blockquote>
<p>Except that until in-place <code>List</code> mutations get more efficient as per our "bit-twiddling prime sieving" discussion, it is still going to be about 20 times slower than it should be...</p>
<p>Just for a point of reference, sorting a million random integers takes only a 100 or two milliseconds using arrays in languages that support direct array access, with "boxed" values as what Python is handling a bit slower in in something in the range of a half a second.  Roc doesn't really have the tools to be able to do this "in native" nor can it be properly tested without bringing in random data from outside Roc as has been mentioned.  An immutable Linked List implementation in Roc for the "bottom-up" merge sort is as follows:</p>
<div class="codehilite" data-code-language="roc"><pre><span></span><code>app [main] { pf: platform "https://github.com/roc-lang/basic-cli/releases/download/0.10.0/vNe6s9hWzoTZtFmNkvEICPErI9ptji_ySjicO6CkucY.tar.br" }

import pf.Stdout
import pf.Task

cSIZE : I32
cSIZE = 1000000

LinkedList a : [Empty, Cons a (LinkedList a)]

showLL : LinkedList a -&gt; Str where a implements Inspect
showLL = \ lst -&gt;
  shw = \ ill, oslst -&gt;
    when ill is
      Empty -&gt; Str.joinWith oslst ", "
      Cons v nxtll -&gt; shw nxtll (List.append oslst (Inspect.toStr v))
  shw lst []

reverseLL : LinkedList a -&gt; LinkedList a
reverseLL = \ lst -&gt;
  rvs = \ ilst, olst -&gt;
    when ilst is
      Empty -&gt; olst
      Cons v nxtll -&gt; rvs nxtll (Cons v olst)
  rvs lst Empty

# generates a LinkedList of I32' in reverse order to zero...
buildList : I32 -&gt; LinkedList I32
buildList = \ size -&gt;
  bld = \ n, lst -&gt;
    if n &lt; 0 then lst
    else bld (n - 1) (Cons n lst)
  bld (size - 1) Empty

makelsts : LinkedList I32, LinkedList (LinkedList I32)
             -&gt; LinkedList (LinkedList I32)
makelsts = \ lst, rlstlst -&gt;
  when lst is
    Empty -&gt; rlstlst
    Cons f ftl -&gt;
      when ftl is
        Empty -&gt; Cons (Cons f Empty) rlstlst
        Cons s stl -&gt;
          if f &lt;= s then makelsts stl (Cons (Cons f (Cons s Empty)) rlstlst)
          else makelsts stl (Cons (Cons s (Cons f Empty)) rlstlst)

append : LinkedList a, LinkedList a -&gt; LinkedList a
append = \ llst, rlst -&gt;
  when llst is
    Empty -&gt; reverseLL rlst
    Cons v vtl -&gt; append vtl (Cons v rlst)

merge : LinkedList I32, LinkedList I32, LinkedList I32 -&gt; LinkedList I32
merge = \ lstx, lsty, rlst -&gt;
  when lstx is
    Empty -&gt; append lsty rlst
    Cons x xtl -&gt;
      when lsty is
        Empty -&gt; append lstx rlst
        Cons y ytl -&gt;
          if x &lt;= y then merge xtl lsty (Cons x rlst)
          else merge lstx ytl (Cons y rlst)

pairs : LinkedList (LinkedList I32), LinkedList (LinkedList I32)
          -&gt; LinkedList (LinkedList I32)
pairs = \ lstlst, rlstlst -&gt;
  when lstlst is
    Empty -&gt; reverseLL rlstlst
    Cons xs xstl -&gt;
      when xstl is
        Empty -&gt; reverseLL (Cons xs rlstlst)
        Cons ys ystl -&gt; pairs ystl (Cons (merge xs ys Empty) rlstlst)

loop : LinkedList (LinkedList I32) -&gt; LinkedList I32
loop = \ lstlst -&gt;
  when lstlst is
    Empty -&gt; Empty
    Cons lst lsttl -&gt;
      when lsttl is
        Empty -&gt; lst
        _ -&gt; loop (pairs lstlst Empty)

# can't be generallized b because no Sort ability...
mergeSort : LinkedList I32 -&gt; LinkedList I32
mergeSort = \ lst -&gt;
  loop (makelsts lst Empty)

testSort : LinkedList I32 -&gt; Str
testSort = \ list -&gt;
  tst  = \ lst, last -&gt;
    when lst is
      Empty -&gt; "Linked List is sorted!"
      Cons v vtl -&gt;
        if v &gt;= last then tst vtl v
        else "Failed to sort Linked List!!!!!"
  when list is
    Empty -&gt; "Empty Linked Lists are considered sorted."
    Cons f ftl -&gt; tst ftl f

main =
  Stdout.line! "Merge Sorting \(Inspect.toStr cSIZE) 32-bit integers..."
  Stdout.line! (buildList 100 |&gt; mergeSort |&gt; showLL)
  Stdout.line! (buildList cSIZE |&gt; mergeSort |&gt; testSort)
</code></pre></div>
<p>The above sorts a million values in about a quarter of a second, but that isn't really worst case as they are already mostly sorted meaning that there won't be many missed branch predictions or cache misses with list nodes scattered all over heap memory; I would expect it to get three times or more slower if we could provide random data...</p>



<a name="445379484"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/445379484" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#445379484">(Jun 18 2024 at 14:51)</a>:</h4>
<p>Why are you showing a linked list?</p>



<a name="445379594"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/445379594" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#445379594">(Jun 18 2024 at 14:52)</a>:</h4>
<p>That will just make performance even worse due to pointer chasing.</p>



<a name="445468370"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/445468370" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#445468370">(Jun 18 2024 at 21:55)</a>:</h4>
<p>If you want a simple but kinda effecient mergesort, I would do this:</p>
<div class="spoiler-block"><div class="spoiler-header">
<p>alg</p>
</div><div class="spoiler-content" aria-hidden="true">
<div class="codehilite" data-code-language="Elm"><pre><span></span><code><span class="nv">mergeSort</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="nf">\</span><span class="nv">list</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">  </span><span class="nv">when</span><span class="w"> </span><span class="nv">list</span><span class="w"> </span><span class="nv">is</span>
<span class="w">    </span><span class="p">[]</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">      </span><span class="p">[]</span>
<span class="w">    </span><span class="p">[</span><span class="nv">_</span><span class="p">]</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">      </span><span class="nv">list</span>
<span class="w">    </span><span class="p">[</span><span class="nv">a</span><span class="p">,</span><span class="w"> </span><span class="nv">b</span><span class="p">]</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">      </span><span class="kr">if</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nf">&lt;=</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="kr">then</span>
<span class="w">        </span><span class="nv">list</span>
<span class="w">      </span><span class="kr">else</span>
<span class="w">        </span><span class="p">[</span><span class="nv">b</span><span class="p">,</span><span class="w"> </span><span class="nv">a</span><span class="p">]</span>
<span class="w">    </span><span class="nv">x</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">      </span><span class="nv">l</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="kt">List</span><span class="nf">.</span><span class="nv">len</span><span class="w"> </span><span class="nv">x</span>
<span class="w">      </span><span class="nv">m</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="nv">l</span><span class="w"> </span><span class="nf">//</span><span class="w"> </span><span class="mi">2</span>
<span class="w">      </span><span class="nv">left</span><span class="w"> </span><span class="nf">=</span>
<span class="w">        </span><span class="kt">List</span><span class="nf">.</span><span class="nv">takeFirst</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">m</span>
<span class="w">        </span><span class="nf">|&gt;</span><span class="w"> </span><span class="nv">mergeSort</span>
<span class="w">      </span><span class="nv">right</span><span class="w"> </span><span class="nf">=</span>
<span class="w">        </span><span class="kt">List</span><span class="nf">.</span><span class="nv">dropFirst</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">m</span>
<span class="w">        </span><span class="nf">|&gt;</span><span class="w"> </span><span class="nv">mergeSort</span>
<span class="w">      </span><span class="nv">merge</span><span class="w"> </span><span class="nv">left</span><span class="w"> </span><span class="nv">right</span><span class="w"> </span><span class="p">(</span><span class="kt">List</span><span class="nf">.</span><span class="nv">withCapacity</span><span class="w"> </span><span class="nv">l</span><span class="p">)</span>

<span class="nv">merge</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="nf">\</span><span class="nv">left</span><span class="p">,</span><span class="w"> </span><span class="nv">right</span><span class="p">,</span><span class="w"> </span><span class="nv">out</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">  </span><span class="nv">when</span><span class="w"> </span><span class="p">(</span><span class="nv">left</span><span class="p">,</span><span class="w"> </span><span class="nv">right</span><span class="p">)</span><span class="w"> </span><span class="nv">is</span>
<span class="w">    </span><span class="p">([</span><span class="nv">l</span><span class="p">,</span><span class="w"> </span><span class="nf">..</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nv">ls</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="nv">r</span><span class="p">,</span><span class="w"> </span><span class="nf">..</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nv">rs</span><span class="p">])</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">      </span><span class="kr">if</span><span class="w"> </span><span class="nv">l</span><span class="w"> </span><span class="nf">&lt;=</span><span class="w"> </span><span class="nv">r</span><span class="w"> </span><span class="kr">then</span>
<span class="w">        </span><span class="nv">merge</span><span class="w"> </span><span class="nv">ls</span><span class="w"> </span><span class="nv">right</span><span class="w"> </span><span class="p">(</span><span class="kt">List</span><span class="nf">.</span><span class="nv">append</span><span class="w"> </span><span class="nv">out</span><span class="w"> </span><span class="nv">l</span><span class="p">)</span>
<span class="w">      </span><span class="kr">else</span>
<span class="w">        </span><span class="nv">merge</span><span class="w"> </span><span class="nv">left</span><span class="w"> </span><span class="nv">rs</span><span class="w"> </span><span class="p">(</span><span class="kt">List</span><span class="nf">.</span><span class="nv">append</span><span class="w"> </span><span class="nv">out</span><span class="w"> </span><span class="nv">r</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">_</span><span class="p">,</span><span class="w"> </span><span class="p">[])</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">      </span><span class="kt">List</span><span class="nf">.</span><span class="nv">concat</span><span class="w"> </span><span class="nv">out</span><span class="w"> </span><span class="nv">left</span>
<span class="w">    </span><span class="p">([],</span><span class="w"> </span><span class="nv">_</span><span class="p">)</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">      </span><span class="kt">List</span><span class="nf">.</span><span class="nv">concat</span><span class="w"> </span><span class="nv">out</span><span class="w"> </span><span class="nv">right</span>
</code></pre></div>
</div></div>



<a name="445477674"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/445477674" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> GordonBGood <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#445477674">(Jun 18 2024 at 23:17)</a>:</h4>
<p><span class="user-mention silent" data-user-id="343810">Brendan Hansknecht</span> <a href="#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/445379484">said</a>:</p>
<blockquote>
<p>Why are you showing a linked list?<br>
That will just make performance even worse due to pointer chasing.</p>
</blockquote>
<p>That's my point:  This linked list implementation is actually showing better performance than the current built-in "native" implementation of <code>List.sortWith</code>(althouugh that is using quickSort under the covers) and ais currently much faster than using a custom merge sort using the current state of List indexing due to the non-optimized in-place mutation...</p>
<p>In Elm, Linked List's are all we have that are suitable for writing alternate sorting algorithms, and code such as this sorting a million random Int's runs a sort in a little over a second and is comparable in speed to Haskell's built-in (lazy) List sort doing the same, although a little over twice as slow as Elm's built-in sort calling the JavaScript engine's implementation of an array sort usually implemented as an array Timsort written in C/C++ (converting the links list to a JavaScript array at the beginning and back at the end) although slower in having to deal with JavaScript's boxed objects...</p>
<p>So the following is an implementation of merge sort using List indexing:</p>
<div class="codehilite" data-code-language="Elm"><pre><span></span><code><span class="nv">buildList</span><span class="w"> </span><span class="nf">:</span><span class="w"> </span><span class="kt">U64</span><span class="w"> </span><span class="nf">-&gt;</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="kt">I32</span>
<span class="nv">buildList</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="nv">size</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">  </span><span class="nv">loopi</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="nv">lst</span><span class="p">,</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nf">&gt;=</span><span class="w"> </span><span class="nv">size</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="kt">List</span><span class="nf">.</span><span class="nv">reverse</span><span class="w"> </span><span class="nv">lst</span>
<span class="w">    </span><span class="kr">else</span><span class="w"> </span><span class="nv">loopi</span><span class="w"> </span><span class="p">(</span><span class="kt">List</span><span class="nf">.</span><span class="nv">set</span><span class="w"> </span><span class="nv">lst</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="p">(</span><span class="kt">Num</span><span class="nf">.</span><span class="nv">intCast</span><span class="w"> </span><span class="nv">i</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nv">i</span><span class="w"> </span><span class="nf">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="kt">List</span><span class="nf">.</span><span class="nv">repeat</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nv">size</span><span class="w"> </span><span class="nf">|&gt;</span><span class="w"> </span><span class="nv">loopi</span><span class="w"> </span><span class="mi">0</span>

<span class="nv">sortByTwos</span><span class="w"> </span><span class="nf">:</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="kt">I32</span><span class="w"> </span><span class="nf">-&gt;</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="kt">I32</span>
<span class="nv">sortByTwos</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="nv">list</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">  </span><span class="nv">len</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="kt">List</span><span class="nf">.</span><span class="nv">len</span><span class="w"> </span><span class="nv">list</span>
<span class="w">  </span><span class="nv">loopi</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="nv">lst</span><span class="p">,</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nf">&gt;=</span><span class="w"> </span><span class="nv">len</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="nv">lst</span><span class="w"> </span><span class="kr">else</span>
<span class="w">    </span><span class="nv">lft</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="kt">List</span><span class="nf">.</span><span class="nv">get</span><span class="w"> </span><span class="nv">lst</span><span class="w"> </span><span class="p">(</span><span class="nv">i</span><span class="w"> </span><span class="nf">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="nf">|&gt;</span><span class="w"> </span><span class="kt">Result</span><span class="nf">.</span><span class="nv">withDefault</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="nv">rgt</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="kt">List</span><span class="nf">.</span><span class="nv">get</span><span class="w"> </span><span class="nv">lst</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nf">|&gt;</span><span class="w"> </span><span class="kt">Result</span><span class="nf">.</span><span class="nv">withDefault</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="nv">lft</span><span class="w"> </span><span class="nf">&gt;</span><span class="w"> </span><span class="nv">rgt</span><span class="w"> </span><span class="kr">then</span>
<span class="w">      </span><span class="nv">loopi</span><span class="w"> </span><span class="p">(</span><span class="kt">List</span><span class="nf">.</span><span class="nv">swap</span><span class="w"> </span><span class="nv">lst</span><span class="w"> </span><span class="p">(</span><span class="nv">i</span><span class="w"> </span><span class="nf">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">i</span><span class="w"> </span><span class="nf">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="kr">else</span><span class="w"> </span><span class="nv">loopi</span><span class="w"> </span><span class="nv">lst</span><span class="w"> </span><span class="p">(</span><span class="nv">i</span><span class="w"> </span><span class="nf">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">  </span><span class="nv">loopi</span><span class="w"> </span><span class="nv">list</span><span class="w"> </span><span class="mi">1</span>

<span class="nv">copylst</span><span class="w"> </span><span class="nf">:</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="kt">I32</span><span class="p">,</span><span class="w"> </span><span class="kt">U64</span><span class="p">,</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="kt">I32</span><span class="p">,</span><span class="w"> </span><span class="kt">U64</span><span class="p">,</span><span class="w"> </span><span class="kt">U64</span><span class="w"> </span><span class="nf">-&gt;</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="kt">I32</span>
<span class="nv">copylst</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="nv">srclst</span><span class="p">,</span><span class="w"> </span><span class="nv">si</span><span class="p">,</span><span class="w"> </span><span class="nv">dstlst</span><span class="p">,</span><span class="w"> </span><span class="nv">di</span><span class="p">,</span><span class="w"> </span><span class="nv">num</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">  </span><span class="kr">if</span><span class="w"> </span><span class="nv">num</span><span class="w"> </span><span class="nf">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="nv">dstlst</span><span class="w"> </span><span class="kr">else</span>
<span class="w">  </span><span class="nv">sv</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="kt">List</span><span class="nf">.</span><span class="nv">get</span><span class="w"> </span><span class="nv">srclst</span><span class="w"> </span><span class="nv">si</span><span class="w"> </span><span class="nf">|&gt;</span><span class="w"> </span><span class="kt">Result</span><span class="nf">.</span><span class="nv">withDefault</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="nv">copylst</span><span class="w"> </span><span class="nv">srclst</span><span class="w"> </span><span class="p">(</span><span class="nv">si</span><span class="w"> </span><span class="nf">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="kt">List</span><span class="nf">.</span><span class="nv">set</span><span class="w"> </span><span class="nv">dstlst</span><span class="w"> </span><span class="nv">di</span><span class="w"> </span><span class="nv">sv</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">di</span><span class="w"> </span><span class="nf">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">          </span><span class="p">(</span><span class="nv">num</span><span class="w"> </span><span class="nf">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="nv">merge</span><span class="w"> </span><span class="nf">:</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="kt">I32</span><span class="p">,</span><span class="w"> </span><span class="kt">U64</span><span class="p">,</span><span class="w"> </span><span class="kt">U64</span><span class="p">,</span><span class="w"> </span><span class="kt">U64</span><span class="p">,</span><span class="w"> </span><span class="kt">U64</span><span class="p">,</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="kt">I32</span><span class="p">,</span><span class="w"> </span><span class="kt">U64</span><span class="w"> </span><span class="nf">-&gt;</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="kt">I32</span>
<span class="nv">merge</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="nv">ilst</span><span class="p">,</span><span class="w"> </span><span class="nv">xi</span><span class="p">,</span><span class="w"> </span><span class="nv">xlmt</span><span class="p">,</span><span class="w"> </span><span class="nv">yi</span><span class="p">,</span><span class="w"> </span><span class="nv">ylmt</span><span class="p">,</span><span class="w"> </span><span class="nv">olst</span><span class="p">,</span><span class="w"> </span><span class="nv">oi</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">  </span><span class="kr">if</span><span class="w"> </span><span class="nv">xi</span><span class="w"> </span><span class="nf">&gt;=</span><span class="w"> </span><span class="nv">xlmt</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="nv">copylst</span><span class="w"> </span><span class="nv">ilst</span><span class="w"> </span><span class="nv">yi</span><span class="w"> </span><span class="nv">olst</span><span class="w"> </span><span class="nv">oi</span><span class="w"> </span><span class="p">(</span><span class="nv">ylmt</span><span class="w"> </span><span class="nf">-</span><span class="w"> </span><span class="nv">yi</span><span class="p">)</span>
<span class="w">  </span><span class="kr">else</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="nv">yi</span><span class="w"> </span><span class="nf">&gt;=</span><span class="w"> </span><span class="nv">ylmt</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="nv">copylst</span><span class="w"> </span><span class="nv">ilst</span><span class="w"> </span><span class="nv">xi</span><span class="w"> </span><span class="nv">olst</span><span class="w"> </span><span class="nv">oi</span><span class="w"> </span><span class="p">(</span><span class="nv">xlmt</span><span class="w"> </span><span class="nf">-</span><span class="w"> </span><span class="nv">xi</span><span class="p">)</span>
<span class="w">  </span><span class="kr">else</span>
<span class="w">    </span><span class="nv">x</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="kt">List</span><span class="nf">.</span><span class="nv">get</span><span class="w"> </span><span class="nv">ilst</span><span class="w"> </span><span class="nv">xi</span><span class="w"> </span><span class="nf">|&gt;</span><span class="w"> </span><span class="kt">Result</span><span class="nf">.</span><span class="nv">withDefault</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="nv">y</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="kt">List</span><span class="nf">.</span><span class="nv">get</span><span class="w"> </span><span class="nv">ilst</span><span class="w"> </span><span class="nv">yi</span><span class="w"> </span><span class="nf">|&gt;</span><span class="w"> </span><span class="kt">Result</span><span class="nf">.</span><span class="nv">withDefault</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nf">&lt;=</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="nv">merge</span><span class="w"> </span><span class="nv">ilst</span><span class="w"> </span><span class="p">(</span><span class="nv">xi</span><span class="w"> </span><span class="nf">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="nv">xlmt</span><span class="w"> </span><span class="nv">yi</span><span class="w"> </span><span class="nv">ylmt</span><span class="w"> </span><span class="p">(</span><span class="kt">List</span><span class="nf">.</span><span class="nv">set</span><span class="w"> </span><span class="nv">olst</span><span class="w"> </span><span class="nv">oi</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">oi</span><span class="w"> </span><span class="nf">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="kr">else</span><span class="w"> </span><span class="nv">merge</span><span class="w"> </span><span class="nv">ilst</span><span class="w"> </span><span class="nv">xi</span><span class="w"> </span><span class="nv">xlmt</span><span class="w"> </span><span class="p">(</span><span class="nv">yi</span><span class="w"> </span><span class="nf">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="nv">ylmt</span><span class="w"> </span><span class="p">(</span><span class="kt">List</span><span class="nf">.</span><span class="nv">set</span><span class="w"> </span><span class="nv">olst</span><span class="w"> </span><span class="nv">oi</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">oi</span><span class="w"> </span><span class="nf">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>

<span class="nv">pairs</span><span class="w"> </span><span class="nf">:</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="kt">I32</span><span class="p">,</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="kt">I32</span><span class="p">,</span><span class="w"> </span><span class="kt">U64</span><span class="w"> </span><span class="nf">-&gt;</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="kt">I32</span>
<span class="nv">pairs</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="nv">srclst</span><span class="p">,</span><span class="w"> </span><span class="nv">dstlst</span><span class="p">,</span><span class="w"> </span><span class="nv">mrgsz</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">  </span><span class="nv">len</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="kt">List</span><span class="nf">.</span><span class="nv">len</span><span class="w"> </span><span class="nv">srclst</span>
<span class="w">  </span><span class="nv">loopi</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="nv">dlst</span><span class="p">,</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nf">&gt;=</span><span class="w"> </span><span class="nv">len</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="nv">dlst</span><span class="w"> </span><span class="kr">else</span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nf">+</span><span class="w"> </span><span class="nv">mrgsz</span><span class="w"> </span><span class="nf">&gt;=</span><span class="w"> </span><span class="nv">len</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="nv">copylst</span><span class="w"> </span><span class="nv">srclst</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">dlst</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="p">(</span><span class="nv">len</span><span class="w"> </span><span class="nf">-</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="kr">else</span>
<span class="w">    </span><span class="nv">xlmt</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nf">+</span><span class="w"> </span><span class="nv">mrgsz</span>
<span class="w">    </span><span class="nv">ylmt</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="kt">Num</span><span class="nf">.</span><span class="nv">min</span><span class="w"> </span><span class="nv">len</span><span class="w"> </span><span class="p">(</span><span class="nv">xlmt</span><span class="w"> </span><span class="nf">+</span><span class="w"> </span><span class="nv">mrgsz</span><span class="p">)</span>
<span class="w">    </span><span class="nv">loopi</span><span class="w"> </span><span class="p">(</span><span class="nv">merge</span><span class="w"> </span><span class="nv">srclst</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">xlmt</span><span class="w"> </span><span class="nv">xlmt</span><span class="w"> </span><span class="nv">ylmt</span><span class="w"> </span><span class="nv">dlst</span><span class="w"> </span><span class="nv">i</span><span class="p">)</span><span class="w"> </span><span class="nv">ylmt</span>
<span class="w">  </span><span class="nv">loopi</span><span class="w"> </span><span class="nv">dstlst</span><span class="w"> </span><span class="mi">0</span>

<span class="nv">loop</span><span class="w"> </span><span class="nf">:</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="kt">I32</span><span class="p">,</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="kt">I32</span><span class="p">,</span><span class="w"> </span><span class="kt">U64</span><span class="w"> </span><span class="nf">-&gt;</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="kt">I32</span>
<span class="nv">loop</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="nv">srclst</span><span class="p">,</span><span class="w"> </span><span class="nv">dstlst</span><span class="p">,</span><span class="w"> </span><span class="nv">lstsz</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">  </span><span class="nv">len</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="kt">List</span><span class="nf">.</span><span class="nv">len</span><span class="w"> </span><span class="nv">srclst</span>
<span class="w">  </span><span class="kr">if</span><span class="w"> </span><span class="nv">lstsz</span><span class="w"> </span><span class="nf">&gt;=</span><span class="w"> </span><span class="nv">len</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="nv">srclst</span>
<span class="w">  </span><span class="kr">else</span><span class="w"> </span><span class="nv">loop</span><span class="w"> </span><span class="p">(</span><span class="nv">pairs</span><span class="w"> </span><span class="nv">srclst</span><span class="w"> </span><span class="nv">dstlst</span><span class="w"> </span><span class="nv">lstsz</span><span class="p">)</span><span class="w"> </span><span class="nv">srclst</span><span class="w"> </span><span class="p">(</span><span class="nv">lstsz</span><span class="w"> </span><span class="nf">*</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>

<span class="nv">mergeSort</span><span class="w"> </span><span class="nf">:</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="kt">I32</span><span class="w"> </span><span class="nf">-&gt;</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="kt">I32</span>
<span class="nv">mergeSort</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="nv">lst</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">  </span><span class="nv">altlst</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="kt">List</span><span class="nf">.</span><span class="nv">repeat</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="kt">List</span><span class="nf">.</span><span class="nv">len</span><span class="w"> </span><span class="nv">lst</span><span class="p">)</span>
<span class="w">  </span><span class="nv">lst</span><span class="w"> </span><span class="nf">|&gt;</span><span class="w"> </span><span class="nv">sortByTwos</span><span class="w"> </span><span class="nf">|&gt;</span><span class="w"> </span><span class="nv">loop</span><span class="w"> </span><span class="nv">altlst</span><span class="w"> </span><span class="mi">2</span>

<span class="nv">testSort</span><span class="w"> </span><span class="nf">:</span><span class="w"> </span><span class="kt">List</span><span class="w"> </span><span class="kt">I32</span><span class="w"> </span><span class="nf">-&gt;</span><span class="w"> </span><span class="kt">Str</span>
<span class="nv">testSort</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="nv">lst</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">  </span><span class="nv">len</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="kt">List</span><span class="nf">.</span><span class="nv">len</span><span class="w"> </span><span class="nv">lst</span>
<span class="w">  </span><span class="nv">loopi</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="nf">\</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nf">-&gt;</span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nf">&gt;=</span><span class="w"> </span><span class="nv">len</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="s">"List sorted correctly!"</span><span class="w"> </span><span class="kr">else</span>
<span class="w">    </span><span class="nv">f</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="kt">List</span><span class="nf">.</span><span class="nv">get</span><span class="w"> </span><span class="nv">lst</span><span class="w"> </span><span class="p">(</span><span class="nv">i</span><span class="w"> </span><span class="nf">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="nf">|&gt;</span><span class="w"> </span><span class="kt">Result</span><span class="nf">.</span><span class="nv">withDefault</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="nv">s</span><span class="w"> </span><span class="nf">=</span><span class="w"> </span><span class="kt">List</span><span class="nf">.</span><span class="nv">get</span><span class="w"> </span><span class="nv">lst</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nf">|&gt;</span><span class="w"> </span><span class="kt">Result</span><span class="nf">.</span><span class="nv">withDefault</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="nv">s</span><span class="w"> </span><span class="nf">&lt;</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="s">"Error in List sorting!!!!!"</span>
<span class="w">    </span><span class="kr">else</span><span class="w"> </span><span class="nv">loopi</span><span class="w"> </span><span class="p">(</span><span class="nv">i</span><span class="w"> </span><span class="nf">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="nv">loopi</span><span class="w"> </span><span class="mi">1</span>
</code></pre></div>
<p>This segfaults for some reason for a million entries but can sort a list of half a million integers in about 0.6 seconds meaning that a million entries would take something like 1.3 seconds (O(n log n)) and this is quite a bit slower than the Linked List merge sort above, which also doesn't segfault.  If the optimization for in-place mutation of List's (and what causes the segfault) were fixed, of course an indexed List sort would be faster...</p>
<p>It is also quite trivial to add recognition of pre-existing runs to the initialization for a Linked List based merge sort, unlike for indexed List sorts.</p>
<p>I don't say that Roc should use Linked List sorts, just that the current state of Roc doesn't really support anything better...</p>



<a name="445485818"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/445485818" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#445485818">(Jun 19 2024 at 00:49)</a>:</h4>
<p>In my testing (might be an m1 mac memory thing), the merge sort I wrote above is approximately the same speed as your linked list merge sort (which is pretty sad cause it should be faster, though this merge sort version does allocate for all intermediate lists). Naive merge sort is actually a pretty bad algorithm for sorting contiguous arrays, even the inplace version.</p>
<p>That said, I would still recommend it over using a linked list sort. Cause the linked list will hurt with everything else you do even if it does sort faster.</p>
<p>We probably should pull our sorting algorithm out of zig for now in order to get reasonable performance. That or if someone has time and is willing to contribute, we need to generate element swapping functions and pass them into zig. That hopefully would inline and optimize happily. It would at a minimum be much better than memcpy for swapping elements.</p>



<a name="445486046"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/445486046" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#445486046">(Jun 19 2024 at 00:52)</a>:</h4>
<p>But yeah, overall, the horrible performance here is definitely a major roc bug.</p>



<a name="445492381"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/445492381" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> GordonBGood <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#445492381">(Jun 19 2024 at 01:53)</a>:</h4>
<p><span class="user-mention silent" data-user-id="343810">Brendan Hansknecht</span> <a href="#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/445486046">said</a>:</p>
<blockquote>
<p>the horrible performance here is definitely a major roc bug.</p>
</blockquote>
<p>That's exactly the point I was trying to make; but also that the current implementation of sorting in Zig isn't very good either as you say...</p>
<p><span class="user-mention silent" data-user-id="343810">Brendan Hansknecht</span> <a href="#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/445486046">said</a>:</p>
<blockquote>
<p>Naive merge sort is actually a pretty bad algorithm for sorting contiguous arrays, even the in-place version.</p>
</blockquote>
<p><strong>Ah, I think that by "naive", you mean top-down and intermediate allocating as per your implemented - yes, that kind of "naive" is pretty bad although simpler; you notice that I prefer bottom-up for partly in-place sorting for my implementation although it does still need to alternate between two arrays with the final destination the resulting one.  I think your poorer results for the Linked List version are indeed due to slower memory allocation on macOS where I was running on Linux, as I often see this difference</strong></p>
<p>It's funny you should say that considering that most common sorting implementations in most languages are just variations of array merge sorting, which includes Timsort, the new Powersort that Python currently uses, etc.; if one wants a reasonable performance general-purpose stable sort with good general performance where worst case is about the same as average performance for random data, these seem to be state-of-the-art; if one is willing to give up stable sorting or having extreme worst case performance, there are some exotic sorting algorithms that can deliver for some special cases...</p>



<a name="453253056"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453253056" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> GordonBGood <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453253056">(Jul 22 2024 at 18:51)</a>:</h4>
<p><span class="user-mention silent" data-user-id="686843">GordonBGood</span> <a href="#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/445492381">said</a>:</p>
<blockquote>
<p><strong>you notice that I prefer bottom-up for partly in-place sorting for my implementation although it does still need to alternate between two arrays with the final destination the resulting one</strong></p>
</blockquote>
<p>Just to finish this up, now that there is a <strong>TESTING</strong> branch of nightlies that has fixed the in-place mutation so it is now very fast, indexed List/array merge sorting works about as fast as in any of the fastest languages, as per the following code, which does a bottom-up merge sort:</p>
<div class="codehilite" data-code-language="roc"><pre><span></span><code>app [main] { pf: platform "https://github.com/roc-lang/basic-cli/releases/download/0.10.0/vNe6s9hWzoTZtFmNkvEICPErI9ptji_ySjicO6CkucY.tar.br" }

import pf.Stdout
import pf.Task
import pf.Utc exposing [ now, deltaAsMillis ]

cLIMIT : U64
cLIMIT = 1_000_000

RandSeed : (U64, U64)

initRandSeed : RandSeed
initRandSeed = (0x69B4C98CB8530805u64, 0xFED1DD3004688D68u64)

nextRandI64 : RandSeed -&gt; (RandSeed, I64)
nextRandI64 = \ r -&gt;
  s0 = r.0
  s1 = r.1
  ns1 = Num.bitwiseXor s0 s1
  nr0 = Num.shiftLeftBy s0 55 |&gt; Num.bitwiseOr (Num.shiftRightZfBy s0 9)
          |&gt; Num.bitwiseXor ns1 |&gt; Num.bitwiseXor (Num.shiftLeftBy ns1 14) # a, b
  nr1 = Num.shiftLeftBy ns1 36 |&gt; Num.bitwiseOr (Num.shiftRightZfBy ns1 28) # c
  ((nr0, nr1), Num.intCast (Num.addWrap s0 s1))

buildList : U64 -&gt; List I64
buildList = \ size -&gt;
  loopi = \ lst, r, i -&gt;
    if i &gt;= size then lst else
    (nr, rv) = nextRandI64 r
    loopi (List.set lst i rv) nr (i + 1)
  List.repeat 0 size |&gt; loopi initRandSeed 0

mergeSort : List I64 -&gt; List I64
mergeSort = \ ilist -&gt;
  sortByTwos = \ list -&gt;
    len = List.len list
    loopi = \ lst, i -&gt;
      if i &gt;= len then lst else
      lft = List.get lst (i - 1)|&gt; Result.withDefault 0
      rgt = List.get lst i |&gt; Result.withDefault 0
      if lft &gt; rgt then loopi (List.swap lst (i - 1) i) (i + 2)
      else loopi lst (i + 2)
    loopi list 1
  copylst = \ srclst, si, dstlst, di, num -&gt;
    if num &lt;= 0 then dstlst else
    sv = List.get srclst si |&gt; Result.withDefault 0
    copylst srclst (si + 1)
            (List.set dstlst di sv) (di + 1)
            (num - 1)
  merge = \ ilst, xi, xlmt, yi, ylmt, olst, oi -&gt;
    if xi &gt;= xlmt then copylst ilst yi olst oi (ylmt - yi)
    else if yi &gt;= ylmt then copylst ilst xi olst oi (xlmt - xi)
    else
      x = List.get ilst xi |&gt; Result.withDefault 0
      y = List.get ilst yi |&gt; Result.withDefault 0
      if x &lt;= y then merge ilst (xi + 1) xlmt yi ylmt (List.set olst oi x) (oi + 1)
      else merge ilst xi xlmt (yi + 1) ylmt (List.set olst oi y) (oi + 1)
  pairs = \ srclst, dstlst, mrgsz -&gt;
    len = List.len srclst
    loopi = \ dlst, i -&gt;
      if i &gt;= len then dlst else
      if i + mrgsz &gt;= len then copylst srclst i dlst i (len - i) else
      xlmt = i + mrgsz
      ylmt = Num.min len (xlmt + mrgsz)
      loopi (merge srclst i xlmt xlmt ylmt dlst i) ylmt
    loopi dstlst 0
  loop = \ srclst, dstlst, lstsz -&gt;
    len = List.len srclst
    if lstsz &gt;= len then srclst
    else loop (pairs srclst dstlst lstsz) srclst (lstsz * 2)
  altlst = List.repeat 0 (List.len ilist)
  ilist |&gt; sortByTwos |&gt; loop altlst 2

testSort : List I64 -&gt; Bool
testSort = \ lst -&gt;
  len = List.len lst
  loopi = \ i -&gt;
    if i &gt;= len then Bool.true else
    f = List.get lst (i - 1) |&gt; Result.withDefault 0
    s = List.get lst i |&gt; Result.withDefault 0
    if s &lt; f then Bool.false else loopi (i + 1)
  loopi 1

main =
    tstlst = buildList cLIMIT
    start = now!
    answrlst = tstlst |&gt; mergeSort
    stop = now!
    elpsdStr = deltaAsMillis start stop |&gt; Num.toStr
    shwlst = answrlst |&gt; List.takeFirst 100
    Stdout.line! "$(Inspect.toStr shwlst)"
    Stdout.line! ( if testSort answrlst then "List sorted correctly!"
                   else "Failure in sorting list!!!" )
    Stdout.line! "Sorted $(cLIMIT |&gt; Num.toStr) integers in $(elpsdStr) milliseconds."
</code></pre></div>
<p>The above code sorts a million pseudo random 64-bit integers in about 89 milliseconds with my AMD 7840HS CPU running at 5.1 GHz when single-threaded as here, and that is fast!!!  As mentioned in the thread, bottom-up sorting avoids the many allocations for doing partitioning that many top-down versions do and this version just alternates sorting between the original and the alternate allocated array and just returns the last destination one.</p>
<p>Most languages standard library sorting functions prefer a merge sort because it is a stable sort where equal values maintain their order in the List, and because worst case sorting time is still O(n log n) unlike quicksort which is not a stable sort and can be very slow when given a pre-sorted or partially sorted List and the "pivot" point(s) chosen incorrectly.  For production, one would probably translate Python's new "power sort" which accounts for pre-sorted runs in the List/array although it does an increase in memory from a factor of twice the size of the List/array as here to up to half again as much for a "stack" of the lengths of the found runs...</p>



<a name="453255128"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453255128" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453255128">(Jul 22 2024 at 19:03)</a>:</h4>
<p>Awesome to see this panning out in practice as real perf gains!</p>
<hr>
<p>I need to look into power sort more. To my understanding glidesort actually uses it as a primitive for example. Cause generally speaking if you are will to allocate a little (sqrt of N) you can sort faster than what you get out of a merge sort.</p>
<p>But you always need the merge sort as the backup for bad cases where quicksort would recurse too far or require too much memory.</p>



<a name="453255802"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453255802" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453255802">(Jul 22 2024 at 19:06)</a>:</h4>
<p>looks like power sort also uses extra memory: <code>but they use a linear-size buﬀer for eﬃcient merging.</code></p>



<a name="453256501"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453256501" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453256501">(Jul 22 2024 at 19:09)</a>:</h4>
<p>very cool!</p>



<a name="453256551"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453256551" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453256551">(Jul 22 2024 at 19:10)</a>:</h4>
<p>btw I don't think stable sorting matters in our case because Roc as a language never exposes reference equality</p>



<a name="453256680"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453256680" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453256680">(Jul 22 2024 at 19:10)</a>:</h4>
<p>so I don't think the stability of a sort is observable in Roc code, just in the host</p>



<a name="453257428"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453257428" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453257428">(Jul 22 2024 at 19:14)</a>:</h4>
<p>It is noticable in roc cause the users can set the compare function.</p>
<div class="codehilite"><pre><span></span><code>main =
    x = [2.4, 1.2, 2.3, 2.2, 2.1]
    List.sortWith x \a, b -&gt;
        Num.compare (Num.round a) (Num.round b)
    |&gt; Inspect.toStr
    |&gt; Stdout.line!
</code></pre></div>
<p><code>[1.2, 2.1, 2.4, 2.3, 2.2]</code></p>
<p>Our sort is currently unstable. Stable would produce:<br>
<code>[1.2, 2.4, 2.3, 2.2, 2.1]</code></p>



<a name="453257652"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453257652" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453257652">(Jul 22 2024 at 19:15)</a>:</h4>
<p>ah fair point <span aria-label="thumbs up" class="emoji emoji-1f44d" role="img" title="thumbs up">:thumbs_up:</span></p>



<a name="453315021"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453315021" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> GordonBGood <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453315021">(Jul 23 2024 at 03:24)</a>:</h4>
<p><span class="user-mention silent" data-user-id="343810">Brendan Hansknecht</span> <a href="#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/453255128">said</a>:</p>
<blockquote>
<p>I need to look into power sort more. To my understanding glidesort actually uses it as a primitive for example. Cause generally speaking if you are will to allocate a little (sqrt of N) you can sort faster than what you get out of a merge sort.</p>
</blockquote>
<p>All of these "in-place" List/array indexing sorts that respect pre-existing "runs" of data are going to need to allocate a little extra space to keep track of the length of the "runs" yet to be sorted, which is their cost in order to be able to take advantage of those pre-existing runs yet enjoy the advantages of an indexing in-place stable sort; then, managing that extra allocated memory will add to their execution time cost that will detract from the advantage of using the pre-existing "runs".</p>
<p>I think that the choices between powersort, glidesort, and any other variations gets into nit-picky type of territory:  All try to balance out the number of merges so that the sorting algorithm more often is merging runs of about equal length for efficiency (less copy moves on average) even though the pre-existing runs may differ greatly in length.  Some of the more exotic variations try to do intelligent decisions between different sorting methods based on the "shape" of the data, but it seems to me there will always be cases where the decisions will fail.  The very competent Python contributor, Tim Peters, went through all the research and comparisons and chose powersort, but says that there may be (obscure - GBG) cases where other algorithms give better performance.  I think its a situation where other slightly different algorithms may give somewhat better performance for certain run combinations but then worse for some situations where power sort is better.</p>
<p>It seems to me that we could save time by respecting Tim Peter's research and just implementing a Roc version of the C code he uses for the new Python standard library sort...</p>



<a name="453319958"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453319958" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453319958">(Jul 23 2024 at 04:15)</a>:</h4>
<p>I agree with the general sentiment here, and I think that powersort would be a reasonable algorithm for roc. Like it obviously won't be bad. Clearly will be better than what we currently have by a lot. From real world measurements, it is essentially strictly better than timsort. That said, timsort has had a well known really bad case for a long time where it ends up merging length ~1 arrays with giant arrays.</p>
<p>That said, I think there is definitely more to consider here:</p>
<ol>
<li>python is always dealing with python objects. That significantly changes the sorting tradeoff due to extra pointer indirection and the actually thing being sorted always being relatively small in size.</li>
<li>Algorithms like glidesort, fluxsort, powersort, quadsort, etc are consistently able to beat timsort (by a large margin). So it isn't a good benchmark.</li>
<li>Powersort does not require a little bit of extra memory, it requires a lot of extra memory. In the worst case, it requires an element buffer of size <code>n/2</code>. For any given merge of arrays <code>A</code> and <code>B</code> it requires <code>min(len(A), len(B))</code> extra memory.</li>
<li>Quadsort, which is roughly equivalent to powersort can be significantly slower than fluxsort (a quicksort-like wrapper to quadsort) for certain cases where data is more organized.</li>
<li>blitsort with sqrt of n memory has approximately equivalent perf to fluxsort.</li>
</ol>



<a name="453326163"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453326163" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> GordonBGood <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453326163">(Jul 23 2024 at 04:52)</a>:</h4>
<p><span class="user-mention silent" data-user-id="343810">Brendan Hansknecht</span> <a href="#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/453319958">said</a>:</p>
<blockquote>
<p>That said, timsort has had a well known really bad case for a long time where it ends up merging length ~1 arrays with giant arrays.</p>
</blockquote>
<p>Yes, that has been known about timsort for quite some time, which is why most implementations are a modified timsort to avoid the corner case, and probably is part of the drive to change - to powersort, which can be proved to not have that case...</p>
<blockquote>
<p>That said, I think there is definitely more to consider here:</p>
<ol>
<li>python is always dealing with python objects. That significantly changes the sorting tradeoff due to extra pointer indirection and the actually thing being sorted always being relatively small in size.</li>
</ol>
</blockquote>
<p>True, but that is a trade for any sorting algorithm as to digging down to the actual "key" comparison value and the comparisons should still be valid, just that non some cases of unboxed values will be faster and some that don't box such as tuples and records may be slower...</p>
<blockquote>
<ol start="2">
<li>Algorithms like glidesort, fluxsort, powersort, quadsort, etc are consistently able to beat timsort (by a large margin). So it isn't a good benchmark.</li>
</ol>
</blockquote>
<p>Skipping timsort, we are only concerned with comparisons between powersort and the others...</p>
<blockquote>
<ol start="3">
<li>Powersort does not require a little bit of extra memory, it requires a lot of extra memory. In the worst case, it requires an element buffer of size <code>n/2</code>. For any given merge of arrays <code>A</code> and <code>B</code> it requires <code>min(len(A), len(B))</code> extra memory.</li>
</ol>
</blockquote>
<p>Well, efficient in-place mergesort requires as much extra memory as the array to be sorted, so adding an extra half again extra doesn't seem all that bad - if memory use is a problem, one can switch to one of the others that use a little less, but as far as I can see, all of them use some extra if they are to be stable sorts...</p>
<blockquote>
<ol start="4">
<li>Quadsort, which is roughly equivalent to powersort can be significantly slower than fluxsort (a quicksort-like wrapper to quadsort) for certain cases where data is more organized.</li>
</ol>
</blockquote>
<p>There are always cases...</p>
<blockquote>
<ol start="5">
<li>blitsort with sqrt of n memory has approximately equivalent perf to fluxsort.</li>
</ol>
</blockquote>
<p>If low memory use is an essential criteria, then that looks like it might be a good alternative, but what are the other trade offs?</p>



<a name="453327281"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453327281" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453327281">(Jul 23 2024 at 05:02)</a>:</h4>
<blockquote>
<p>If low memory use is an essential criteria</p>
</blockquote>
<p>This is probably a very good question that we should be asking ourselves. How much memory are we ok with roc's default sort using? <span class="user-mention" data-user-id="281383">@Richard Feldman</span> any thoughts?</p>
<p>I had always assumed the goal was essentially constant memory, but that was definitely a naive assumption. I guess in essentially all commonly used language sorting algorithms, the answer is roughly <code>n/2</code> to <code>n</code> extra memory. I think the main gain of glidesort and blitsort is that they use essentially constant memory (can be restricted to truly constant, but sqrt of n required for full perf) while being competitive with powersort/quadsort. Also due to taking advantage of a few patterns and a top level quicksort in general have slightly better perf.</p>



<a name="453327590"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453327590" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453327590">(Jul 23 2024 at 05:05)</a>:</h4>
<blockquote>
<p>but what are the other trade offs?</p>
</blockquote>
<p>Main tradeoff is in very large merges. They will require more cycles of the buffer which is slower than just having a single large buffer. In practice, this is not much of a cost as long as you have the sqrt of n memory.</p>



<a name="453332142"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453332142" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453332142">(Jul 23 2024 at 05:41)</a>:</h4>
<p>it's a good question; by default I'd say top priority is fastest overall sorting performance, but it's not the only consideration</p>



<a name="453332284"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453332284" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453332284">(Jul 23 2024 at 05:42)</a>:</h4>
<p>for example, if the absolute fastest thing is 5x the memory usage of the next one but only 1% faster, that doesn't sound worth it to me</p>



<a name="453332417"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453332417" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453332417">(Jul 23 2024 at 05:43)</a>:</h4>
<p>Yeah, I think the two main choices are <code>n</code> or basically constant.</p>



<a name="453332517"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453332517" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453332517">(Jul 23 2024 at 05:43)</a>:</h4>
<p>so I'd say constant memory usage is not a requirement, but less memory usage is separately valuable from faster overall perf, although faster overall perf is the most valuable</p>



<a name="453332756"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453332756" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453332756">(Jul 23 2024 at 05:44)</a>:</h4>
<p>also I think the default sorting algorithm will most often be used to sort things of under a thousand elements</p>



<a name="453332758"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453332758" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453332758">(Jul 23 2024 at 05:44)</a>:</h4>
<p>Using <code>n</code> is definitely faster. Though most cases will be similar in performance, in the bad cases for using basically constant memory, it can be 25% slower (though this is also 25% slower of significantly faster than timsort which most languages still use).</p>



<a name="453332882"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453332882" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453332882">(Jul 23 2024 at 05:45)</a>:</h4>
<p>what's the coefficient here? like n times how many bytes?</p>



<a name="453332941"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453332941" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453332941">(Jul 23 2024 at 05:46)</a>:</h4>
<p>Sorry, <code>n</code> elements. So 2 whole copies of the array.</p>



<a name="453333058"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453333058" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453333058">(Jul 23 2024 at 05:47)</a>:</h4>
<p>As a note, no matter which algorithm we use (within the bounds of modern fast algorithms), my gut feeling is that the cost of the cmp function, copy function (ie not giving zig element size and alignment at compile time), and and dealing with refcounts will be the biggest slowdowns. Those are all things we may need to specialize over to get perf.</p>



<a name="453333208"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453333208" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453333208">(Jul 23 2024 at 05:49)</a>:</h4>
<p>when we say the one that doubles the elements is faster, is that in a microbenchmark?</p>



<a name="453333313"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453333313" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453333313">(Jul 23 2024 at 05:50)</a>:</h4>
<p>or in real programs where the cost of cache misses due to evictions from that much memory usage is factored in</p>



<a name="453333579"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453333579" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453333579">(Jul 23 2024 at 05:53)</a>:</h4>
<p>I would guess in practice given most languages use sorting algorithms that duplicate the array or at least require a buffer of approximately half the length of the array.</p>



<a name="453333874"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453333874" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453333874">(Jul 23 2024 at 05:56)</a>:</h4>
<p>That said, it may be a case that most arrays that get sorted easily fit at least L3 cache.</p>



<a name="453333881"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453333881" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453333881">(Jul 23 2024 at 05:57)</a>:</h4>
<p>So the buffer as little cost.</p>



<a name="453333898"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453333898" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453333898">(Jul 23 2024 at 05:57)</a>:</h4>
<p>Also, the buffers are used linearly, so cache locality is still good even with the large buffer.</p>



<a name="453334018"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453334018" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> GordonBGood <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453334018">(Jul 23 2024 at 05:58)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281383">Richard Feldman</span> <a href="#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/453333313">said</a>:</p>
<blockquote>
<p>or in real programs where the cost of cache misses due to evictions from that much memory usage is factored in</p>
</blockquote>
<p>I think that's as in "real" programs, as most algorithms are using some sort of merge under the covers which is feeding from two sources and writing the merged result to another location; since associative caches use multi-way association, this is well within their capability and there will just be jumps when jumping between different merge streams, which will quickly get the cache up to speed.  In the above merge sort benchmark, the main cost is the cost of comparisons at about 24 CPU clock cycles per, and this slow because the sorting data is seen as random and therefore unpredictable...</p>



<a name="453334069"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453334069" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> GordonBGood <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453334069">(Jul 23 2024 at 05:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="343810">Brendan Hansknecht</span> <a href="#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/453333898">said</a>:</p>
<blockquote>
<p>Also, the buffers are used linearly, so cache locality is still good even with the large buffer.</p>
</blockquote>
<p>As <span class="user-mention" data-user-id="343810">@Brendan Hansknecht</span>  says...</p>



<a name="453334228"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453334228" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453334228">(Jul 23 2024 at 06:00)</a>:</h4>
<p>yeah, given all that, it sounds like the fastest one is worth the extra memory usage!</p>



<a name="453336611"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453336611" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453336611">(Jul 23 2024 at 06:24)</a>:</h4>
<p>So in that case that leaves 3 main options:</p>
<ol>
<li>fluxsort</li>
<li>glidesort (with full n element memory)</li>
<li>powersort</li>
</ol>
<hr>
<p>Here are the rough pluses and minuses in my opinion:</p>
<p>fluxsort:</p>
<div class="codehilite"><pre><span></span><code>+ To my understanding should be the fastest in the most cases on most hardware
+ Can take advantage of patterns for more perf
+ Tuned specifically with the idea of passing in a comparison function
- Does more low level optimizations that while simple to understand may not port properly
</code></pre></div>
<p>glidesort:</p>
<div class="codehilite"><pre><span></span><code>~ might be the fastest in the future (depends very heavily on hardware, has optimizations for very new hardware)
+ can take advantage of patterns for more perf
- definitely the most complex to port (sorry rust)
- has some extra tradeoffs made due to panic safety (but we technically don&#39;t need to port those)
</code></pre></div>
<p>powersort:</p>
<div class="codehilite"><pre><span></span><code>+ Definitely the simplest
+ Vetted by python adopting it
- Likely the slowest here, but still very fast overall. Worst cases:
    1. Lots of equivalent elements (like `rand %100` or enums).
    2. Patterns that are more complex than many repeated runs.
- More comparisons on average
</code></pre></div>



<a name="453337704"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453337704" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453337704">(Jul 23 2024 at 06:32)</a>:</h4>
<p>Note, when I talk about powersort being the slowest in many cases, I would expect it to be within a lets say 3%. In the specific edge cases like lots of equality, it can be a huge diff potentially 2x.</p>



<a name="453337902"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453337902" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453337902">(Jul 23 2024 at 06:34)</a>:</h4>
<p>And definitely take all of this with a solid grain of salt. This is from some local benchmarks of existing code, but mostly from trusting existing benchmarks, reading papers on algorithm implementations and tradeoffs, and intuition.</p>
<p>The only way to truly know these tradeoffs would be to implement them all with the constraints of roc.</p>



<a name="453338276"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453338276" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Luke Boswell <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453338276">(Jul 23 2024 at 06:37)</a>:</h4>
<p>I'm guessing it's a fair bit of work to implement these. Like you wouldn't just implement a couple and have a flag?</p>



<a name="453338318"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453338318" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Luke Boswell <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453338318">(Jul 23 2024 at 06:37)</a>:</h4>
<p>What about implementing the simple one first, and then potentially exploring the more experimental glidesort?</p>



<a name="453338741"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453338741" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453338741">(Jul 23 2024 at 06:41)</a>:</h4>
<blockquote>
<p>a fair bit of work</p>
</blockquote>
<p>100% in fact the simple one is still pretty complex (if you want it fast and not just a naive port of the algorithm as a whole).</p>



<a name="453341091"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453341091" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453341091">(Jul 23 2024 at 07:00)</a>:</h4>
<p>A note on the glidesort gains, I think they are a double edge sword. To my understanding they are likely what make it slower on middle end, low end, and embedded hardware. Though in 5 years probably will be fine on middle end. It merges in an interleaved manner to take advantage of out of order execution. And multiple memory streams. This is just larger overhead and potential cache conflicts on older/lower resource hardware.</p>
<p>That said, all algorithms use at least 2 way merging to help some with out of order and multiple memory streams.</p>
<p>In fact, the newest paper on power sort, it uses four way merging, but it has too much overhead to gain perf unless you have sentinel values (values that always sort greater than all other values). It uses them to avoid slice/subarray bounds checks. Just puts them at the end of chunks being merged.</p>
<p>Glidesort looks to have managed multi way merging wins, but they are the main reason the perf varies so much by hardware.</p>



<a name="453409916"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453409916" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> GordonBGood <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453409916">(Jul 23 2024 at 12:59)</a>:</h4>
<p><span class="user-mention silent" data-user-id="343810">Brendan Hansknecht</span> <a href="#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/453337902">said</a>:</p>
<blockquote>
<p>and intuition...</p>
</blockquote>
<p>My intuition says try powersort or some slight derivation thereof, and maybe compare it with fluxsort if it isn't too much more complex.  At this stage, nothing is cast in stone and you can always revisit it later, and either of these or even my simple merge sort as per the above is better than the Zig code you have now...</p>



<a name="453414419"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453414419" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453414419">(Jul 23 2024 at 13:18)</a>:</h4>
<p><span class="user-mention silent" data-user-id="343810">Brendan Hansknecht</span> <a href="#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/453341091">said</a>:</p>
<blockquote>
<p>A note on the glidesort gains, I think they are a double edge sword. To my understanding they are likely what make it slower on middle end, low end, and embedded hardware. Though in 5 years probably will be fine on middle end. It merges in an interleaved manner to take advantage of out of order execution. And multiple memory streams. This is just larger overhead and potential cache conflicts on older/lower resource hardware.</p>
</blockquote>
<p>I don't think that's a big downside</p>



<a name="453414826"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453414826" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453414826">(Jul 23 2024 at 13:20)</a>:</h4>
<p>it's hard to imagine a few percentage points of sorting perf being a major issue for embedded use cases; I wouldn't expect sorting to be a significant percentage of what they spend their time on regardless</p>



<a name="453415080"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453415080" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453415080">(Jul 23 2024 at 13:22)</a>:</h4>
<p>and definitely optimizing for where hardware is going seems like a better idea than optimizing for where it is today, when there aren't yet any big Roc deployments that could actually take advantage of that on today's hardware anyway <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span></p>



<a name="453415477"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453415477" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453415477">(Jul 23 2024 at 13:24)</a>:</h4>
<p>I do like that fluxsort is tuned for accepting a comparison function though; I definitely expect that to come up a lot!</p>



<a name="453415793"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453415793" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453415793">(Jul 23 2024 at 13:26)</a>:</h4>
<p>based on that, fluxsort seems like the frontrunner to me unless there's some really significant implementation advantage to powersort being simpler, but it sounds like the simplicity of the algorithm itself is a relatively minor percentage of the overall project regardless, yeah?</p>



<a name="453433789"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453433789" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453433789">(Jul 23 2024 at 14:51)</a>:</h4>
<p>Yeah, it will be curious to see once we have one of these in zig, what the real overhead ends up being.</p>



<a name="453434471"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453434471" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453434471">(Jul 23 2024 at 14:53)</a>:</h4>
<p>I don't think we could write raw roc as optimally, but the overhead of closures in zig and lack of mono could hit hard.</p>



<a name="453434926"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453434926" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453434926">(Jul 23 2024 at 14:55)</a>:</h4>
<p>Long term will certainly try multiple configs.</p>



<a name="453445777"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453445777" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453445777">(Jul 23 2024 at 15:28)</a>:</h4>
<p>That said, at least currently, we don't have anything interesting in roc to benchmark it against. So we'll have to think about what benchmarks we actually care about when it comes to perf here. What are our "realworld" enough sorting benchmarks.</p>



<a name="453574960"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453574960" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> GordonBGood <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453574960">(Jul 24 2024 at 02:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="343810">Brendan Hansknecht</span> <a href="#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/453445777">said</a>:</p>
<blockquote>
<p>What are our "realworld" enough sorting benchmarks.</p>
</blockquote>
<p>Also as in Zig versus in "native" Roc...</p>
<p>There is also that it would be really nice to have the <code>Sort</code> Ability in place rather than having to depend on whatever comparable behavior defaults there are for whatever Type one wants to use as a sorting key...</p>



<a name="453576899"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453576899" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453576899">(Jul 24 2024 at 02:51)</a>:</h4>
<p>I don't quite follow that statement, can you elaborate?</p>
<p>The current plan for <code>Sort</code> is that it is a mapping from 2 inputs of the same type to <code>[EQ, LT, GT]</code>.</p>



<a name="453582831"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453582831" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> GordonBGood <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453582831">(Jul 24 2024 at 03:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="343810">Brendan Hansknecht</span> <a href="#narrow/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F/near/453576899">said</a>:</p>
<blockquote>
<p>I don't quite follow that statement, can you elaborate?</p>
</blockquote>
<p>I mean that in order to implement a sort function, the contents need to be known to be comparable unless everything is automatically comparable (unless it contains a function), so tuples, records, Str's (???), Char's, and custom tagged union types are all comparable by these criteria (tuples, record's, and union's not containing a function); if they aren't comparable, then one could use the <code>sortWith</code> or <code>sortBy</code> variation, but the usual protocol is to apply the constraint to the type variable as in Elm (<code>sort : List comparable -&gt; List comparable</code>) or with an Ability (<code>sort : List a -&gt; List a where a implements Sort</code>)...</p>



<a name="453584345"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/Obvious%20inefficiencies%20in%20merge%20sort%20algorithm%3F/near/453584345" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/Obvious.20inefficiencies.20in.20merge.20sort.20algorithm.3F.html#453584345">(Jul 24 2024 at 03:33)</a>:</h4>
<p>Ah yeah, sort will be auto derive, but not for strings, functions, opaques. So most types will just have sort.</p>
<p>We will expose <code>sort : List a -&gt; List a where a implements Sort</code>, but it will just wrap <code>List.sortWith</code>. <code>Sort</code> ability will be used to generate the comparison functions.</p>
<p>We eventually may also want to add raw primitive sorts that automatically get dispatched to by <code>List.sort</code>, but that will depend on the gains it sees. If we are lucky, llvm might be smart enough to optimize sortWith on primitives and inline the indirect call to the constant compare function.</p>



<hr><p>Last updated: Nov 01 2025 at 12:13 UTC</p>
</html>