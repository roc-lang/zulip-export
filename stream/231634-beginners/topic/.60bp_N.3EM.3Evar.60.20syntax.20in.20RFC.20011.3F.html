<html>
<head><meta charset="utf-8"><title>`bp_N&gt;M&gt;var` syntax in RFC 011? · beginners · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/index.html">beginners</a></h2>
<h3>Topic: <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html">`bp_N&gt;M&gt;var` syntax in RFC 011?</a></h3>

<hr>

<base href="https://roc.zulipchat.com">

<head><link href="https://roc-lang.github.io/zulip-export/style.css" rel="stylesheet"></head>

<a name="491866847"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/491866847" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#491866847">(Jan 04 2025 at 10:50)</a>:</h4>
<p>Hi <span class="user-mention" data-user-id="454654">@Ayaz Hafiz</span>. Could you explain what <code>N</code>, <code>M</code>, and <code>var</code> are in <code>bp_N&gt;M&gt;var</code> syntax that you use in <a href="https://github.com/roc-lang/rfcs/blob/main/0011-union-refinement.md">RFC 011</a>?</p>



<a name="491867735"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/491867735" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#491867735">(Jan 04 2025 at 11:05)</a>:</h4>
<p>As far as I can see there are no examples of <code>N</code> and <code>M</code> being different numbers in the examples, so it's hard to tell why you have two numbers <code>N</code> and <code>M</code> and when they can be different.</p>



<a name="491890771"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/491890771" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#491890771">(Jan 04 2025 at 16:53)</a>:</h4>
<p>yes, apologies that this is a bit confusing. the idea is to distinguish between the specific branch being targeted, and the pattern within the branch that is being constrained. <code>bp_N</code> refers to the Nth branch being targeted. <code>M&gt;var</code> refers to the branch pattern that should be matched.</p>



<a name="491891108"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/491891108" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#491891108">(Jan 04 2025 at 16:59)</a>:</h4>
<p>For example, take the case</p>
<div class="codehilite"><pre><span></span><code>x: [A [B, C], D [E]]

when x is
  A B -&gt; D E
  D E -&gt; A C
  A other -&gt; A other
</code></pre></div>
<p>Our goal is constrain <code>other</code> down to <code>[C]</code>, so we are looking at <code>bp_3</code>. The way we want to constrain is by eliminating whatever is in its type that appears in previous branches. What could appear in other branches is given by the pattern <code>A other</code> that occurs in the second branch, so call this <code>3&gt;other</code> (the pattern path in branch 3 that leads to <code>other</code>). Now <code>other</code> = <code>[B, C] - bp_1&gt;(3&gt;other) - bp_2&gt;(3&gt;other)</code>. <code>bp_1&gt;(3&gt;other)</code> is <code>[B]</code>, because that's where <code>other</code> would match the pattern. <code>bp_2&gt;(3&gt;other)</code> is <code>[]</code>, because the third branch does not match the second. So we send up with <code>other = [B, C] - [B] - [] = [C]</code>.</p>



<a name="491893995"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/491893995" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#491893995">(Jan 04 2025 at 17:44)</a>:</h4>
<p>Thanks, it makes more sense to me now.</p>
<p>Have you considered this alternative (or maybe it's the same as what you describe?) approach? When unifying the pattern types with the scrutinee type, you copy the scrutinee type, updating it with the fully covered variants (non-variant types are copied as-is). So in your example, when you check the second branch's pattern, you consider the scrutinee type not as <code>[A [B, C], D [E]]</code> but as <code>[A [C], D [E]]</code>. Then in the third branch, you consider it as <code>[A [C]]</code>.</p>
<p>Is this the same as what you describe?</p>



<a name="491894265"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/491894265" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#491894265">(Jan 04 2025 at 17:48)</a>:</h4>
<p>The copying should share the unification variables, but copy everything else, updating variants based on fully covered variants in the previous branches.</p>



<a name="491894787"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/491894787" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#491894787">(Jan 04 2025 at 17:56)</a>:</h4>
<p>I wonder if this approach is a bit too eager, because you do refinements before generating all of the unification constraints.</p>



<a name="491896560"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/491896560" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#491896560">(Jan 04 2025 at 18:16)</a>:</h4>
<p>Do you know if there's prior work on this? I can't find anything.</p>



<a name="491896740"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/491896740" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#491896740">(Jan 04 2025 at 18:19)</a>:</h4>
<p>yes, i think it is equivalent. you probably need to solve at least the constraints in the body of all prior branches before updating the scrutinee. This still might be too eager, but I think the only other alternative is some fixpoint analysis (maybe there's a simpler method)</p>



<a name="491896809"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/491896809" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#491896809">(Jan 04 2025 at 18:20)</a>:</h4>
<p>i think you have to break unification variables when you update the scrutinee, but yeah copy the unification vars up to that</p>



<a name="491896894"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/491896894" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#491896894">(Jan 04 2025 at 18:21)</a>:</h4>
<p>i know that this is quite simple in a typesystem with subtyping - i don't have any papers in mind off the top of my head but kotlin, typescript, etc have done this</p>



<a name="491897111"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/491897111" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#491897111">(Jan 04 2025 at 18:24)</a>:</h4>
<p>Why is it simpler with subtyping?</p>



<a name="491897624"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/491897624" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#491897624">(Jan 04 2025 at 18:32)</a>:</h4>
<p>you can model this as intersections which are often part of the basic operations of the type system, so you don't need to materialize the types partway</p>



<a name="491949028"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/491949028" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#491949028">(Jan 05 2025 at 08:39)</a>:</h4>
<p>Have you considered handling cases where the refinement cannot be done based on the scrutinee type? E.g.</p>
<div class="codehilite"><pre><span></span><code>type Err:
    Err([A, B, C])
    Ok(I32)

match x:
    Err(&#39;A): ...
    Err(other): ...     # other : [B, C]
    Ok(x): ...
</code></pre></div>
<p>Here <code>[A, B, C]</code> is not a type argument to the scrutinee (<code>x</code>) type, so it can't be refined.</p>



<a name="491971834"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/491971834" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#491971834">(Jan 05 2025 at 14:37)</a>:</h4>
<p>I ended up implementing this without updating the scrutinee type as described above: <a href="https://github.com/fir-lang/fir/pull/39">https://github.com/fir-lang/fir/pull/39</a>.</p>
<p>What I did was: for a branch, first unify the pattern type with the scrutinee type as usual, but before type checking the right-hand side, refine binders in the pattern based on coverage information.</p>
<p>Here are some examples of what this can handle: <a href="https://github.com/fir-lang/fir/blob/main/tests/Rows3.fir">https://github.com/fir-lang/fir/blob/main/tests/Rows3.fir</a></p>



<a name="491979494"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/491979494" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#491979494">(Jan 05 2025 at 16:26)</a>:</h4>
<p>ah very nice. i guess the coverage of the pattern indeed gives you all you need</p>



<a name="492470469"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/492470469" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#492470469">(Jan 08 2025 at 10:00)</a>:</h4>
<p>FYI you may want to review <a href="https://langdev.stackexchange.com/questions/4239/flow-sensitive-type-refinement-of-polymorphic-variants">https://langdev.stackexchange.com/questions/4239/flow-sensitive-type-refinement-of-polymorphic-variants</a> before implementing this.</p>



<a name="492513785"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/492513785" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#492513785">(Jan 08 2025 at 14:17)</a>:</h4>
<p>wow that is the best StackOverflow answer to an advanced question I've ever seen in my entire life <span aria-label="astonished" class="emoji emoji-1f632" role="img" title="astonished">:astonished:</span></p>



<a name="492513837"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/492513837" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#492513837">(Jan 08 2025 at 14:17)</a>:</h4>
<p>Alexis King is awesome</p>



<a name="492516194"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/492516194" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#492516194">(Jan 08 2025 at 14:29)</a>:</h4>
<p>I didn't know about <a href="http://langdev.stackexchange.com">langdev.stackexchange.com</a> , that's useful</p>



<a name="494752228"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494752228" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494752228">(Jan 20 2025 at 08:58)</a>:</h4>
<p>I discovered an interesting case, where refining a pattern binding causes a type error. Without refinement there's no type error.</p>
<div class="codehilite"><pre><span></span><code>test(x: [A, ..r]): [A, ..r]
     match x:
         ~A: ~A
         other: other
</code></pre></div>
<p>Here the RHS type of the first branch is <code>[A, ..x1]</code> where <code>x1</code> is a fresh unification variable.</p>
<p>In the second branch, normally the type would be <code>[A, ..r]</code> and RHS types of these two branches would unify.</p>
<p>But with refinement, we get <code>[..r]</code>, which doesn't unify with <code>[A, ..x1]</code> (type of first RHS) as <code>r</code> is a rigid type variable (coming from the type signature), not a unification variable.</p>
<p>Not sure how to approach this..</p>
<p><span class="user-mention" data-user-id="454654">@Ayaz Hafiz</span> have you considered this case before?</p>



<a name="494765101"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494765101" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494765101">(Jan 20 2025 at 09:55)</a>:</h4>
<p>I feel like this is where "absent" fields in variant and record types will come into play.</p>
<p>E.g. we refine <code>other</code> as <code>[..r] \ A</code> ("a record with rows r, not including label A")</p>
<p>Then allow unification <code>[..r] \ A ~ [A, ..x1]</code> (which unifies <code>r ~ x1</code>).</p>



<a name="494817451"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494817451" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494817451">(Jan 20 2025 at 13:58)</a>:</h4>
<p>yes.. one approach is to avoid distinguishing rigid and unification variables until after generalization</p>



<a name="494817650"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494817650" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494817650">(Jan 20 2025 at 13:59)</a>:</h4>
<p>i assume your definition of rigid vs unification variable is rigid can be instantiated, unification can be instantiated with at most one type until generalization?</p>



<a name="494817900"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494817900" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494817900">(Jan 20 2025 at 14:00)</a>:</h4>
<p>if you do this, then the type is <code>x: [A, ..r'] -&gt; [A, ..r']</code> for fresh unification var <code>r'</code> and I believe it solves correctly. Then after solving the body of <code>test</code>, generalize <code>r'</code> to <code>r</code></p>



<a name="494818738"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494818738" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494818738">(Jan 20 2025 at 14:03)</a>:</h4>
<p>One thing to be careful about with this approach though is whether you would like to support polymorphic recursion. If polymorphic recursion is permitted, then I think you must take the set-theoretic approach you describe</p>



<a name="494818819"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494818819" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494818819">(Jan 20 2025 at 14:04)</a>:</h4>
<p>imo set theoretic models are better in general, just much harder to implement</p>



<a name="494823206"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494823206" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494823206">(Jan 20 2025 at 14:22)</a>:</h4>
<p>My definition of rigid type variable is when you have a type parameter in a type signature, that type variable becomes "rigid" when checking the body of the function, i.e. it only unifies with itself.</p>
<p>So in my example <code>r</code> is rigid: <code>test(x: [A, ..r]): [A, ..r] = ...</code>. In this identity function <code>t</code> is rigid: <code>id(x: t): t = x</code></p>



<a name="494823696"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494823696" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494823696">(Jan 20 2025 at 14:24)</a>:</h4>
<p>I don't care too much about poly. recursion.. but I'm curious what's the difference between the set theoretic approach from non- set theoretic one?</p>



<a name="494825042"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494825042" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494825042">(Jan 20 2025 at 14:30)</a>:</h4>
<p>I think you are right that if I make <code>r</code> a unification variable and then generalize at the end, I would get the same type as in the signature so it would work.</p>



<a name="494829215"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494829215" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494829215">(Jan 20 2025 at 14:47)</a>:</h4>
<blockquote>
<p>Then allow unification <code>[..r] \ A ~ [A, ..x1]</code> (which unifies <code>r ~ x1</code>).</p>
</blockquote>
<p>I'm actually not sure if this is possible. The type <code>[..r] \ A</code> doesn't have any unification variables (<code>r</code> is a rigid variable) so not sure how to make it equal to <code>[..r]</code> again.</p>



<a name="494836117"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494836117" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494836117">(Jan 20 2025 at 15:17)</a>:</h4>
<p>I see - yes then i think making it a unification var would work, as long as you preserve the link (eg all instances of <code>r</code> become a unification var pointing at the same thing)</p>



<a name="494836569"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494836569" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494836569">(Jan 20 2025 at 15:19)</a>:</h4>
<p>W.r.t set theoretic types, i mean treating types as sets of values rather than the typical type-theoretic approach - the type-theoretic approach makes unification easy but distinguishing based on values harder. For most cases the difference is not so severe, like in this case, but with intersections, negations, etc it can make a big difference in my experience. I think Castagna is the leading expert on this topic, <a href="https://www.irif.fr/~gc/papers/set-theoretic-types-2022.pdf">https://www.irif.fr/~gc/papers/set-theoretic-types-2022.pdf</a> is a good paper of his i like</p>



<a name="494837713"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494837713" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bullard <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494837713">(Jan 20 2025 at 15:24)</a>:</h4>
<p>I’m interested in how the Elixir project of implementing set-theoretic types , especially for gradual typing, goes.</p>



<a name="494838613"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494838613" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bullard <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494838613">(Jan 20 2025 at 15:28)</a>:</h4>
<p>Giuseppe is the advisor to the project, so I'm pretty sure this is the exact paper that is being implemented here</p>



<a name="494838749"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494838749" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bullard <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494838749">(Jan 20 2025 at 15:28)</a>:</h4>
<p>Here's a good talk from the recent ElixirConf about what they are doing: <a href="https://www.youtube.com/watch?v=Bf7dp0Yj8Po">https://www.youtube.com/watch?v=Bf7dp0Yj8Po</a></p>
<div class="youtube-video message_inline_image"><a data-id="Bf7dp0Yj8Po" href="https://www.youtube.com/watch?v=Bf7dp0Yj8Po"><img src="https://uploads.zulipusercontent.net/fa5db396252c7adba557c26023f5e1d29b17fb91/68747470733a2f2f692e7974696d672e636f6d2f76692f426637647030596a38506f2f64656661756c742e6a7067"></a></div>



<a name="494839366"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494839366" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494839366">(Jan 20 2025 at 15:31)</a>:</h4>
<p>I just found another repro of the issue that doesn't use refinements:</p>
<div class="codehilite"><pre><span></span><code>test(x: [..errs]): [E1, ..errs]
    if Bool.True:
        x
    else:
        ~E1
</code></pre></div>
<p>This can't be type checked if we consider type of <code>x</code> as <code>[..errs]</code> where <code>errs</code> is rigid (i.e. can't be unified with anything else).</p>
<p>So I think it's clear that I need something like what <span class="user-mention" data-user-id="454654">@Ayaz Hafiz</span> suggested.</p>



<a name="494908489"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494908489" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494908489">(Jan 20 2025 at 20:37)</a>:</h4>
<p>Thinking about this more, I don't think creating unification variables for type variables in the signature and then generalizing and compring the generalized type with the signature can type check this.</p>
<p>Here's how the type checking goes:</p>
<ul>
<li>
<p>Create fresh unification variable for <code>errs</code>: <code>errs1</code>.</p>
</li>
<li>
<p>Bind <code>x : [..errs1]</code>.</p>
</li>
<li>
<p>Unify both branches of <code>if</code>:</p>
<ul>
<li>Branch 1: <code>[..errs1]</code></li>
<li>Branch 2: <code>[E1, ..a]</code> (<code>a</code> is fresh)</li>
</ul>
</li>
<li>
<p>Unification links <code>errs1</code> to <code>[E1, ..errs2]</code> (<code>errs2</code> is fresh) and <code>a</code> to <code>errs2</code>.</p>
</li>
<li>
<p>So the return type becomes <code>[E1, ..errs2]</code>, and the argument is <code>[..errs1]</code>, which was linked to <code>[E1, ..errs2]</code>.</p>
</li>
<li>
<p>So when generalized we get <code>Fn([E1, ..errs]): [E1, errs]</code>. That's the inferred type of this function.</p>
</li>
</ul>
<p>I think this function's type signature is not right.</p>



<a name="494911367"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494911367" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494911367">(Jan 20 2025 at 20:53)</a>:</h4>
<p>Unfortunately this takes us back to my original question with the refinement.</p>
<div class="codehilite"><pre><span></span><code>test(x: [A, ..r]): [A, ..r]
     match x:
         ~A: ~A
         other: other
</code></pre></div>
<p>Here if I refine type of <code>other</code> as <code>[..r]</code>, I can't unify it with <code>[A, ..r2]</code> and get the argument or return type in the signature.</p>



<a name="494913550"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494913550" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494913550">(Jan 20 2025 at 21:08)</a>:</h4>
<p>This seems relevant: <a href="https://drops.dagstuhl.de/storage/00lipics/lipics-vol263-ecoop2023/LIPIcs.ECOOP.2023.17/LIPIcs.ECOOP.2023.17.pdf">https://drops.dagstuhl.de/storage/00lipics/lipics-vol263-ecoop2023/LIPIcs.ECOOP.2023.17/LIPIcs.ECOOP.2023.17.pdf</a></p>



<a name="494916967"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494916967" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494916967">(Jan 20 2025 at 21:33)</a>:</h4>
<p>I think we just accept this program as ill-typed. If we don't want refinement we can use the argument:</p>
<div class="codehilite"><pre><span></span><code>test(x: [A, ..r]): [A, ..r]
     match x:
         ~A: ~A
         _: x
</code></pre></div>
<p>which type checks.</p>



<a name="494918000"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494918000" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494918000">(Jan 20 2025 at 21:40)</a>:</h4>
<p>yes i think that program has to be ill-typed</p>



<a name="494918056"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494918056" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494918056">(Jan 20 2025 at 21:41)</a>:</h4>
<p>to do anything else you need something other than unification (ie distinguish the input parameter typevar from the output value var)</p>



<a name="494918191"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494918191" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494918191">(Jan 20 2025 at 21:42)</a>:</h4>
<p>i think it is sufficient to check whether any user-annotated rigid variables after generalization can be unified (without instantiation) to the inferred generalized types</p>



<a name="494918203"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494918203" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494918203">(Jan 20 2025 at 21:42)</a>:</h4>
<p>there is probably a simpler way though</p>



<a name="494918789"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494918789" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494918789">(Jan 20 2025 at 21:47)</a>:</h4>
<p>Now my problem with this system is that it seems a bit counterintuitive. I implemented it, wrote tests, wrote a blog post about it, but I still find cases that I expect to work but doesn't, then debug it for a few hours, only to realize that it's working as expected and my program should be tweaked. Users will have the same experience, or worse depending on how well they understand rows.</p>



<a name="494947144"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494947144" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494947144">(Jan 21 2025 at 01:33)</a>:</h4>
<p>yeah</p>



<a name="494947156"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494947156" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494947156">(Jan 21 2025 at 01:33)</a>:</h4>
<p>this is why unification is not ideal for this</p>



<a name="494947261"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494947261" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494947261">(Jan 21 2025 at 01:34)</a>:</h4>
<p>my general take is that subtyping is almost always superior</p>



<a name="494947288"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494947288" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494947288">(Jan 21 2025 at 01:34)</a>:</h4>
<p>especially in the preference of inference</p>



<a name="494947296"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494947296" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494947296">(Jan 21 2025 at 01:34)</a>:</h4>
<p>but it's hard</p>



<a name="494947461"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494947461" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494947461">(Jan 21 2025 at 01:35)</a>:</h4>
<p>undecidability of semi-unification etc etc (but possible in a restricted context)</p>



<a name="494986143"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494986143" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494986143">(Jan 21 2025 at 07:48)</a>:</h4>
<p>If you impolement this in Roc are you going to use rows or subtyping?</p>
<p>I don't want to introduce subtyping in my system because (1) I have no experience in implementing subtyping (2) I also don't have any experience in using subtyping outside of OOP langs so I can't predict the interactions it's going to have with the other features.</p>
<p>For now, I'm thinking maybe I can adjust the user type signatures under the hood to make this work like subtyping. For example, if user has <code>[A, ..r]</code> in argument position, maybe I can replace it with <code>[A, B, ..r]</code> somehow to make the types align.</p>



<a name="494990867"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/494990867" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#494990867">(Jan 21 2025 at 08:18)</a>:</h4>
<p>So far I found two things that users should be aware of and understand:</p>
<ul>
<li>
<p>Variants in return position always need to be polymorphic (with the <code>..r</code> part), otherwise the function becomes unnecessarily strict.</p>
<p>I think OCaml does it right here by hiding the row parameter and instead having syntax like <code>[&gt; ...]</code>. I may do something simliar.</p>
</li>
<li>
<p>You can't add a label to a variant that you take as an argument. So if you want to convert a label <code>A</code> into <code>B</code>, your function type needs to be <code>[A, B, ..r] -&gt; [B, ..r]</code> instead of <code>[A, ..r] -&gt; [B, ..r]</code>.</p>
</li>
</ul>



<a name="495063550"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/495063550" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#495063550">(Jan 21 2025 at 14:24)</a>:</h4>
<p>probably rows but i do think they are the imperfect model for this, for example exactly because the rows leak into userspace and are kind of confusing to users (eg ocaml's <code>[&gt; ...]</code> vs <code>[&lt; ...]</code>)</p>



<a name="495064934"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/495064934" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#495064934">(Jan 21 2025 at 14:29)</a>:</h4>
<blockquote>
<ul>
<li>You can't add a label to a variant that you take as an argument. So if you want to convert a label <code>A</code> into <code>B</code>, your function type needs to be <code>[A, B, ..r] -&gt; [B, ..r]</code> instead of <code>[A, ..r] -&gt; [B, ..r]</code>.</li>
</ul>
</blockquote>
<p>Sorry, i think i missed something - is there a reason this doesn't work? Or are there other patterns you are referring to that don't work with your model</p>
<div class="codehilite"><pre><span></span><code>test(x: [A, ..r]): [B, ..r]
  match x:
    ~A: ~B
    other: other
</code></pre></div>



<a name="495065187"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/495065187" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#495065187">(Jan 21 2025 at 14:29)</a>:</h4>
<p><span class="user-mention silent" data-user-id="454654">Ayaz Hafiz</span> <a href="#narrow/channel/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F/near/495063550">said</a>:</p>
<blockquote>
<p>probably rows but i do think they are the imperfect model for this, for example exactly because the rows leak into userspace and are kind of confusing to users (eg ocaml's <code>[&gt; ...]</code> vs <code>[&lt; ...]</code>)</p>
</blockquote>
<p>Yeah, but subtyping exposes users to covariance which is also confusing.. I'm also not sure if subtyping based approaches can be as flexible, as upcasting means losing information.</p>



<a name="495065447"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/495065447" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#495065447">(Jan 21 2025 at 14:30)</a>:</h4>
<p>yeah i agree</p>



<a name="495065721"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/495065721" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#495065721">(Jan 21 2025 at 14:31)</a>:</h4>
<p>all these models are kind of confusing haha. this is me coming from the perspective of ocaml variants and roc tags (esp. polymorphic versions) seeming to be much more confusing than any typescript types in the common case for people i've talked to about it</p>



<a name="495067540"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/495067540" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#495067540">(Jan 21 2025 at 14:37)</a>:</h4>
<blockquote>
<p>Sorry, i think i missed something - is there a reason this doesn't work?</p>
</blockquote>
<p>The problem is the return types of branches don't unify:</p>
<ul>
<li>First branch: <code>[B, ..x1]</code> (x1 is fresh)</li>
<li>Second branch: <code>[..r]</code> (r is from the type signature) (note that this type doesn't have <code>A</code> as I "refined" it)</li>
</ul>
<p>These two don't unify because you can't unify <code>r</code> with anything as it's coming from the type signature (I call this "rigid type variable"), so you can't add <code>B</code> to this record.</p>
<p>Am I doing it wrong?</p>



<a name="495068501"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/495068501" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#495068501">(Jan 21 2025 at 14:40)</a>:</h4>
<p>ah i see, and you found that instantiation doesn't work</p>



<a name="495068554"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/495068554" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#495068554">(Jan 21 2025 at 14:40)</a>:</h4>
<p>yeah that is unfortunate</p>



<a name="495073409"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/495073409" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> osa1 <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#495073409">(Jan 21 2025 at 14:54)</a>:</h4>
<p><span class="user-mention silent" data-user-id="454654">Ayaz Hafiz</span> <a href="#narrow/channel/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F/near/495068501">said</a>:</p>
<blockquote>
<p>ah i see, and you found that instantiation doesn't work</p>
</blockquote>
<p>To be clear it works, but it infers <code>[A, B, ..r] -&gt; [B, ..r]</code> instead of <code>[A, ..r] -&gt; [B, ..r]</code>. Which is fine (I think the types are identical in terms of how you would use them), but intuitively not what one might expect.</p>
<p>How the type checking would go with instantiation:</p>
<ul>
<li>bind <code>x</code> to <code>[A, ..x1]</code> where the type is from the signature but type parameter <code>r</code> is instantiated as <code>x1</code>.</li>
<li>in the first branch, unify <code>[A, ..x1]</code> with type of the pattern which is <code>[A, ..x2]</code>, so that equates <code>x1</code> and <code>x2</code>.</li>
<li>in the rhs of the first branch, return type is <code>[B, ..x3]</code>.</li>
<li>in the second branch, unify type of <code>other</code> which is <code>x4</code> (fresh) with type of <code>x</code> so that gives us <code>x4 ~ [A, ..x1]</code>, and then refine it as <code>[..x1]</code> based on coverage of the previous branches.</li>
<li>in the rhs of the second brnach, return type is <code>[..x1]</code>.</li>
<li>unify return types: <code>[..x1] ~ [B, ..x3]</code>, which unifies <code>x1</code> with rows of <code>[B, ..x3]</code>.</li>
</ul>
<p>So the type before generalization becomes <code>[A, B, ..x3] -&gt; [B, ..x3]</code>.</p>



<a name="495085655"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/231634-beginners/topic/%60bp_N%3EM%3Evar%60%20syntax%20in%20RFC%20011%3F/near/495085655" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/231634-beginners/topic/.60bp_N.3EM.3Evar.60.20syntax.20in.20RFC.20011.3F.html#495085655">(Jan 21 2025 at 15:41)</a>:</h4>
<p>yeah that's tough</p>



<hr><p>Last updated: Nov 01 2025 at 12:13 UTC</p>
</html>