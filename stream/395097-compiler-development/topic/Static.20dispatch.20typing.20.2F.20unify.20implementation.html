<html>
<head><meta charset="utf-8"><title>Static dispatch typing / unify implementation · compiler development · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/index.html">compiler development</a></h2>
<h3>Topic: <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html">Static dispatch typing / unify implementation</a></h3>

<hr>

<base href="https://roc.zulipchat.com">

<head><link href="https://roc-lang.github.io/zulip-export/style.css" rel="stylesheet"></head>

<a name="535712100"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535712100" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Warner <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535712100">(Aug 22 2025 at 15:55)</a>:</h4>
<p>What's the strategy for implementing static dispatch in unify? How would this example be handled?</p>
<div class="codehilite"><pre><span></span><code>|x, y| {
  joined = x.map2(y, Pair)
  res = joined.walk([], |acc, el| acc)
  if false { res } else { res.push(0) }
}
</code></pre></div>
<p>It seems that would need to be something like:</p>
<div class="codehilite"><pre><span></span><code>a, b -&gt; c
  where a.map2(b, d): e,
   e.walk(...): c,
   c.push(...): c
</code></pre></div>
<p>(not sure I have the syntax exactly right there?)</p>
<p>Prior to static dispatch that method would have resolved as a much more pronounceable <code>List(a), List(b) -&gt; List(c)</code></p>
<p>Tracking all that in type inference sounds like a headache <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="535714429"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535714429" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535714429">(Aug 22 2025 at 16:07)</a>:</h4>
<p>Tracking it seems manageable but it does not look nice in the LSP type hover...</p>



<a name="535714990"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535714990" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Warner <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535714990">(Aug 22 2025 at 16:10)</a>:</h4>
<p>Err, I guess more specifically - is the intent to implement this via separate constraints? or constrained types? or some kind of row polymorphism types?</p>



<a name="535723518"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535723518" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535723518">(Aug 22 2025 at 17:04)</a>:</h4>
<p>I believe we have not discussed this before <span class="user-mention" data-user-id="281383">@Richard Feldman</span></p>



<a name="535730982"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535730982" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Warner <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535730982">(Aug 22 2025 at 18:00)</a>:</h4>
<p>I ask because I've been tinkering with a type inference system where I tried to do this via row polymorphism... and this is one example where that strategy runs into issues. I think doing it properly that way would require tracking where types are _used_ (i.e. back-links), so that effectively the constraints can be reversed back out of the types. Furthermore, when checking if this function can be applied in a given scenario, we need to follow that whole type graph, making unification much more complicated. So.. probably one of the first two approaches would be best. That, or significant restrictions need to be placed on how much inference we do in this case.</p>



<a name="535733778"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535733778" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Warner <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535733778">(Aug 22 2025 at 18:20)</a>:</h4>
<p>Which is to say, I think some form of global constraint tracking is necessary here</p>



<a name="535733918"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535733918" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Warner <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535733918">(Aug 22 2025 at 18:21)</a>:</h4>
<p>I have a very vague memory of someone here discussing row-polymorphism for implementing static dispatch, but I can't find it, and I could very well be imagining it.</p>



<a name="535745433"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535745433" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535745433">(Aug 22 2025 at 19:40)</a>:</h4>
<p>nah it's basically the same as open records or anonymous tag unions</p>



<a name="535745448"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535745448" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535745448">(Aug 22 2025 at 19:40)</a>:</h4>
<p>I can write it out in more detail tonight</p>



<a name="535745668"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535745668" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Warner <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535745668">(Aug 22 2025 at 19:42)</a>:</h4>
<p>Very interested in how it handles that example!</p>



<a name="535777360"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535777360" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535777360">(Aug 23 2025 at 02:53)</a>:</h4>
<p>yeah so in that example, it would indeed be something similar - so if you put this into the repl:</p>
<div class="codehilite" data-code-language="Ruby"><pre><span></span><code><span class="o">|</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">joined</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">map2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="no">Pair</span><span class="p">)</span>
<span class="w">  </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">joined</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="o">[]</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">acc</span><span class="p">,</span><span class="w"> </span><span class="n">el</span><span class="o">|</span><span class="w"> </span><span class="n">acc</span><span class="p">)</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="kp">false</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">res</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>



<a name="535777483"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535777483" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535777483">(Aug 23 2025 at 02:57)</a>:</h4>
<p>I believe the inferred type would be:</p>
<div class="codehilite" data-code-language="Ruby"><pre><span></span><code><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">res</span>
<span class="w">    </span><span class="n">where</span><span class="w"> </span><span class="o">[</span>
<span class="w">        </span><span class="n">module</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">map2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="no">Pair</span><span class="p">,</span><span class="w"> </span><span class="o">..]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">joined</span><span class="p">,</span>
<span class="w">        </span><span class="n">module</span><span class="p">(</span><span class="n">joined</span><span class="p">)</span><span class="o">.</span><span class="n">walk</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">List</span><span class="p">(</span><span class="n">elem_</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="n">acc</span><span class="p">,</span><span class="w"> </span><span class="n">el_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">acc</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">res</span><span class="p">,</span>
<span class="w">        </span><span class="n">module</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">res</span><span class="p">,</span>
<span class="w">        </span><span class="n">module</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="o">.</span><span class="n">from_digits</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Iter</span><span class="p">(</span><span class="no">U8</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">Result</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="no">BadNumLiteral</span><span class="p">(</span><span class="no">Str</span><span class="p">)),</span>
<span class="w">    </span><span class="o">]</span>
</code></pre></div>



<a name="535777640"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535777640" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535777640">(Aug 23 2025 at 03:01)</a>:</h4>
<p>of course, in practice people will normally annotate top-level functions, at which point the type checker would just verify that the body of the function matches the annotation like normal</p>



<a name="535777663"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535777663" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535777663">(Aug 23 2025 at 03:01)</a>:</h4>
<p>so the only time you'd see big inferred types like that would be if you weren't annotating top-level functions at all, which in turn would likely only be when writing quick scripts anyway</p>



<a name="535777694"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535777694" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535777694">(Aug 23 2025 at 03:02)</a>:</h4>
<p>as far as how this works across modules, yeah it's row types similar to records or anonymous tag unions</p>



<a name="535777719"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535777719" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535777719">(Aug 23 2025 at 03:03)</a>:</h4>
<p>so let's say I write this function (no annotation) and just expose it from my module</p>



<a name="535777745"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535777745" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535777745">(Aug 23 2025 at 03:03)</a>:</h4>
<p>let's say the function's name is <code>join_walk_push</code></p>



<a name="535777767"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535777767" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535777767">(Aug 23 2025 at 03:04)</a>:</h4>
<p>another module could call it like so:</p>
<div class="codehilite" data-code-language="Ruby"><pre><span></span><code><span class="o">|</span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="n">arg2</span><span class="o">|</span><span class="w"> </span><span class="no">FirstModule</span><span class="o">.</span><span class="n">join_walk_push</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="n">arg2</span><span class="p">)</span>
</code></pre></div>



<a name="535777781"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535777781" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535777781">(Aug 23 2025 at 03:04)</a>:</h4>
<p>in that case, the inferred type of that function would of course be the same, because all it's doing is calling a function with that type and returning its answer</p>



<a name="535777807"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535777807" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535777807">(Aug 23 2025 at 03:05)</a>:</h4>
<p>similarly, if the other module were to expose <em>that</em> function, and another module were to call <em>it</em>, that function's type would still be unchanged</p>



<a name="535777917"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535777917" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535777917">(Aug 23 2025 at 03:08)</a>:</h4>
<p>however, if at any point the function gets called with a narrower type, e.g.</p>
<div class="codehilite" data-code-language="Ruby"><pre><span></span><code><span class="o">|</span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="n">arg2</span><span class="o">|</span><span class="w"> </span><span class="no">FirstModule</span><span class="o">.</span><span class="n">join_walk_push</span><span class="p">(</span><span class="o">[].</span><span class="n">concat</span><span class="p">(</span><span class="n">arg1</span><span class="p">),</span><span class="w"> </span><span class="n">arg2</span><span class="p">)</span>
</code></pre></div>
<p>...then the type of <em>that</em> function (but not all the others) would be instantiated (at the call site) and unified to something narrower, in this case (because of the <code>[]</code> being passed for the first arg):</p>
<div class="codehilite" data-code-language="Ruby"><pre><span></span><code><span class="no">List</span><span class="p">(</span><span class="n">elem</span><span class="p">),</span><span class="w"> </span><span class="no">List</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">List</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
<span class="w">    </span><span class="n">where</span><span class="w"> </span><span class="o">[</span>
<span class="w">        </span><span class="n">module</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="o">.</span><span class="n">from_digits</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Iter</span><span class="p">(</span><span class="no">U8</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">Result</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="w"> </span><span class="no">BadNumLiteral</span><span class="p">(</span><span class="no">Str</span><span class="p">)),</span>
<span class="w">    </span><span class="o">]</span>
</code></pre></div>
<p>(assuming <code>List.push</code> exists; otherwise it's a type mismatch - these end up needing to be <code>List</code>s because of <code>x.map2(y, ...)</code> when <code>x</code> is a <code>List</code> means this <code>map2</code> will be <code>List.map2</code> etc.)</p>



<a name="535777960"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535777960" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535777960">(Aug 23 2025 at 03:09)</a>:</h4>
<p>and again, you could export <em>that</em> function from the module, and other modules could import it, and then either re-export it by just calling it and returning the answer (in which case this narrower type would be unchanged), or else narrowing it even further</p>



<a name="535778169"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535778169" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Warner <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535778169">(Aug 23 2025 at 03:15)</a>:</h4>
<p>Ahh ok, so this is a bit more sorted out in my head now</p>



<a name="535778235"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535778235" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Warner <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535778235">(Aug 23 2025 at 03:17)</a>:</h4>
<p>The issue I was running into is, in the row-polymorphism approach, you end up with this type information hanging off of the inferred argument types of the function. Which would be fine on its own - except that, for reasons, I want/need to understand what properties the return value of that function could possibly have - and that would require traversing all the type references _backwards_.</p>



<a name="535778255"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535778255" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535778255">(Aug 23 2025 at 03:18)</a>:</h4>
<p>so the key here is that in order to narrow a type variable in a <code>module</code> (e.g. the <code>x</code> in <code>module(x)</code>), you have to actually pas a specific nominal type</p>



<a name="535778264"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535778264" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535778264">(Aug 23 2025 at 03:18)</a>:</h4>
<p>and as soon as you've passed a specific nominal type, we know what module it came from</p>



<a name="535778295"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535778295" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535778295">(Aug 23 2025 at 03:19)</a>:</h4>
<p>and as soon as we know the module, it's trivial to unify <code>moudle(x).foo : type goes here</code> with the type of that module's exposed <code>foo</code> function (or give an error if that module doesn't expose a <code>foo</code>)</p>



<a name="535778314"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535778314" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Warner <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535778314">(Aug 23 2025 at 03:20)</a>:</h4>
<p>Yep yep</p>



<a name="535778317"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535778317" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535778317">(Aug 23 2025 at 03:20)</a>:</h4>
<p>so basically you can add constraints by calling more methods, and they just accumulate in the inferred type as more <code>module(a).whatever</code>s</p>



<a name="535778320"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535778320" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535778320">(Aug 23 2025 at 03:20)</a>:</h4>
<p>and then you can reduce constraints by providing actual nominal types</p>



<a name="535778329"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535778329" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535778329">(Aug 23 2025 at 03:20)</a>:</h4>
<p>and eventually you end up providing nominal types for everything (or variables stay unbound, e.g. empty list, which is also fine)</p>



<a name="535778340"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535778340" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535778340">(Aug 23 2025 at 03:21)</a>:</h4>
<p>at which point we know all the functions that need to be called, and it all works out! <span aria-label="smiley" class="emoji emoji-1f603" role="img" title="smiley">:smiley:</span></p>



<a name="535778363"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535778363" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Warner <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535778363">(Aug 23 2025 at 03:22)</a>:</h4>
<p>Random observation - when you use static dispatch and let the compiler infer the type, the inferred type ends up pretty closely reflecting the shape of the code in the function, but obviously omitting some details. I wonder if that could be useful somehow... <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="535778819"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535778819" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535778819">(Aug 23 2025 at 03:34)</a>:</h4>
<p>that's interesting!</p>



<a name="535778829"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535778829" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535778829">(Aug 23 2025 at 03:34)</a>:</h4>
<p>I kinda suspect it would be like..."almost but not quite" something we could rely on in the compiler</p>



<a name="535778843"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535778843" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535778843">(Aug 23 2025 at 03:35)</a>:</h4>
<p>like there'd be just enough differences that we couldn't just say "the type is [just go look at this canonical IR node]"</p>



<a name="535779085"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535779085" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Warner <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535779085">(Aug 23 2025 at 03:40)</a>:</h4>
<p>Right, it "looks thru" inlining, for example</p>



<a name="535779102"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535779102" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Warner <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535779102">(Aug 23 2025 at 03:41)</a>:</h4>
<p>I was more thinking of either from the _user_ side, or perhaps the _possible language extension_ side.</p>



<a name="535779212"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Static%20dispatch%20typing%20/%20unify%20implementation/near/535779212" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joshua Warner <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Static.20dispatch.20typing.20.2F.20unify.20implementation.html#535779212">(Aug 23 2025 at 03:44)</a>:</h4>
<p>The analogy that was popping into my head was how some ML frameworks (e.g. pytorch) "compile" functions via bytecode inspection. And vaguely similarly, you can do interesting things with passing Proxy objects to javascript functions and just always return new proxy objects from them - you end up essentially getting a trace of the execution, minus branching and constant evaluation, etc.</p>



<hr><p>Last updated: Nov 01 2025 at 12:13 UTC</p>
</html>