<html>
<head><meta charset="utf-8"><title>Allowing implicit cycles in the type representation · compiler development · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/index.html">compiler development</a></h2>
<h3>Topic: <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html">Allowing implicit cycles in the type representation</a></h3>

<hr>

<base href="https://roc.zulipchat.com">

<head><link href="https://roc-lang.github.io/zulip-export/style.css" rel="stylesheet"></head>

<a name="401631984"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/401631984" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#401631984">(Nov 12 2023 at 18:29)</a>:</h4>
<p>I don't know if this would fix some of our woes with recursive types or not, but I've been thinking about our representation, which tries to convert implicit type cycles into explicit type cycles (ie a transformation from equirecursive to isorecursive types in the literature). Dealing with isorecursive types in printing types/generating code is super useful, but I also wonder if the source of most of our problems is because of that transformation</p>



<a name="401632093"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/401632093" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#401632093">(Nov 12 2023 at 18:31)</a>:</h4>
<p>What we could do instead is go full-in on the implicit cyclic representations. So, we would get rid of any explicit <code>occurs</code> checks, and always unify types when we begin to compare them (this is safe because our checker is non-backtracking), rather than after the point we determine that they are equivalent (as we currently do)</p>



<a name="401632105"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/401632105" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#401632105">(Nov 12 2023 at 18:31)</a>:</h4>
<p>Printing types becomes more annoying, but right now if we miss a recursion point the printer stack overflows anyway</p>



<a name="401632191"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/401632191" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#401632191">(Nov 12 2023 at 18:33)</a>:</h4>
<p>Code-generation of layouts also becomes more difficult, but the layout-interner operates on type variables anyway, so it should automatically cache layouts of the implicit recursion points (though, at that point, we would explicitly need to insert a recursion pointer in the memory layout, so this is a bit tricky)</p>



<a name="401632206"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/401632206" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#401632206">(Nov 12 2023 at 18:33)</a>:</h4>
<p>If this works <a href="#narrow/stream/395097-compiler-development/topic/Recursive.20Types.20with.20List">https://roc.zulipchat.com/#narrow/stream/395097-compiler-development/topic/Recursive.20Types.20with.20List</a> would also trivially work</p>



<a name="401632255"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/401632255" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#401632255">(Nov 12 2023 at 18:34)</a>:</h4>
<p>Might be an interesting thing to try at some point</p>



<a name="401634172"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/401634172" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#401634172">(Nov 12 2023 at 19:08)</a>:</h4>
<p>wouldn't that also speed up type checking if it worked?</p>



<a name="401641301"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/401641301" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#401641301">(Nov 12 2023 at 21:22)</a>:</h4>
<p>possibly yeah</p>



<a name="401641382"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/401641382" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#401641382">(Nov 12 2023 at 21:24)</a>:</h4>
<p>yeah this sounds really interesting</p>



<a name="401642293"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/401642293" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#401642293">(Nov 12 2023 at 21:43)</a>:</h4>
<p>if nothing else, it sounds like a really nice simplification of the type checker</p>



<a name="401642369"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/401642369" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#401642369">(Nov 12 2023 at 21:45)</a>:</h4>
<p>and printing types would get more complex, but that's not a troublesome area of the code base anyway...seems like a great trade to make that part of the code base more complex in order to make the really tricky part simpler</p>



<a name="401643551"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/401643551" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#401643551">(Nov 12 2023 at 22:04)</a>:</h4>
<p>i don’t actually know why there’s a recursive type representation/occurs check in the current impl. is that just a holdover from the initial elm port?</p>



<a name="401643681"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/401643681" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#401643681">(Nov 12 2023 at 22:07)</a>:</h4>
<p>that's definitely where we originally got it! <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span></p>



<a name="401658456"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/401658456" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#401658456">(Nov 13 2023 at 01:14)</a>:</h4>
<p>honestly this sounds to me like a better thing to try next than boxing closures</p>



<a name="401658553"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/401658553" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#401658553">(Nov 13 2023 at 01:15)</a>:</h4>
<p>because it might mean we don't end up needing to do that after all, but even if not—if it works, I suspect it'll improve both the code base and performance anyway, so we'll be glad to have it and can then proceed boxing closures anyway</p>



<a name="401673827"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/401673827" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#401673827">(Nov 13 2023 at 03:03)</a>:</h4>
<p>well, I don't actually know if this works, it's just a thought. And we have a few other problems with lambda sets that are unrelated to recursive types specifically. So I'm not sure - if someone has the opportunity to spike it out, definitely useful though</p>



<a name="403304007"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403304007" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403304007">(Nov 21 2023 at 05:09)</a>:</h4>
<p>I really want to figure out how to make this work. Here's a request for help. Consider we have the following function</p>
<div class="codehilite"><pre><span></span><code>mapper = \l, f -&gt; when l is
  Nil -&gt; Nil
  Cons x xs -&gt; Cons (f x) (mapper xs f)
</code></pre></div>
<p>It's clear that the inferred type for <code>l</code> is <code>&lt;t&gt; = [Nil, Cons a &lt;t&gt;]</code>. Now, the question is, can we find an algorithm that can efficiently "see" that <code>&lt;t&gt;</code> is recursive during or right after inference?</p>
<p>As is it, the unification would proceed as</p>
<div class="codehilite"><pre><span></span><code>l = tvar_0 (tvar = type variable)
l ~ Nil = [Nil]a
l ~ Cons x xs = [Nil, Cons a b]c; xs has type c
mapper xs f =&gt; typeof&lt;xs&gt; = typeof&lt;l&gt; =&gt; c = typeof&lt;l&gt;
=&gt; typeof&lt;l&gt; = [Nil, Cons a b]&lt;typeof l&gt;
</code></pre></div>
<p>But we don't yet explicitly see that &lt;typeof l&gt; is recursive in itself. The obvious solution is to perform an occurs check at this point, but this is not efficient.</p>
<p>Can we do this efficiently?</p>



<a name="403304585"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403304585" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403304585">(Nov 21 2023 at 05:15)</a>:</h4>
<p>some ideas from GPT-4:</p>
<blockquote>
<p>Structure Sharing in Unification: By employing structure sharing in the unification algorithm, you can avoid redundant traversals of type structures. When two type variables unify, they can share the same structure, reducing the need for repeated checks.<br>
   Efficient Occurs Check: Implementing an efficient occurs check can significantly improve performance. This could involve optimizations such as:<br>
       Path Compression: During unification, flatten the structure of type variables to minimize the depth of the tree.<br>
       Tail Recursion Optimization: Make the occurs check tail-recursive if possible, to reduce stack usage.<br>
   Incremental Unification: Instead of performing a full unification pass at every step, you can incrementally update the type information as you traverse the structure. This reduces the overall computational load.<br>
   Caching Results: Cache intermediate results during unification and type checking. If you encounter a type structure you've already processed, you can reuse the cached results instead of recomputing.<br>
   Detecting Recursion Early: Analyze the structure of the function and its parameters to identify potential recursion early in the process. For instance, in your example, the recursive call to mapper within itself is a strong hint of recursive types.<br>
   Graph-based Representations: Representing types as graphs rather than as tree structures can make it easier to detect cycles (indicative of recursion) efficiently.<br>
   Lazy Evaluation: In some cases, using lazy evaluation strategies in your type inference algorithm can defer processing until necessary, reducing immediate computational overhead.</p>
</blockquote>



<a name="403304660"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403304660" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403304660">(Nov 21 2023 at 05:16)</a>:</h4>
<p>"Efficient Occurs Check" - thanks, just make it efficient, good call <span aria-label="stuck out tongue" class="emoji emoji-1f61b" role="img" title="stuck out tongue">:stuck_out_tongue:</span></p>



<a name="403304917"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403304917" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403304917">(Nov 21 2023 at 05:19)</a>:</h4>
<p>hm, here's an idea: can we potentially benefit from knowing that there's a restricted set of places where recursion can validly occur?</p>



<a name="403304994"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403304994" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403304994">(Nov 21 2023 at 05:20)</a>:</h4>
<p>for example, what if we just did an occurs check on the ext var of the tag union at the end there?</p>



<a name="403305014"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403305014" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403305014">(Nov 21 2023 at 05:20)</a>:</h4>
<p>eh I guess it could just as easily be in one of the tags</p>



<a name="403305086"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403305086" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403305086">(Nov 21 2023 at 05:21)</a>:</h4>
<p>yeah that's what we do today</p>



<a name="403305149"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403305149" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403305149">(Nov 21 2023 at 05:22)</a>:</h4>
<p>Im just trying to figure out if there's a better way</p>



<a name="403305191"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403305191" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403305191">(Nov 21 2023 at 05:22)</a>:</h4>
<p>I realized we have to have at least a flag that tells us if a type is recursive, during unification. otherwise there's just no way to reliably generate code that needs to be boxed in certain places</p>



<a name="403305213"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403305213" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403305213">(Nov 21 2023 at 05:23)</a>:</h4>
<p>but figuring out where to place the flag is super hard</p>



<a name="403305233"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403305233" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403305233">(Nov 21 2023 at 05:23)</a>:</h4>
<p>like when to try to detect it you mean?</p>



<a name="403305449"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403305449" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403305449">(Nov 21 2023 at 05:25)</a>:</h4>
<p>yes</p>



<a name="403306613"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403306613" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403306613">(Nov 21 2023 at 05:38)</a>:</h4>
<p>not a direct answer, but I could ask Stephanie Weirich if she could introduce us to someone who might have more experience with the problem (e.g. OCaml devs)</p>



<a name="403499147"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403499147" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403499147">(Nov 22 2023 at 02:05)</a>:</h4>
<p>ok I want to try to lay out some thoughts on this one, maybe it will help</p>



<a name="403499274"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403499274" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403499274">(Nov 22 2023 at 02:06)</a>:</h4>
<p>the goal is to have some way of saying (I guess on <code>Content</code>?) whether a given type is known to be recursive, and we want to set that during unification, such that by the time solving is done we just have that information going into mono</p>



<a name="403499439"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403499439" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403499439">(Nov 22 2023 at 02:07)</a>:</h4>
<p>the <code>occurs</code> strategy would be to, at certain points, walk through all the different variables in the type and see if any of them refer to the original type itself, and then recursively do that for all the variables until we either run out of things to recurse on or detect that the original type refers to itself.</p>
<p>this works, but is slow.</p>



<a name="403499779"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403499779" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403499779">(Nov 22 2023 at 02:10)</a>:</h4>
<p>another idea would be to track the set of all the variables each variable references, including transitively, as we go</p>



<a name="403499826"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403499826" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403499826">(Nov 22 2023 at 02:11)</a>:</h4>
<p>but that also sounds slow (maybe even slower)</p>



<a name="403500598"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403500598" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403500598">(Nov 22 2023 at 02:16)</a>:</h4>
<p>yeah</p>



<a name="403501113"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403501113" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403501113">(Nov 22 2023 at 02:20)</a>:</h4>
<p>I think it's helpful to work out of this example, just based on first principles.</p>
<div class="codehilite"><pre><span></span><code>mapper = \l, f -&gt; when l is
  Nil -&gt; Nil
  Cons x xs -&gt; Cons (f x) (mapper xs f)
</code></pre></div>
<p>In more detail, let's consider what it takes to infer the type of <code>l</code> here.</p>
<div class="codehilite"><pre><span></span><code>1. `l` is introduced. Give it some type variable `v1`.
2. We encounter `Nil` and `Cons x xs` matched against `l`. Suppose typeof&lt;Nil&gt; = [Nil] and typeof&lt;Cons x xs&gt; = [Cons v2 v3]. Then we set v1 = [Nil, Cons v2 v3]
3. We encounter `mapper xs f`. This induces the constraint `v3 = v1`. So now we have v1 = [Nil, Cons v2 v1].
</code></pre></div>
<p>This type is correct but what we'd like is to note at that point that we should store somewhere (e.g. a lookaside table) that v1 is recursive in itself</p>



<a name="403501306"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403501306" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403501306">(Nov 22 2023 at 02:21)</a>:</h4>
<p>For what it's worth,</p>
<blockquote>
<p>the occurs strategy would be to, at certain points, walk through all the different variables in the type and see if any of them refer to the original type itself, and then recursively do that for all the variables until we either run out of things to recurse on or detect that the original type refers to itself.</p>
</blockquote>
<p>Is what we currently do, but only for tag unions. And it's half baked. So we could add it to more places but i'm not sure that scales. For example, we 'd need to also add it to be able to infer something like <code>X : (Str, List X)</code> as recursive properly. And I'm sure there are more cases like this.</p>



<a name="403501439"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403501439" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403501439">(Nov 22 2023 at 02:22)</a>:</h4>
<p>we currently do that during unification?</p>



<a name="403501448"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403501448" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403501448">(Nov 22 2023 at 02:22)</a>:</h4>
<p>yes</p>



<a name="403501476"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403501476" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403501476">(Nov 22 2023 at 02:23)</a>:</h4>
<p>for tags only</p>



<a name="403502065"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403502065" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403502065">(Nov 22 2023 at 02:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="454654">Ayaz Hafiz</span> <a href="#narrow/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation/near/403305191">said</a>:</p>
<blockquote>
<p>I realized we have to have at least a flag that tells us if a type is recursive, during unification. otherwise there's just no way to reliably generate code that needs to be boxed in certain places</p>
</blockquote>
<p>just to check my understanding: does this mean the original idea at the top of this thread can't work?</p>



<a name="403503086"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403503086" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403503086">(Nov 22 2023 at 02:34)</a>:</h4>
<p>for Roc's compilation strategy, i don't think it can</p>



<a name="403503134"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403503134" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403503134">(Nov 22 2023 at 02:35)</a>:</h4>
<p>although i just had an idea. maybe it only matters to mark the recursion points during specialization (monomorphization)</p>



<a name="403503160"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403503160" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403503160">(Nov 22 2023 at 02:35)</a>:</h4>
<p>since at that point you must traverse the full types anyway</p>



<a name="403503225"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403503225" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403503225">(Nov 22 2023 at 02:36)</a>:</h4>
<p>the problem is you can end up with duplicate specializations, potentially exponentially many</p>



<a name="403503262"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403503262" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403503262">(Nov 22 2023 at 02:36)</a>:</h4>
<p>but maybe that's not a problem in practice?</p>



<a name="403503353"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403503353" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403503353">(Nov 22 2023 at 02:37)</a>:</h4>
<p>what if we actually mutated the subs during specialization when doing that?</p>



<a name="403503778"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403503778" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403503778">(Nov 22 2023 at 02:40)</a>:</h4>
<p>like we're about to traverse a type, we see that we've never checked whether it's recursive or not, so we check that during the current specialization and then mark it in the subs so future specializations don't need to check again</p>



<a name="403503931"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403503931" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403503931">(Nov 22 2023 at 02:41)</a>:</h4>
<p><span class="user-mention silent" data-user-id="454654">Ayaz Hafiz</span> <a href="#narrow/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation/near/403503225">said</a>:</p>
<blockquote>
<p>the problem is you can end up with duplicate specializations, potentially exponentially many</p>
</blockquote>
<p>hm, why would checking for recursion during specialization cause <em>more</em> specializations? <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="403505513"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403505513" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403505513">(Nov 22 2023 at 02:53)</a>:</h4>
<p>Because consider for example we have that mapper function, but it's a more complex type <code>[Cons a {x: b}, Nil]</code>, and we need to specialize it twice. The first time we specialize it, it's because it's called with a type <code>b = [Cons a {x : b}, Nil]</code>.  But the second time we specialize it, it's because it's called with a type that had the determined recursion point in a different place, like <code>c = [Cons a (c = {x: b}), Nil]</code>. Since the specialization of <code>mapper</code> is determined by the caller, and the callers can be disjoint from each other, we can't adjust this.</p>
<p>This is the advantage of finding the recursion points up-front. If we found the recursion point in the generalized <code>mapper</code> definition, then each specialization would also inherit that recursion point during unification.</p>



<a name="403505563"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403505563" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403505563">(Nov 22 2023 at 02:53)</a>:</h4>
<p>also, don't we need to check for this during unification for error reporting?</p>
<p>e.g. <code>X : { y : X }</code> needs to report an error at compile time, and I'm not sure how we could know to do that without doing the work of answering the question of whether it's a (valid) recursive type</p>



<a name="403505669"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403505669" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403505669">(Nov 22 2023 at 02:54)</a>:</h4>
<p>I guess that's just limited to type alias declarations though</p>



<a name="403505689"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403505689" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403505689">(Nov 22 2023 at 02:54)</a>:</h4>
<p>and opaque type definitions</p>



<a name="403505749"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403505749" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403505749">(Nov 22 2023 at 02:55)</a>:</h4>
<p>yeah. type definitions are the easy version, cuz we can always add the recursion marker at that time</p>



<a name="403505757"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403505757" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403505757">(Nov 22 2023 at 02:55)</a>:</h4>
<p>nominal types make it easy</p>



<a name="403505786"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403505786" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403505786">(Nov 22 2023 at 02:55)</a>:</h4>
<p>nominal even in the sense of aliases. "Explicitly typed"</p>



<a name="403505896"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403505896" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403505896">(Nov 22 2023 at 02:56)</a>:</h4>
<p>because they tell you where the recursion (and hence where you should compile as boxed) should happen</p>



<a name="403506495"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403506495" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403506495">(Nov 22 2023 at 03:00)</a>:</h4>
<p>so going back to your example of calling with two specializations - what I was suggesting earlier is that the first specialization would essentially do what the occurs check during unification would do</p>



<a name="403506656"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403506656" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403506656">(Nov 22 2023 at 03:01)</a>:</h4>
<p>such that by the end of the specialization we'd have a generalized answer</p>



<a name="403506919"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403506919" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403506919">(Nov 22 2023 at 03:02)</a>:</h4>
<p>hm but I guess that doesn't work because the specialization wouldn't have access to the original variables during specialization <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="403506957"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403506957" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403506957">(Nov 22 2023 at 03:03)</a>:</h4>
<p>What if the first specialization makes it so that <code>[Cons a {x: b}, Nil]</code> is specialized to <code>[Cons Int {x: self}, Nil]</code>? You need to roll the changes back, and now you've lost the markers right?</p>



<a name="403669335"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403669335" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403669335">(Nov 22 2023 at 21:43)</a>:</h4>
<p>I wonder how OCaml does this</p>



<a name="403669404"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403669404" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403669404">(Nov 22 2023 at 21:44)</a>:</h4>
<p>because no matter how often people use polymorphic variants, having them in the language at all means you have to do this analysis</p>



<a name="403669458"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403669458" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403669458">(Nov 22 2023 at 21:44)</a>:</h4>
<p>and OCaml's compiler has a good reputation for performance, so either <code>occurs</code> is not that expensive in practice (although that would surprise me) or else maybe they found something else that works</p>



<a name="403675479"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403675479" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Elias Mulhall <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403675479">(Nov 22 2023 at 22:39)</a>:</h4>
<p>FWIW I think polymorphic variants are usually used pretty sparingly in OCaml code. The general wisdom is that polymorphic variants produce less efficient compiled code. I haven't heard anything about impacting compile times, but there might be a similar philosophy where you're trading speed for flexibility.</p>



<a name="403677134"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403677134" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403677134">(Nov 22 2023 at 22:57)</a>:</h4>
<p>yeah the thing is that just because they exist in the language at all, this analysis has to happen</p>



<a name="403677192"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403677192" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403677192">(Nov 22 2023 at 22:58)</a>:</h4>
<p>how often they're used only affects how often the analysis comes back with the answer being yes vs no, but it's the same amount of work to get the answer either way</p>



<a name="403677414"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403677414" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403677414">(Nov 22 2023 at 23:00)</a>:</h4>
<p>I asked how OCaml does this and got some answers: <a href="https://twitter.com/rtfeldman/status/1727443546897252521">https://twitter.com/rtfeldman/status/1727443546897252521</a></p>



<a name="403677571"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403677571" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403677571">(Nov 22 2023 at 23:01)</a>:</h4>
<p>this one is interesting, but if it's correct, it's not something we could do: <a href="https://twitter.com/welltypedwitch/status/1727449171207074289">https://twitter.com/welltypedwitch/status/1727449171207074289</a></p>



<a name="403677606"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403677606" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403677606">(Nov 22 2023 at 23:01)</a>:</h4>
<p>it didn't occur to me that OCaml could get away with not having that info once type checking is done, but maybe they can?</p>



<a name="403679847"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403679847" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403679847">(Nov 22 2023 at 23:24)</a>:</h4>
<p>I'm pretty sure this is a non-problem for OCaml. Inference of recursive types is not really the issue (that part is easy, just eagerly unify all types you compared). Figuring out where recursive types "are recursive" is the problem, and OCaml doesn't have that issue because it boxes ~everything (so codegen doesn't need to care about where the point of recursion happens). At least that's my understanding</p>



<a name="403679868"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403679868" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403679868">(Nov 22 2023 at 23:24)</a>:</h4>
<p>Put another way, the problem for us is that during code generation you must translate a structural type to an equivalent nominal type.</p>



<a name="403679918"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403679918" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403679918">(Nov 22 2023 at 23:25)</a>:</h4>
<p>unrelated, but fwiw OCaml doesn't support recursive types of the form <code>X : (X, List X)</code> in general. See <a href="https://caml.inria.fr/pub/docs/oreilly-book/html/book-ora209.html">https://caml.inria.fr/pub/docs/oreilly-book/html/book-ora209.html</a></p>



<a name="403680115"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403680115" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403680115">(Nov 22 2023 at 23:27)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281383">Richard Feldman</span> <a href="#narrow/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation/near/403677571">said</a>:</p>
<blockquote>
<p>this one is interesting, but if it's correct, it's not something we could do: <a href="https://twitter.com/welltypedwitch/status/1727449171207074289">https://twitter.com/welltypedwitch/status/1727449171207074289</a></p>
</blockquote>
<p>I'm pretty sure this description is <a href="#narrow/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation/near/401632093">https://roc.zulipchat.com/#narrow/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation/near/401632093</a>. I think by "reference" they mean "are these two type variables equivalent", which is the standard way to infer recursive types</p>



<a name="403684830"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403684830" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403684830">(Nov 23 2023 at 00:25)</a>:</h4>
<p><span class="user-mention silent" data-user-id="454654">Ayaz Hafiz</span> <a href="#narrow/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation/near/403679918">said</a>:</p>
<blockquote>
<p>unrelated, but fwiw OCaml doesn't support recursive types of the form <code>X : (X, List X)</code> in general. See <a href="https://caml.inria.fr/pub/docs/oreilly-book/html/book-ora209.html">https://caml.inria.fr/pub/docs/oreilly-book/html/book-ora209.html</a></p>
</blockquote>
<p>just checking, but was this meant to be <code>X : (Str, List X)</code> or similar? I don't think <code>X : (X, ...)</code> is possible in general <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span></p>



<a name="403689016"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403689016" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403689016">(Nov 23 2023 at 01:24)</a>:</h4>
<p>Right, thanks for the clarification</p>



<a name="403769442"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403769442" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403769442">(Nov 23 2023 at 11:23)</a>:</h4>
<p>I wonder if it's possible somehow to make <code>occurs</code> cheap <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="403769476"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403769476" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403769476">(Nov 23 2023 at 11:23)</a>:</h4>
<p>like by trying to arrange it such that everything we're checking is already in cache</p>



<a name="403808554"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403808554" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403808554">(Nov 23 2023 at 15:17)</a>:</h4>
<p>here's an idea: what if during unification we record in <code>Content</code> whether a type is concrete? That should be super cheap.</p>
<p>Then we do an <code>occurs</code> check except it short-circuits on concrete types because we know they're either not recursive or else they're nominal and therefore we already know where they recurse</p>



<a name="403808656"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403808656" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403808656">(Nov 23 2023 at 15:18)</a>:</h4>
<p>maybe that would cheaply reduce the number of occurs checks low enough to be fast in practice?</p>



<a name="403808815"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403808815" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403808815">(Nov 23 2023 at 15:19)</a>:</h4>
<p>v1 is concrete in <a href="#narrow/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation/near/403501113">https://roc.zulipchat.com/#narrow/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation/near/403501113</a>. How do you detect the recursion point there?</p>



<a name="403809337"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403809337" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403809337">(Nov 23 2023 at 15:22)</a>:</h4>
<p>ugh I'm on mobile and the link doesn't work - what's something I can search for to see where that is? <span aria-label="sweat smile" class="emoji emoji-1f605" role="img" title="sweat smile">:sweat_smile:</span></p>



<a name="403810128"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403810128" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403810128">(Nov 23 2023 at 15:26)</a>:</h4>
<p>My message from Nov21 in this thread that starts with I think it's helpful to work out of this example, just based on first principles.</p>



<a name="403811117"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403811117" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403811117">(Nov 23 2023 at 15:32)</a>:</h4>
<p>hm, yeah fair point <span aria-label="thinking" class="emoji emoji-1f914" role="img" title="thinking">:thinking:</span></p>



<a name="403814241"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403814241" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403814241">(Nov 23 2023 at 15:53)</a>:</h4>
<p>so I guess part of the challenge is that the last unification, <code>v1 = v3</code>, is isolated and doesn't "realize" the implication that it just created a loop</p>



<a name="403814516"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403814516" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403814516">(Nov 23 2023 at 15:55)</a>:</h4>
<p>I wonder if there's some (typically small) set of variables we could keep track of that are "potentially recursive" and then use simd to check them 4 at a time every time we resolve an equals constraint?</p>



<a name="403814580"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403814580" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403814580">(Nov 23 2023 at 15:56)</a>:</h4>
<p>but maybe everything is potentially recursive as far as we can tell</p>



<a name="403817642"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403817642" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403817642">(Nov 23 2023 at 16:14)</a>:</h4>
<p>so I guess one of the questions is "when to check" right?</p>



<a name="403817703"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403817703" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403817703">(Nov 23 2023 at 16:15)</a>:</h4>
<p>(I realize I'm catching up on a lot of questions you've probably already thought of, appreciate the patience <span aria-label="laughing" class="emoji emoji-1f606" role="img" title="laughing">:laughing:</span>)</p>



<a name="403818268"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403818268" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403818268">(Nov 23 2023 at 16:19)</a>:</h4>
<p>it seems like if we tried to do a full check after resolving every eq constraint, that would be what worse than if we just did one pass at the end, before mono</p>



<a name="403818403"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403818403" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403818403">(Nov 23 2023 at 16:20)</a>:</h4>
<p>although I guess that depends a lot on cache behavior</p>



<a name="403824870"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403824870" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403824870">(Nov 23 2023 at 17:08)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281383">Richard Feldman</span> <a href="#narrow/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation/near/403817642">said</a>:</p>
<blockquote>
<p>so I guess one of the questions is "when to check" right?</p>
</blockquote>
<p>yeah</p>



<a name="403967665"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403967665" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403967665">(Nov 24 2023 at 13:26)</a>:</h4>
<p><span class="user-mention silent" data-user-id="454654">Ayaz Hafiz</span> <a href="#narrow/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation/near/403503134">said</a>:</p>
<blockquote>
<p>although i just had an idea. maybe it only matters to mark the recursion points during specialization (monomorphization)</p>
</blockquote>
<p>so what if we started with this, and then whenever we detect a recursion point during specialization, we go look up the name of the function we're specializing, look up its unspecializd type and canonical IR, and then do a check of that whole function looking for recursion points and writing them down in subs.</p>
<p>That way, if any future specializations run into this, they will all use the same one.</p>



<a name="403967881"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/403967881" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#403967881">(Nov 24 2023 at 13:27)</a>:</h4>
<p>the theory would be that this wouldn't come up often in practice, so doing extra work (but only 1 extra pass per recursion point, not N of them) would be fine in practice</p>



<a name="404027980"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/404027980" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#404027980">(Nov 24 2023 at 22:54)</a>:</h4>
<blockquote>
<p>whenever we detect a recursion point during specialization, we go look up the name of the function we're specializing, look up its unspecializd type and canonical IR, and then do a check of that whole function looking for recursion points and writing them down in subs.</p>
</blockquote>
<p>I'm not sure that this gets us much. Like, if there are specializations that force the recursion point to occur in a different place, then we still require another specialization - and now we may have two places in the type that we need to Box, instead of just one</p>



<a name="404028191"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Allowing%20implicit%20cycles%20in%20the%20type%20representation/near/404028191" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Allowing.20implicit.20cycles.20in.20the.20type.20representation.html#404028191">(Nov 24 2023 at 22:57)</a>:</h4>
<p>But I agree we should do this. More specializations has only the downside of more code to generate, and you can bound the number of specializations by using an explicit type annotation</p>



<hr><p>Last updated: Mar 01 2026 at 12:20 UTC</p>
</html>