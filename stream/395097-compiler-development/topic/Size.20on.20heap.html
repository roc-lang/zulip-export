<html>
<head><meta charset="utf-8"><title>Size on heap · compiler development · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/index.html">compiler development</a></h2>
<h3>Topic: <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html">Size on heap</a></h3>

<hr>

<base href="https://roc.zulipchat.com">

<head><link href="https://roc-lang.github.io/zulip-export/style.css" rel="stylesheet"></head>

<a name="407161704"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/407161704" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#407161704">(Dec 11 2023 at 05:18)</a>:</h4>
<p>For the change to put the size of a list (number of elements) on the heap, the size is only put on the heap for lists that actually have refcounted elements. So if it is a string (list u8), there will be no size on the heap. As such, I was thinking that this would be modeled directly and piped around through the bitcode.</p>
<p>This is a base commit of just changing the zig bitcode to see what that would look like (obviously a lot more pipelining is needed in all of the backends). Does this approach seam reasonable? Is there a better way I should do this?</p>
<p><a href="https://github.com/roc-lang/roc/commit/638cc7780c46b94239af90d431b1e84c806921d6">https://github.com/roc-lang/roc/commit/638cc7780c46b94239af90d431b1e84c806921d6</a></p>
<p>Note: the zig in this change is definitly not fully converted. I also need to go through and remove a bunch of recursive refcount changes that will no longer happen. Now, recursive increments should only happen on creating a new unique copy of a list and recursive decrements should only happen on deallocation. All other increments and decrements should only happen to the outer list non-recursively.</p>



<a name="407161866"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/407161866" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#407161866">(Dec 11 2023 at 05:20)</a>:</h4>
<p><span class="user-mention" data-user-id="281543">@Folkert de Vries</span> I assume you are most likely to have input here. Though the input may just be that I am gonna have a <em>really</em> fun time updating every single location that can call the bitcode paths.</p>
<p>On the rust side, this variable will be initialized as <code>interner.contains_refcounted(element_layout)</code></p>



<a name="407161947"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/407161947" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#407161947">(Dec 11 2023 at 05:20)</a>:</h4>
<p>And for types like unions and strings that are allocated with these helpers but don't have an element type, it will just be set to false.</p>



<a name="407166739"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/407166739" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#407166739">(Dec 11 2023 at 06:04)</a>:</h4>
<p>One extra piece that I am realizing that will be kinda inconvenient to pipeline through is specifically for list incref. If a list has refcounted elements and is incrementing from a refcount of 1 to 2, we need to save it's size to the heap. This means that we either need to pass all of this information to all incref functions, or we need to make a custom incref function for list and distinguish this in all cases (so like dispatching correctly when we have a struct that has a union in it that has a list of refcounted data in that).</p>



<a name="407172781"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/407172781" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#407172781">(Dec 11 2023 at 06:49)</a>:</h4>
<p>Although may be best to overall reduce the footprint of all of these versions and just make a list specific version of incref and decref that is exposed to the backends. Then each backend has to code gen based on if something is a list or not and only for lists they would pass in whether or not an element is refcount. Probably will be easier to follow and a bit more performant than if these variables are pervasive to literally all recounting functions.</p>
<p>.... Just trying to brainstorm what will end up being the nicest way to do this.</p>



<a name="407186971"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/407186971" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Folkert de Vries <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#407186971">(Dec 11 2023 at 08:16)</a>:</h4>
<p>did I miss something? why do we want this?</p>



<a name="407264234"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/407264234" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#407264234">(Dec 11 2023 at 15:28)</a>:</h4>
<p>This is to fix the reverse list refcounting.</p>



<a name="407264377"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/407264377" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#407264377">(Dec 11 2023 at 15:29)</a>:</h4>
<p>When list recount is normally incremented or decremented it will just be the main list from now on</p>



<a name="407264643"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/407264643" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#407264643">(Dec 11 2023 at 15:30)</a>:</h4>
<p>Only on making a new unique copy of a list or fully deallocating a list with the recursive refcount need to happen.</p>



<a name="407264909"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/407264909" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#407264909">(Dec 11 2023 at 15:31)</a>:</h4>
<p>Since a seamless slice does not know the size of the original list, it is unable to free all of the elements if it is the last reference to the list.</p>



<a name="407265000"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/407265000" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#407265000">(Dec 11 2023 at 15:32)</a>:</h4>
<p>So we have to put the size on the heap to enable this feature.</p>



<a name="407265369"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/407265369" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#407265369">(Dec 11 2023 at 15:33)</a>:</h4>
<p>When chatting with Richard about this, he suggested that to avoid adding the size before all strings and lists even ones where it isn't really needed, we can decided to added it or not and do this extra logic based on if the element is refcounted or not. If the element is not refcounted, then it never has recursive refocounts anyway.</p>



<a name="407266238"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/407266238" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#407266238">(Dec 11 2023 at 15:38)</a>:</h4>
<p>Main goal is to fix perf bugs like this:</p>
<p><span class="user-mention silent" data-user-id="343810">Brendan Hansknecht</span> <a href="#narrow/stream/231634-beginners/topic/Profiling.20an.20AoC.20app/near/406961712">said</a>:</p>
<blockquote>
<p>Purple is refcounting. It is 98.6% of the program execution: <br>
<a href="/user_uploads/22008/I1tRBIHi3RfmhPQ2GMDFdpwj/Screenshot-2023-12-09-at-10.30.06AM.png">Screenshot-2023-12-09-at-10.30.06AM.png</a></p>
</blockquote>



<a name="407514182"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/407514182" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Folkert de Vries <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#407514182">(Dec 12 2023 at 16:21)</a>:</h4>
<p>ah, sure</p>



<a name="407514235"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/407514235" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Folkert de Vries <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#407514235">(Dec 12 2023 at 16:21)</a>:</h4>
<p>that makes sense</p>



<a name="407812824"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/407812824" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#407812824">(Dec 13 2023 at 21:24)</a>:</h4>
<p><span class="user-mention" data-user-id="281543">@Folkert de Vries</span>, One other question on this. If I pull all the list refcounting into it's own function. So Lists always call <code>roc_builtins.list.incref</code> or something like that, do you see any issue with building the dispatch? I assume that all of the generation for our refcounting functions will have all the information needed to be able to at compile time pick which version to call (generic refcount vs list refcount), correct?</p>



<a name="407817425"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/407817425" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Folkert de Vries <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#407817425">(Dec 13 2023 at 21:58)</a>:</h4>
<p>we generate specific functions to inc/dec a list. you'll need to adjust those functions (and only those functions) I think?</p>



<a name="407817548"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/407817548" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#407817548">(Dec 13 2023 at 21:59)</a>:</h4>
<p>Ok</p>



<a name="408982221"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/408982221" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#408982221">(Dec 19 2023 at 17:16)</a>:</h4>
<p>I am starting to look at this a bit more and realizing that tons more list functions now need to take an element <code>incref</code> and element <code>decref</code> function.  Cause anything that might free a list (even a potentially empty one) now needs an element decref function. And anything that might make a new allocation of a list now needs an element incref function.</p>
<p>So instead of having one main location for incref and decref, it is much more distributed. Just so many args to pass around then pipe through all calling functions. Not hard, just a lot of work and a good chance that I will mess something up and create some mem leaks or other issues.</p>



<a name="408982465"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/408982465" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Folkert de Vries <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#408982465">(Dec 19 2023 at 17:17)</a>:</h4>
<p>yes (that is why this never happened). in valgrind we trust I suppose</p>



<a name="408983062"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/408983062" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#408983062">(Dec 19 2023 at 17:21)</a>:</h4>
<p>yeah, if this wasn't so important for performance, I definitely wouldn't want to take on the complexity.</p>
<p>Like I guess we could try the borrowing idea first and see if this is still needed. With the borrowing idea, functions that just read would be saved from the horrid recursive refcounts. Functions that might modify hopefully would take a unique list anyway. So they would take ownership of the list and no refcount changes would be needed.</p>



<a name="408983632"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/408983632" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#408983632">(Dec 19 2023 at 17:25)</a>:</h4>
<p>Borrowing would just be analysis of the mono ir. Starting at the leaf node functions and working back to the root. For any function that a list could be modified or return, we label it as owning. For all other functions, borrowing. Then for borrowing functions, we skip all the refcount inc and dec. Not sure how hard that analysis would be in practice, but seems like it would mostly be a matter of walking the ir and tracking variables.</p>



<a name="408983987"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/408983987" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#408983987">(Dec 19 2023 at 17:27)</a>:</h4>
<p>I think the biggest concern for borrowing will be records. Cause we would probably check for borrowing of the record as a whole rather than for borrowing of each field in a record. Thus a function that changes one field in a record, but doesn't touch a refcounted list field would also need to increment the refcount of that list.</p>



<a name="408985800"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/408985800" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#408985800">(Dec 19 2023 at 17:39)</a>:</h4>
<p>Just debating the effort, gain, and complexity trade off. Especially considering this is a big pain point hit by many many people working on AOC currently, so would be nice to fix them sooner (even if not a complete fix but more a workaround).</p>



<a name="408987443"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/408987443" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#408987443">(Dec 19 2023 at 17:50)</a>:</h4>
<p>yeah my overall thoughts on this are:</p>
<ol>
<li>In general I'm very much in favor of trying out more aggressive borrowing strategies. I know there's a concern about potentially blowing up the number of specializations (and therefore binary size and compile times), but that seems like one of those things where we can't really know how big (or little) of a problem it is without actually trying it. It seems very hard to predict how often it would come up in real-world programs. Like maybe in practice it's totally fine because—much like how <code>let</code> inference has theoretically abysmal worst-case performance, in practice it just turns out people don't write programs in the way that would trigger the pathological case.</li>
<li>Regarding borrowing of record fields, I assume that could be treated as a separate project, right? Like it wouldn't have to block trying out a borrowing design that didn't treat records differently (at least at first).</li>
<li>The upside potential on borrowing inference seems clearly higher in the sense that there would presumably be a lot of refcounts eliminated across programs even in other scenarios than this one.</li>
</ol>



<a name="408987604"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/408987604" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#408987604">(Dec 19 2023 at 17:51)</a>:</h4>
<blockquote>
<ol start="2">
<li>Regarding borrowing of record fields, I assume that could be treated as a separate project, right? Like it wouldn't have to block trying out a borrowing design that didn't treat records differently (at least at first).</li>
</ol>
</blockquote>
<p>100%</p>



<a name="408987794"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/408987794" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#408987794">(Dec 19 2023 at 17:52)</a>:</h4>
<p>Do you think it is likely that borrow inference could remove the need for these other changes that deal with recursive refcounts? Or do you think we would likely need both?</p>



<a name="408988096"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/408988096" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#408988096">(Dec 19 2023 at 17:55)</a>:</h4>
<p>personally I have no idea; others would have a better idea about that than I would <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span></p>



<a name="408988177"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/408988177" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#408988177">(Dec 19 2023 at 17:55)</a>:</h4>
<p>fair enough. I think it would fix all of the cases getting hit by the AOC currently.</p>



<a name="409028791"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409028791" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409028791">(Dec 19 2023 at 22:49)</a>:</h4>
<p>So. I decided to do a manual MVC of borrowing. The borrowing is just hardcoded for <a href="https://github.com/lindskogen/advent-of-code-2023/blob/a0c49f6c6061f20619fcb05a8f855ac4bf6c05ce/day16/main.roc">an example AOC app that recently hit big perf issues the other day</a>.</p>
<p>Changes here: <a href="https://github.com/roc-lang/roc/compare/main...borrowing-hacks">https://github.com/roc-lang/roc/compare/main...borrowing-hacks</a></p>
<p>At least for this arbitrary app, this 100% fixes the perf issue. Comparing the borrowing hack branch to a manual workaround of using <code>U8</code>s instead of strings:</p>
<div class="codehilite"><pre><span></span><code>Benchmark 1: /tmp/aoc-borrowing
  Time (mean ± σ):     259.1 ms ±   1.8 ms    [User: 255.9 ms, System: 1.3 ms]
  Range (min … max):   256.8 ms … 263.0 ms    11 runs

Benchmark 2: /tmp/aoc-workaround
  Time (mean ± σ):     253.7 ms ±   4.5 ms    [User: 249.8 ms, System: 1.5 ms]
  Range (min … max):   247.7 ms … 262.5 ms    11 runs

Summary
  &#39;/tmp/aoc-workaround&#39; ran
    1.02 ± 0.02 times faster than &#39;/tmp/aoc-borrowing&#39;
</code></pre></div>
<p>Without the fix, this app takes ~70 seconds on my M1 mac. So borrowing is definitely very promising. Still not sure how often borrowing will fail to help. I guess the cases where we will still need size on heap will be cases where the same value is passed to multiple different functions that each might modify it. So none of those function can borrow it and we need to increment and decrements refcounts around each function. Of course, if the function modifies, the refcounting was needed anyway and is not cost. So it would only matter if the functions are unlikely to modify the value. So long term we may still want both, but maybe there is another better optimization for situations like those.</p>



<a name="409029202"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409029202" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409029202">(Dec 19 2023 at 22:52)</a>:</h4>
<p>wow, 70 seconds to 250ms is...quite a difference <span aria-label="laughing" class="emoji emoji-1f606" role="img" title="laughing">:laughing:</span></p>



<a name="409029237"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409029237" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409029237">(Dec 19 2023 at 22:53)</a>:</h4>
<p>how does the borrowing inference algorithm work here?</p>



<a name="409029401"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409029401" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409029401">(Dec 19 2023 at 22:54)</a>:</h4>
<p>incrementing and decrementing <code>12100</code> refcounts in a hot loop is slow....who would have guessed.</p>



<a name="409030263"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409030263" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409030263">(Dec 19 2023 at 23:01)</a>:</h4>
<p>In this case there is no inference algorithm, I just manually labeled some functions and joinpoints.</p>



<a name="409030423"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409030423" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409030423">(Dec 19 2023 at 23:02)</a>:</h4>
<p>Then updated the refcount insertion algorithm to obey those new annotations.</p>



<a name="409030677"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409030677" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409030677">(Dec 19 2023 at 23:04)</a>:</h4>
<p>The manual labeling is at the bottom of the code changes.</p>



<a name="409032124"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409032124" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409032124">(Dec 19 2023 at 23:18)</a>:</h4>
<p>gotcha... <span class="user-mention" data-user-id="281543">@Folkert de Vries</span> <span class="user-mention" data-user-id="454654">@Ayaz Hafiz</span> I know you've both talked about thoughts around borrow inference in the past - what do you think of the idea of trying it out and seeing if there's an explosion of specializations in practice vs not? (Maybe there's some way we could answer that question without implementing the whole thing?)</p>



<a name="409032219"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409032219" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409032219">(Dec 19 2023 at 23:19)</a>:</h4>
<p>Why would it explode specialization?</p>



<a name="409032261"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409032261" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409032261">(Dec 19 2023 at 23:20)</a>:</h4>
<p>In my mind, each function has exactly one borrowing signature based on its implementation.</p>



<a name="409065297"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409065297" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409065297">(Dec 20 2023 at 02:20)</a>:</h4>
<p>Don't we already have a borrow inference algorithm?</p>



<a name="409065345"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409065345" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409065345">(Dec 20 2023 at 02:21)</a>:</h4>
<p>At least Morphic definitely specializes based on borrows</p>



<a name="409065480"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409065480" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409065480">(Dec 20 2023 at 02:21)</a>:</h4>
<p>The specialization is because you can you specialize a function to take its arguments as owned, and one to take arguments as borrowed (so potentially 2^N in the number of arguments)</p>



<a name="409070991"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409070991" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409070991">(Dec 20 2023 at 02:48)</a>:</h4>
<p>Sure, but if you can take as borrowed, why would you ever take as owned?</p>



<a name="409073872"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409073872" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ayaz Hafiz <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409073872">(Dec 20 2023 at 03:02)</a>:</h4>
<p>Because it could avoid a ref count if the borrowed version needs a ref<br>
count in some branch</p>



<a name="409079620"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409079620" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409079620">(Dec 20 2023 at 03:41)</a>:</h4>
<p>Hmm....I guess I need to see an example. Cause in my mind if a function borrows, all functions it calls must also borrow, so it just fully avoids refocounts.</p>
<p>With branches we have:</p>
<div class="codehilite"><pre><span></span><code># this is called from a function that owns a.
# it has to own a cause it calls another owning function
if ... then
   owningFn a
else
    # references a to generate some new value
    borrowingFn a
</code></pre></div>
<p>The first one has to be owning cause it mutates. The second one we have the choice, of borrowing or owning. That said, it is always fine to borrow (sometime minor delay in freeing memory) and depending on the exact use borrowing will be better.</p>
<p>The second branch is one of these two:</p>
<div class="codehilite"><pre><span></span><code># borrow
else
    borrowingFn a
    dec a

# own
else
    # will Dec at some point inside of the function.
    borrowingForceOwningFn a
</code></pre></div>
<p>Those two are essentially the same, both have one decref, but owning frees memory potentially earlier. That said, it is the only case where borrowing is a disadvantage. If the borrowing function returns a value and then we use a, it will be strictly better for the function to borrow. Would look something like this:</p>
<div class="codehilite"><pre><span></span><code># borrow
else
    someVal = borrowingFn a
    # use some val and a

# own
else
    inc a
    # will Dec at some point inside of the function.
    someVal = borrowingForceOwningFn a
    # use some val and a
</code></pre></div>
<p>Am I missing something. Besides the chance of a delayed free, I see no disadvantage of always borrowing when possible.</p>



<a name="409138158"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409138158" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Folkert de Vries <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409138158">(Dec 20 2023 at 10:09)</a>:</h4>
<p>yeah I think with the simple heuristic (any mutation opportunity -&gt; owned, otherwise borrowed) you don't get excess specializations. There is just the risk of keeping allocations around for much longer than needed if something gets borrowed but is not actually used in practice</p>



<a name="409138622"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409138622" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Folkert de Vries <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409138622">(Dec 20 2023 at 10:11)</a>:</h4>
<p>maybe there should be some mechanism to force ownership regardless, a fake mutation</p>



<a name="409138921"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409138921" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Folkert de Vries <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409138921">(Dec 20 2023 at 10:12)</a>:</h4>
<p>also, the "can it be mutated" value is not that easy to determine precisely for tag unions: we determine reuse based on drops, but drops are of course inserted differently for owned/borrowed values</p>



<a name="409139268"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409139268" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Folkert de Vries <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409139268">(Dec 20 2023 at 10:13)</a>:</h4>
<p>you can statically know that there are no reuse opportunities at all in a function, but once there are, you must pass the value as owned even if in practice the value is never updated because the structure of the function does not allow it</p>



<a name="409221678"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409221678" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409221678">(Dec 20 2023 at 16:34)</a>:</h4>
<p><span class="user-mention silent" data-user-id="281543">Folkert de Vries</span> <a href="#narrow/stream/395097-compiler-development/topic/Size.20on.20heap/near/409138158">said</a>:</p>
<blockquote>
<p>yeah I think with the simple heuristic (any mutation opportunity -&gt; owned, otherwise borrowed) you don't get excess specializations. There is just the risk of keeping allocations around for much longer than needed if something gets borrowed but is not actually used in practice</p>
</blockquote>
<p>I could be wrong, but I suspect this would be fine in Roc's case because things are always given to the host as owned, so if they did go longer than necessary without being deallocated, it would only be until the next io operation</p>



<a name="409226707"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409226707" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409226707">(Dec 20 2023 at 17:02)</a>:</h4>
<p>I think the heuristic would be in practices:</p>
<p>potentially passed to an owning function or returned from the function -&gt; owned<br>
otherwise -&gt; borrow</p>
<p>Also, borrowing is the default in rust for cases like this, and it tends not to be a memory probably. So I bet it would be fine in Roc.</p>



<a name="409229933"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409229933" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409229933">(Dec 20 2023 at 17:19)</a>:</h4>
<p>I know this is jumping back some, but I decided to attempt to update the entire bitcode for size on heap (just to see what it would look like in practice). I'm sure it has bugs, but I think this is the full bitcode updated (wish we had more zig tests cause they can all catch memory issues). Well, also need to remove our eager element decrementing in various functions.<br>
<a href="https://github.com/roc-lang/roc/compare/main...list-size-on-heap">https://github.com/roc-lang/roc/compare/main...list-size-on-heap</a></p>
<p>Changes the api for essentially every list function and the utils refcounting functions. So that would need to be wired through to every calling location in the compiler. Would be a matter of generating and passing more element increment and decrement functions to these various locations. Would also require ensuring all list refcounting goes through the new zig exposed list refcounting functions.</p>
<p>So I think it would be a slog with a lot of bugs to work through once wired up, but definitely doable. Should be a lot of the same at least with a similar pattern of changes for all of the functions.</p>
<p>I still think the borrowing changes will be a fundamental need, but as I was manually testing borrowing and thinking about edge cases, I get more and more the feeling that both of these changes will be needed.</p>



<a name="409233688"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409233688" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Richard Feldman <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409233688">(Dec 20 2023 at 17:44)</a>:</h4>
<p>I buy that! Does anyone think we shouldn't at least <em>try</em> both and see what we run into in practice? (Especially <span class="user-mention" data-user-id="281543">@Folkert de Vries</span> or <span class="user-mention" data-user-id="454654">@Ayaz Hafiz</span> <span aria-label="big smile" class="emoji emoji-1f604" role="img" title="big smile">:big_smile:</span>)</p>



<a name="409233920"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409233920" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Folkert de Vries <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409233920">(Dec 20 2023 at 17:45)</a>:</h4>
<p>yes that sounds like a good idea</p>



<a name="409596990"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409596990" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anton <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409596990">(Dec 22 2023 at 15:03)</a>:</h4>
<blockquote>
<p>(wish we had more zig tests cause they can all catch memory issues)</p>
</blockquote>
<p><span class="user-mention" data-user-id="343810">@Brendan Hansknecht</span> I just remembered you saying this :p could you make an issue for it? This definitely sounds like something we should do.</p>



<a name="409600962"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/Size%20on%20heap/near/409600962" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/Size.20on.20heap.html#409600962">(Dec 22 2023 at 15:30)</a>:</h4>
<p><a href="https://github.com/roc-lang/roc/issues/6301">#6301</a></p>



<hr><p>Last updated: Nov 01 2025 at 12:13 UTC</p>
</html>