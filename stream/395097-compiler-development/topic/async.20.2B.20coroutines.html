<html>
<head><meta charset="utf-8"><title>async + coroutines · compiler development · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/index.html">compiler development</a></h2>
<h3>Topic: <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/async.20.2B.20coroutines.html">async + coroutines</a></h3>

<hr>

<base href="https://roc.zulipchat.com">

<head><link href="https://roc-lang.github.io/zulip-export/style.css" rel="stylesheet"></head>

<a name="545866860"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/async%20%2B%20coroutines/near/545866860" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Brendan Hansknecht <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/async.20.2B.20coroutines.html#545866860">(Oct 20 2025 at 00:24)</a>:</h4>
<p>Not really compiler development... more platform theorizing. I was chatting with <span class="user-mention" data-user-id="281383">@Richard Feldman</span> and one thing we discussed is the tradeoff between being in async land and being in coroutine land. As roc stands today (and for the planned future), we like nice synchronous apis. As such, we do not play nicely with async.</p>
<p>This can be seen very clearly in basic-webserver. We have an sync platform and it is calling into roc. At that point, we are a blocking workload in an async world and we don't have a clean way to run requests in the async system. This is pretty awful. We literally <code>spawn_blocking</code> and all of the effects that roc calls are sync. This essentially ruins most of the reasons you would use async rust.</p>
<p>That said, depending on the platform language, we still want to be able to integrate with their async ecosystem (e.g. the most robustly tested web servers in many languages are built on async). This is a pure rust prototype looking into bridging that gap. It is a lot of vibe coding, but the core is definitely something we could build out if wanted: <a href="https://github.com/bhansconnect/hyper-may-async-bridge">https://github.com/bhansconnect/hyper-may-async-bridge</a></p>
<p>It is a really basic webserver with a sample set of endpoints that all just hit simulated delay (sleep instead of real io). I tried to model a handful of situations that map reasonably to real workloads. The system is implemented in 100% async, 100% coroutines, and a hybrid that uses channels and condvars to syncronize between the two systems. Note, the coroutines are cooperative.</p>
<p>This is just a prototype. The perf seems to be reasonable, but definitely falls short of both fully async and fully coroutine. The cost is expected due to the forcing these two systems to communicate and share resources. That said, I definitely think there is room to squash a lot of the overhead. Technically speaking, the go runtime is a well integrated for the this kind of a perf hybrid.</p>
<p>I think for a next version of basic webserver that properly cooperates with async rust, this would be interesting to build off of.</p>



<a name="545871711"></a>
<h4><a href="https://roc.zulipchat.com#narrow/stream/395097-compiler%20development/topic/async%20%2B%20coroutines/near/545871711" class="zl"><img src="https://roc-lang.github.io/zulip-export/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Luke Boswell <a href="https://roc-lang.github.io/zulip-export/stream/395097-compiler-development/topic/async.20.2B.20coroutines.html#545871711">(Oct 20 2025 at 01:51)</a>:</h4>
<p>Real cool exploration <span class="user-mention" data-user-id="343810">@Brendan Hansknecht</span>, thank you for sharing.</p>



<hr><p>Last updated: Nov 01 2025 at 12:13 UTC</p>
</html>